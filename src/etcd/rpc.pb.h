// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "kv.pb.h"
#include "auth.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_rpc_2eproto;
namespace etcdserverpb {
class AlarmMember;
struct AlarmMemberDefaultTypeInternal;
extern AlarmMemberDefaultTypeInternal _AlarmMember_default_instance_;
class AlarmRequest;
struct AlarmRequestDefaultTypeInternal;
extern AlarmRequestDefaultTypeInternal _AlarmRequest_default_instance_;
class AlarmResponse;
struct AlarmResponseDefaultTypeInternal;
extern AlarmResponseDefaultTypeInternal _AlarmResponse_default_instance_;
class AuthDisableRequest;
struct AuthDisableRequestDefaultTypeInternal;
extern AuthDisableRequestDefaultTypeInternal _AuthDisableRequest_default_instance_;
class AuthDisableResponse;
struct AuthDisableResponseDefaultTypeInternal;
extern AuthDisableResponseDefaultTypeInternal _AuthDisableResponse_default_instance_;
class AuthEnableRequest;
struct AuthEnableRequestDefaultTypeInternal;
extern AuthEnableRequestDefaultTypeInternal _AuthEnableRequest_default_instance_;
class AuthEnableResponse;
struct AuthEnableResponseDefaultTypeInternal;
extern AuthEnableResponseDefaultTypeInternal _AuthEnableResponse_default_instance_;
class AuthRoleAddRequest;
struct AuthRoleAddRequestDefaultTypeInternal;
extern AuthRoleAddRequestDefaultTypeInternal _AuthRoleAddRequest_default_instance_;
class AuthRoleAddResponse;
struct AuthRoleAddResponseDefaultTypeInternal;
extern AuthRoleAddResponseDefaultTypeInternal _AuthRoleAddResponse_default_instance_;
class AuthRoleDeleteRequest;
struct AuthRoleDeleteRequestDefaultTypeInternal;
extern AuthRoleDeleteRequestDefaultTypeInternal _AuthRoleDeleteRequest_default_instance_;
class AuthRoleDeleteResponse;
struct AuthRoleDeleteResponseDefaultTypeInternal;
extern AuthRoleDeleteResponseDefaultTypeInternal _AuthRoleDeleteResponse_default_instance_;
class AuthRoleGetRequest;
struct AuthRoleGetRequestDefaultTypeInternal;
extern AuthRoleGetRequestDefaultTypeInternal _AuthRoleGetRequest_default_instance_;
class AuthRoleGetResponse;
struct AuthRoleGetResponseDefaultTypeInternal;
extern AuthRoleGetResponseDefaultTypeInternal _AuthRoleGetResponse_default_instance_;
class AuthRoleGrantPermissionRequest;
struct AuthRoleGrantPermissionRequestDefaultTypeInternal;
extern AuthRoleGrantPermissionRequestDefaultTypeInternal _AuthRoleGrantPermissionRequest_default_instance_;
class AuthRoleGrantPermissionResponse;
struct AuthRoleGrantPermissionResponseDefaultTypeInternal;
extern AuthRoleGrantPermissionResponseDefaultTypeInternal _AuthRoleGrantPermissionResponse_default_instance_;
class AuthRoleListRequest;
struct AuthRoleListRequestDefaultTypeInternal;
extern AuthRoleListRequestDefaultTypeInternal _AuthRoleListRequest_default_instance_;
class AuthRoleListResponse;
struct AuthRoleListResponseDefaultTypeInternal;
extern AuthRoleListResponseDefaultTypeInternal _AuthRoleListResponse_default_instance_;
class AuthRoleRevokePermissionRequest;
struct AuthRoleRevokePermissionRequestDefaultTypeInternal;
extern AuthRoleRevokePermissionRequestDefaultTypeInternal _AuthRoleRevokePermissionRequest_default_instance_;
class AuthRoleRevokePermissionResponse;
struct AuthRoleRevokePermissionResponseDefaultTypeInternal;
extern AuthRoleRevokePermissionResponseDefaultTypeInternal _AuthRoleRevokePermissionResponse_default_instance_;
class AuthUserAddRequest;
struct AuthUserAddRequestDefaultTypeInternal;
extern AuthUserAddRequestDefaultTypeInternal _AuthUserAddRequest_default_instance_;
class AuthUserAddResponse;
struct AuthUserAddResponseDefaultTypeInternal;
extern AuthUserAddResponseDefaultTypeInternal _AuthUserAddResponse_default_instance_;
class AuthUserChangePasswordRequest;
struct AuthUserChangePasswordRequestDefaultTypeInternal;
extern AuthUserChangePasswordRequestDefaultTypeInternal _AuthUserChangePasswordRequest_default_instance_;
class AuthUserChangePasswordResponse;
struct AuthUserChangePasswordResponseDefaultTypeInternal;
extern AuthUserChangePasswordResponseDefaultTypeInternal _AuthUserChangePasswordResponse_default_instance_;
class AuthUserDeleteRequest;
struct AuthUserDeleteRequestDefaultTypeInternal;
extern AuthUserDeleteRequestDefaultTypeInternal _AuthUserDeleteRequest_default_instance_;
class AuthUserDeleteResponse;
struct AuthUserDeleteResponseDefaultTypeInternal;
extern AuthUserDeleteResponseDefaultTypeInternal _AuthUserDeleteResponse_default_instance_;
class AuthUserGetRequest;
struct AuthUserGetRequestDefaultTypeInternal;
extern AuthUserGetRequestDefaultTypeInternal _AuthUserGetRequest_default_instance_;
class AuthUserGetResponse;
struct AuthUserGetResponseDefaultTypeInternal;
extern AuthUserGetResponseDefaultTypeInternal _AuthUserGetResponse_default_instance_;
class AuthUserGrantRoleRequest;
struct AuthUserGrantRoleRequestDefaultTypeInternal;
extern AuthUserGrantRoleRequestDefaultTypeInternal _AuthUserGrantRoleRequest_default_instance_;
class AuthUserGrantRoleResponse;
struct AuthUserGrantRoleResponseDefaultTypeInternal;
extern AuthUserGrantRoleResponseDefaultTypeInternal _AuthUserGrantRoleResponse_default_instance_;
class AuthUserListRequest;
struct AuthUserListRequestDefaultTypeInternal;
extern AuthUserListRequestDefaultTypeInternal _AuthUserListRequest_default_instance_;
class AuthUserListResponse;
struct AuthUserListResponseDefaultTypeInternal;
extern AuthUserListResponseDefaultTypeInternal _AuthUserListResponse_default_instance_;
class AuthUserRevokeRoleRequest;
struct AuthUserRevokeRoleRequestDefaultTypeInternal;
extern AuthUserRevokeRoleRequestDefaultTypeInternal _AuthUserRevokeRoleRequest_default_instance_;
class AuthUserRevokeRoleResponse;
struct AuthUserRevokeRoleResponseDefaultTypeInternal;
extern AuthUserRevokeRoleResponseDefaultTypeInternal _AuthUserRevokeRoleResponse_default_instance_;
class AuthenticateRequest;
struct AuthenticateRequestDefaultTypeInternal;
extern AuthenticateRequestDefaultTypeInternal _AuthenticateRequest_default_instance_;
class AuthenticateResponse;
struct AuthenticateResponseDefaultTypeInternal;
extern AuthenticateResponseDefaultTypeInternal _AuthenticateResponse_default_instance_;
class CompactionRequest;
struct CompactionRequestDefaultTypeInternal;
extern CompactionRequestDefaultTypeInternal _CompactionRequest_default_instance_;
class CompactionResponse;
struct CompactionResponseDefaultTypeInternal;
extern CompactionResponseDefaultTypeInternal _CompactionResponse_default_instance_;
class Compare;
struct CompareDefaultTypeInternal;
extern CompareDefaultTypeInternal _Compare_default_instance_;
class DefragmentRequest;
struct DefragmentRequestDefaultTypeInternal;
extern DefragmentRequestDefaultTypeInternal _DefragmentRequest_default_instance_;
class DefragmentResponse;
struct DefragmentResponseDefaultTypeInternal;
extern DefragmentResponseDefaultTypeInternal _DefragmentResponse_default_instance_;
class DeleteRangeRequest;
struct DeleteRangeRequestDefaultTypeInternal;
extern DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
class DeleteRangeResponse;
struct DeleteRangeResponseDefaultTypeInternal;
extern DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
class HashKVRequest;
struct HashKVRequestDefaultTypeInternal;
extern HashKVRequestDefaultTypeInternal _HashKVRequest_default_instance_;
class HashKVResponse;
struct HashKVResponseDefaultTypeInternal;
extern HashKVResponseDefaultTypeInternal _HashKVResponse_default_instance_;
class HashRequest;
struct HashRequestDefaultTypeInternal;
extern HashRequestDefaultTypeInternal _HashRequest_default_instance_;
class HashResponse;
struct HashResponseDefaultTypeInternal;
extern HashResponseDefaultTypeInternal _HashResponse_default_instance_;
class LeaseCheckpoint;
struct LeaseCheckpointDefaultTypeInternal;
extern LeaseCheckpointDefaultTypeInternal _LeaseCheckpoint_default_instance_;
class LeaseCheckpointRequest;
struct LeaseCheckpointRequestDefaultTypeInternal;
extern LeaseCheckpointRequestDefaultTypeInternal _LeaseCheckpointRequest_default_instance_;
class LeaseCheckpointResponse;
struct LeaseCheckpointResponseDefaultTypeInternal;
extern LeaseCheckpointResponseDefaultTypeInternal _LeaseCheckpointResponse_default_instance_;
class LeaseGrantRequest;
struct LeaseGrantRequestDefaultTypeInternal;
extern LeaseGrantRequestDefaultTypeInternal _LeaseGrantRequest_default_instance_;
class LeaseGrantResponse;
struct LeaseGrantResponseDefaultTypeInternal;
extern LeaseGrantResponseDefaultTypeInternal _LeaseGrantResponse_default_instance_;
class LeaseKeepAliveRequest;
struct LeaseKeepAliveRequestDefaultTypeInternal;
extern LeaseKeepAliveRequestDefaultTypeInternal _LeaseKeepAliveRequest_default_instance_;
class LeaseKeepAliveResponse;
struct LeaseKeepAliveResponseDefaultTypeInternal;
extern LeaseKeepAliveResponseDefaultTypeInternal _LeaseKeepAliveResponse_default_instance_;
class LeaseLeasesRequest;
struct LeaseLeasesRequestDefaultTypeInternal;
extern LeaseLeasesRequestDefaultTypeInternal _LeaseLeasesRequest_default_instance_;
class LeaseLeasesResponse;
struct LeaseLeasesResponseDefaultTypeInternal;
extern LeaseLeasesResponseDefaultTypeInternal _LeaseLeasesResponse_default_instance_;
class LeaseRevokeRequest;
struct LeaseRevokeRequestDefaultTypeInternal;
extern LeaseRevokeRequestDefaultTypeInternal _LeaseRevokeRequest_default_instance_;
class LeaseRevokeResponse;
struct LeaseRevokeResponseDefaultTypeInternal;
extern LeaseRevokeResponseDefaultTypeInternal _LeaseRevokeResponse_default_instance_;
class LeaseStatus;
struct LeaseStatusDefaultTypeInternal;
extern LeaseStatusDefaultTypeInternal _LeaseStatus_default_instance_;
class LeaseTimeToLiveRequest;
struct LeaseTimeToLiveRequestDefaultTypeInternal;
extern LeaseTimeToLiveRequestDefaultTypeInternal _LeaseTimeToLiveRequest_default_instance_;
class LeaseTimeToLiveResponse;
struct LeaseTimeToLiveResponseDefaultTypeInternal;
extern LeaseTimeToLiveResponseDefaultTypeInternal _LeaseTimeToLiveResponse_default_instance_;
class Member;
struct MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class MemberAddRequest;
struct MemberAddRequestDefaultTypeInternal;
extern MemberAddRequestDefaultTypeInternal _MemberAddRequest_default_instance_;
class MemberAddResponse;
struct MemberAddResponseDefaultTypeInternal;
extern MemberAddResponseDefaultTypeInternal _MemberAddResponse_default_instance_;
class MemberListRequest;
struct MemberListRequestDefaultTypeInternal;
extern MemberListRequestDefaultTypeInternal _MemberListRequest_default_instance_;
class MemberListResponse;
struct MemberListResponseDefaultTypeInternal;
extern MemberListResponseDefaultTypeInternal _MemberListResponse_default_instance_;
class MemberPromoteRequest;
struct MemberPromoteRequestDefaultTypeInternal;
extern MemberPromoteRequestDefaultTypeInternal _MemberPromoteRequest_default_instance_;
class MemberPromoteResponse;
struct MemberPromoteResponseDefaultTypeInternal;
extern MemberPromoteResponseDefaultTypeInternal _MemberPromoteResponse_default_instance_;
class MemberRemoveRequest;
struct MemberRemoveRequestDefaultTypeInternal;
extern MemberRemoveRequestDefaultTypeInternal _MemberRemoveRequest_default_instance_;
class MemberRemoveResponse;
struct MemberRemoveResponseDefaultTypeInternal;
extern MemberRemoveResponseDefaultTypeInternal _MemberRemoveResponse_default_instance_;
class MemberUpdateRequest;
struct MemberUpdateRequestDefaultTypeInternal;
extern MemberUpdateRequestDefaultTypeInternal _MemberUpdateRequest_default_instance_;
class MemberUpdateResponse;
struct MemberUpdateResponseDefaultTypeInternal;
extern MemberUpdateResponseDefaultTypeInternal _MemberUpdateResponse_default_instance_;
class MoveLeaderRequest;
struct MoveLeaderRequestDefaultTypeInternal;
extern MoveLeaderRequestDefaultTypeInternal _MoveLeaderRequest_default_instance_;
class MoveLeaderResponse;
struct MoveLeaderResponseDefaultTypeInternal;
extern MoveLeaderResponseDefaultTypeInternal _MoveLeaderResponse_default_instance_;
class PutRequest;
struct PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
struct PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class RangeRequest;
struct RangeRequestDefaultTypeInternal;
extern RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
class RangeResponse;
struct RangeResponseDefaultTypeInternal;
extern RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
class RequestOp;
struct RequestOpDefaultTypeInternal;
extern RequestOpDefaultTypeInternal _RequestOp_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class ResponseOp;
struct ResponseOpDefaultTypeInternal;
extern ResponseOpDefaultTypeInternal _ResponseOp_default_instance_;
class SnapshotRequest;
struct SnapshotRequestDefaultTypeInternal;
extern SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
class SnapshotResponse;
struct SnapshotResponseDefaultTypeInternal;
extern SnapshotResponseDefaultTypeInternal _SnapshotResponse_default_instance_;
class StatusRequest;
struct StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class TxnRequest;
struct TxnRequestDefaultTypeInternal;
extern TxnRequestDefaultTypeInternal _TxnRequest_default_instance_;
class TxnResponse;
struct TxnResponseDefaultTypeInternal;
extern TxnResponseDefaultTypeInternal _TxnResponse_default_instance_;
class WatchCancelRequest;
struct WatchCancelRequestDefaultTypeInternal;
extern WatchCancelRequestDefaultTypeInternal _WatchCancelRequest_default_instance_;
class WatchCreateRequest;
struct WatchCreateRequestDefaultTypeInternal;
extern WatchCreateRequestDefaultTypeInternal _WatchCreateRequest_default_instance_;
class WatchProgressRequest;
struct WatchProgressRequestDefaultTypeInternal;
extern WatchProgressRequestDefaultTypeInternal _WatchProgressRequest_default_instance_;
class WatchRequest;
struct WatchRequestDefaultTypeInternal;
extern WatchRequestDefaultTypeInternal _WatchRequest_default_instance_;
class WatchResponse;
struct WatchResponseDefaultTypeInternal;
extern WatchResponseDefaultTypeInternal _WatchResponse_default_instance_;
}  // namespace etcdserverpb
PROTOBUF_NAMESPACE_OPEN
template <>
::etcdserverpb::AlarmMember* Arena::CreateMaybeMessage<::etcdserverpb::AlarmMember>(Arena*);
template <>
::etcdserverpb::AlarmRequest* Arena::CreateMaybeMessage<::etcdserverpb::AlarmRequest>(Arena*);
template <>
::etcdserverpb::AlarmResponse* Arena::CreateMaybeMessage<::etcdserverpb::AlarmResponse>(Arena*);
template <>
::etcdserverpb::AuthDisableRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthDisableRequest>(Arena*);
template <>
::etcdserverpb::AuthDisableResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthDisableResponse>(Arena*);
template <>
::etcdserverpb::AuthEnableRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthEnableRequest>(Arena*);
template <>
::etcdserverpb::AuthEnableResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthEnableResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleAddRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleAddRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleAddResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleAddResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleDeleteRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleDeleteRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleDeleteResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleDeleteResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleGetRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleGetRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleGetResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleGetResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleGrantPermissionRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleGrantPermissionRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleGrantPermissionResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleGrantPermissionResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleListRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleListRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleListResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleListResponse>(Arena*);
template <>
::etcdserverpb::AuthRoleRevokePermissionRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleRevokePermissionRequest>(Arena*);
template <>
::etcdserverpb::AuthRoleRevokePermissionResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthRoleRevokePermissionResponse>(Arena*);
template <>
::etcdserverpb::AuthUserAddRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserAddRequest>(Arena*);
template <>
::etcdserverpb::AuthUserAddResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserAddResponse>(Arena*);
template <>
::etcdserverpb::AuthUserChangePasswordRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserChangePasswordRequest>(Arena*);
template <>
::etcdserverpb::AuthUserChangePasswordResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserChangePasswordResponse>(Arena*);
template <>
::etcdserverpb::AuthUserDeleteRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserDeleteRequest>(Arena*);
template <>
::etcdserverpb::AuthUserDeleteResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserDeleteResponse>(Arena*);
template <>
::etcdserverpb::AuthUserGetRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserGetRequest>(Arena*);
template <>
::etcdserverpb::AuthUserGetResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserGetResponse>(Arena*);
template <>
::etcdserverpb::AuthUserGrantRoleRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserGrantRoleRequest>(Arena*);
template <>
::etcdserverpb::AuthUserGrantRoleResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserGrantRoleResponse>(Arena*);
template <>
::etcdserverpb::AuthUserListRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserListRequest>(Arena*);
template <>
::etcdserverpb::AuthUserListResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserListResponse>(Arena*);
template <>
::etcdserverpb::AuthUserRevokeRoleRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserRevokeRoleRequest>(Arena*);
template <>
::etcdserverpb::AuthUserRevokeRoleResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthUserRevokeRoleResponse>(Arena*);
template <>
::etcdserverpb::AuthenticateRequest* Arena::CreateMaybeMessage<::etcdserverpb::AuthenticateRequest>(Arena*);
template <>
::etcdserverpb::AuthenticateResponse* Arena::CreateMaybeMessage<::etcdserverpb::AuthenticateResponse>(Arena*);
template <>
::etcdserverpb::CompactionRequest* Arena::CreateMaybeMessage<::etcdserverpb::CompactionRequest>(Arena*);
template <>
::etcdserverpb::CompactionResponse* Arena::CreateMaybeMessage<::etcdserverpb::CompactionResponse>(Arena*);
template <>
::etcdserverpb::Compare* Arena::CreateMaybeMessage<::etcdserverpb::Compare>(Arena*);
template <>
::etcdserverpb::DefragmentRequest* Arena::CreateMaybeMessage<::etcdserverpb::DefragmentRequest>(Arena*);
template <>
::etcdserverpb::DefragmentResponse* Arena::CreateMaybeMessage<::etcdserverpb::DefragmentResponse>(Arena*);
template <>
::etcdserverpb::DeleteRangeRequest* Arena::CreateMaybeMessage<::etcdserverpb::DeleteRangeRequest>(Arena*);
template <>
::etcdserverpb::DeleteRangeResponse* Arena::CreateMaybeMessage<::etcdserverpb::DeleteRangeResponse>(Arena*);
template <>
::etcdserverpb::HashKVRequest* Arena::CreateMaybeMessage<::etcdserverpb::HashKVRequest>(Arena*);
template <>
::etcdserverpb::HashKVResponse* Arena::CreateMaybeMessage<::etcdserverpb::HashKVResponse>(Arena*);
template <>
::etcdserverpb::HashRequest* Arena::CreateMaybeMessage<::etcdserverpb::HashRequest>(Arena*);
template <>
::etcdserverpb::HashResponse* Arena::CreateMaybeMessage<::etcdserverpb::HashResponse>(Arena*);
template <>
::etcdserverpb::LeaseCheckpoint* Arena::CreateMaybeMessage<::etcdserverpb::LeaseCheckpoint>(Arena*);
template <>
::etcdserverpb::LeaseCheckpointRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseCheckpointRequest>(Arena*);
template <>
::etcdserverpb::LeaseCheckpointResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseCheckpointResponse>(Arena*);
template <>
::etcdserverpb::LeaseGrantRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseGrantRequest>(Arena*);
template <>
::etcdserverpb::LeaseGrantResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseGrantResponse>(Arena*);
template <>
::etcdserverpb::LeaseKeepAliveRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseKeepAliveRequest>(Arena*);
template <>
::etcdserverpb::LeaseKeepAliveResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseKeepAliveResponse>(Arena*);
template <>
::etcdserverpb::LeaseLeasesRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseLeasesRequest>(Arena*);
template <>
::etcdserverpb::LeaseLeasesResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseLeasesResponse>(Arena*);
template <>
::etcdserverpb::LeaseRevokeRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseRevokeRequest>(Arena*);
template <>
::etcdserverpb::LeaseRevokeResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseRevokeResponse>(Arena*);
template <>
::etcdserverpb::LeaseStatus* Arena::CreateMaybeMessage<::etcdserverpb::LeaseStatus>(Arena*);
template <>
::etcdserverpb::LeaseTimeToLiveRequest* Arena::CreateMaybeMessage<::etcdserverpb::LeaseTimeToLiveRequest>(Arena*);
template <>
::etcdserverpb::LeaseTimeToLiveResponse* Arena::CreateMaybeMessage<::etcdserverpb::LeaseTimeToLiveResponse>(Arena*);
template <>
::etcdserverpb::Member* Arena::CreateMaybeMessage<::etcdserverpb::Member>(Arena*);
template <>
::etcdserverpb::MemberAddRequest* Arena::CreateMaybeMessage<::etcdserverpb::MemberAddRequest>(Arena*);
template <>
::etcdserverpb::MemberAddResponse* Arena::CreateMaybeMessage<::etcdserverpb::MemberAddResponse>(Arena*);
template <>
::etcdserverpb::MemberListRequest* Arena::CreateMaybeMessage<::etcdserverpb::MemberListRequest>(Arena*);
template <>
::etcdserverpb::MemberListResponse* Arena::CreateMaybeMessage<::etcdserverpb::MemberListResponse>(Arena*);
template <>
::etcdserverpb::MemberPromoteRequest* Arena::CreateMaybeMessage<::etcdserverpb::MemberPromoteRequest>(Arena*);
template <>
::etcdserverpb::MemberPromoteResponse* Arena::CreateMaybeMessage<::etcdserverpb::MemberPromoteResponse>(Arena*);
template <>
::etcdserverpb::MemberRemoveRequest* Arena::CreateMaybeMessage<::etcdserverpb::MemberRemoveRequest>(Arena*);
template <>
::etcdserverpb::MemberRemoveResponse* Arena::CreateMaybeMessage<::etcdserverpb::MemberRemoveResponse>(Arena*);
template <>
::etcdserverpb::MemberUpdateRequest* Arena::CreateMaybeMessage<::etcdserverpb::MemberUpdateRequest>(Arena*);
template <>
::etcdserverpb::MemberUpdateResponse* Arena::CreateMaybeMessage<::etcdserverpb::MemberUpdateResponse>(Arena*);
template <>
::etcdserverpb::MoveLeaderRequest* Arena::CreateMaybeMessage<::etcdserverpb::MoveLeaderRequest>(Arena*);
template <>
::etcdserverpb::MoveLeaderResponse* Arena::CreateMaybeMessage<::etcdserverpb::MoveLeaderResponse>(Arena*);
template <>
::etcdserverpb::PutRequest* Arena::CreateMaybeMessage<::etcdserverpb::PutRequest>(Arena*);
template <>
::etcdserverpb::PutResponse* Arena::CreateMaybeMessage<::etcdserverpb::PutResponse>(Arena*);
template <>
::etcdserverpb::RangeRequest* Arena::CreateMaybeMessage<::etcdserverpb::RangeRequest>(Arena*);
template <>
::etcdserverpb::RangeResponse* Arena::CreateMaybeMessage<::etcdserverpb::RangeResponse>(Arena*);
template <>
::etcdserverpb::RequestOp* Arena::CreateMaybeMessage<::etcdserverpb::RequestOp>(Arena*);
template <>
::etcdserverpb::ResponseHeader* Arena::CreateMaybeMessage<::etcdserverpb::ResponseHeader>(Arena*);
template <>
::etcdserverpb::ResponseOp* Arena::CreateMaybeMessage<::etcdserverpb::ResponseOp>(Arena*);
template <>
::etcdserverpb::SnapshotRequest* Arena::CreateMaybeMessage<::etcdserverpb::SnapshotRequest>(Arena*);
template <>
::etcdserverpb::SnapshotResponse* Arena::CreateMaybeMessage<::etcdserverpb::SnapshotResponse>(Arena*);
template <>
::etcdserverpb::StatusRequest* Arena::CreateMaybeMessage<::etcdserverpb::StatusRequest>(Arena*);
template <>
::etcdserverpb::StatusResponse* Arena::CreateMaybeMessage<::etcdserverpb::StatusResponse>(Arena*);
template <>
::etcdserverpb::TxnRequest* Arena::CreateMaybeMessage<::etcdserverpb::TxnRequest>(Arena*);
template <>
::etcdserverpb::TxnResponse* Arena::CreateMaybeMessage<::etcdserverpb::TxnResponse>(Arena*);
template <>
::etcdserverpb::WatchCancelRequest* Arena::CreateMaybeMessage<::etcdserverpb::WatchCancelRequest>(Arena*);
template <>
::etcdserverpb::WatchCreateRequest* Arena::CreateMaybeMessage<::etcdserverpb::WatchCreateRequest>(Arena*);
template <>
::etcdserverpb::WatchProgressRequest* Arena::CreateMaybeMessage<::etcdserverpb::WatchProgressRequest>(Arena*);
template <>
::etcdserverpb::WatchRequest* Arena::CreateMaybeMessage<::etcdserverpb::WatchRequest>(Arena*);
template <>
::etcdserverpb::WatchResponse* Arena::CreateMaybeMessage<::etcdserverpb::WatchResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace etcdserverpb {
enum RangeRequest_SortOrder : int {
  RangeRequest_SortOrder_NONE = 0,
  RangeRequest_SortOrder_ASCEND = 1,
  RangeRequest_SortOrder_DESCEND = 2,
  RangeRequest_SortOrder_RangeRequest_SortOrder_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RangeRequest_SortOrder_RangeRequest_SortOrder_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RangeRequest_SortOrder_IsValid(int value);
constexpr RangeRequest_SortOrder RangeRequest_SortOrder_SortOrder_MIN = static_cast<RangeRequest_SortOrder>(0);
constexpr RangeRequest_SortOrder RangeRequest_SortOrder_SortOrder_MAX = static_cast<RangeRequest_SortOrder>(2);
constexpr int RangeRequest_SortOrder_SortOrder_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RangeRequest_SortOrder_descriptor();
template <typename T>
const std::string& RangeRequest_SortOrder_Name(T value) {
  static_assert(std::is_same<T, RangeRequest_SortOrder>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortOrder_Name().");
  return RangeRequest_SortOrder_Name(static_cast<RangeRequest_SortOrder>(value));
}
template <>
inline const std::string& RangeRequest_SortOrder_Name(RangeRequest_SortOrder value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RangeRequest_SortOrder_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RangeRequest_SortOrder_Parse(absl::string_view name, RangeRequest_SortOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RangeRequest_SortOrder>(
      RangeRequest_SortOrder_descriptor(), name, value);
}
enum RangeRequest_SortTarget : int {
  RangeRequest_SortTarget_KEY = 0,
  RangeRequest_SortTarget_VERSION = 1,
  RangeRequest_SortTarget_CREATE = 2,
  RangeRequest_SortTarget_MOD = 3,
  RangeRequest_SortTarget_VALUE = 4,
  RangeRequest_SortTarget_RangeRequest_SortTarget_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RangeRequest_SortTarget_RangeRequest_SortTarget_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RangeRequest_SortTarget_IsValid(int value);
constexpr RangeRequest_SortTarget RangeRequest_SortTarget_SortTarget_MIN = static_cast<RangeRequest_SortTarget>(0);
constexpr RangeRequest_SortTarget RangeRequest_SortTarget_SortTarget_MAX = static_cast<RangeRequest_SortTarget>(4);
constexpr int RangeRequest_SortTarget_SortTarget_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RangeRequest_SortTarget_descriptor();
template <typename T>
const std::string& RangeRequest_SortTarget_Name(T value) {
  static_assert(std::is_same<T, RangeRequest_SortTarget>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortTarget_Name().");
  return RangeRequest_SortTarget_Name(static_cast<RangeRequest_SortTarget>(value));
}
template <>
inline const std::string& RangeRequest_SortTarget_Name(RangeRequest_SortTarget value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RangeRequest_SortTarget_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool RangeRequest_SortTarget_Parse(absl::string_view name, RangeRequest_SortTarget* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RangeRequest_SortTarget>(
      RangeRequest_SortTarget_descriptor(), name, value);
}
enum Compare_CompareResult : int {
  Compare_CompareResult_EQUAL = 0,
  Compare_CompareResult_GREATER = 1,
  Compare_CompareResult_LESS = 2,
  Compare_CompareResult_NOT_EQUAL = 3,
  Compare_CompareResult_Compare_CompareResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Compare_CompareResult_Compare_CompareResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Compare_CompareResult_IsValid(int value);
constexpr Compare_CompareResult Compare_CompareResult_CompareResult_MIN = static_cast<Compare_CompareResult>(0);
constexpr Compare_CompareResult Compare_CompareResult_CompareResult_MAX = static_cast<Compare_CompareResult>(3);
constexpr int Compare_CompareResult_CompareResult_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Compare_CompareResult_descriptor();
template <typename T>
const std::string& Compare_CompareResult_Name(T value) {
  static_assert(std::is_same<T, Compare_CompareResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CompareResult_Name().");
  return Compare_CompareResult_Name(static_cast<Compare_CompareResult>(value));
}
template <>
inline const std::string& Compare_CompareResult_Name(Compare_CompareResult value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Compare_CompareResult_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Compare_CompareResult_Parse(absl::string_view name, Compare_CompareResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Compare_CompareResult>(
      Compare_CompareResult_descriptor(), name, value);
}
enum Compare_CompareTarget : int {
  Compare_CompareTarget_VERSION = 0,
  Compare_CompareTarget_CREATE = 1,
  Compare_CompareTarget_MOD = 2,
  Compare_CompareTarget_VALUE = 3,
  Compare_CompareTarget_LEASE = 4,
  Compare_CompareTarget_Compare_CompareTarget_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Compare_CompareTarget_Compare_CompareTarget_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Compare_CompareTarget_IsValid(int value);
constexpr Compare_CompareTarget Compare_CompareTarget_CompareTarget_MIN = static_cast<Compare_CompareTarget>(0);
constexpr Compare_CompareTarget Compare_CompareTarget_CompareTarget_MAX = static_cast<Compare_CompareTarget>(4);
constexpr int Compare_CompareTarget_CompareTarget_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Compare_CompareTarget_descriptor();
template <typename T>
const std::string& Compare_CompareTarget_Name(T value) {
  static_assert(std::is_same<T, Compare_CompareTarget>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CompareTarget_Name().");
  return Compare_CompareTarget_Name(static_cast<Compare_CompareTarget>(value));
}
template <>
inline const std::string& Compare_CompareTarget_Name(Compare_CompareTarget value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Compare_CompareTarget_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Compare_CompareTarget_Parse(absl::string_view name, Compare_CompareTarget* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Compare_CompareTarget>(
      Compare_CompareTarget_descriptor(), name, value);
}
enum WatchCreateRequest_FilterType : int {
  WatchCreateRequest_FilterType_NOPUT = 0,
  WatchCreateRequest_FilterType_NODELETE = 1,
  WatchCreateRequest_FilterType_WatchCreateRequest_FilterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WatchCreateRequest_FilterType_WatchCreateRequest_FilterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WatchCreateRequest_FilterType_IsValid(int value);
constexpr WatchCreateRequest_FilterType WatchCreateRequest_FilterType_FilterType_MIN = static_cast<WatchCreateRequest_FilterType>(0);
constexpr WatchCreateRequest_FilterType WatchCreateRequest_FilterType_FilterType_MAX = static_cast<WatchCreateRequest_FilterType>(1);
constexpr int WatchCreateRequest_FilterType_FilterType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
WatchCreateRequest_FilterType_descriptor();
template <typename T>
const std::string& WatchCreateRequest_FilterType_Name(T value) {
  static_assert(std::is_same<T, WatchCreateRequest_FilterType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FilterType_Name().");
  return WatchCreateRequest_FilterType_Name(static_cast<WatchCreateRequest_FilterType>(value));
}
template <>
inline const std::string& WatchCreateRequest_FilterType_Name(WatchCreateRequest_FilterType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<WatchCreateRequest_FilterType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool WatchCreateRequest_FilterType_Parse(absl::string_view name, WatchCreateRequest_FilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WatchCreateRequest_FilterType>(
      WatchCreateRequest_FilterType_descriptor(), name, value);
}
enum AlarmRequest_AlarmAction : int {
  AlarmRequest_AlarmAction_GET = 0,
  AlarmRequest_AlarmAction_ACTIVATE = 1,
  AlarmRequest_AlarmAction_DEACTIVATE = 2,
  AlarmRequest_AlarmAction_AlarmRequest_AlarmAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AlarmRequest_AlarmAction_AlarmRequest_AlarmAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AlarmRequest_AlarmAction_IsValid(int value);
constexpr AlarmRequest_AlarmAction AlarmRequest_AlarmAction_AlarmAction_MIN = static_cast<AlarmRequest_AlarmAction>(0);
constexpr AlarmRequest_AlarmAction AlarmRequest_AlarmAction_AlarmAction_MAX = static_cast<AlarmRequest_AlarmAction>(2);
constexpr int AlarmRequest_AlarmAction_AlarmAction_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AlarmRequest_AlarmAction_descriptor();
template <typename T>
const std::string& AlarmRequest_AlarmAction_Name(T value) {
  static_assert(std::is_same<T, AlarmRequest_AlarmAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AlarmAction_Name().");
  return AlarmRequest_AlarmAction_Name(static_cast<AlarmRequest_AlarmAction>(value));
}
template <>
inline const std::string& AlarmRequest_AlarmAction_Name(AlarmRequest_AlarmAction value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AlarmRequest_AlarmAction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AlarmRequest_AlarmAction_Parse(absl::string_view name, AlarmRequest_AlarmAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlarmRequest_AlarmAction>(
      AlarmRequest_AlarmAction_descriptor(), name, value);
}
enum AlarmType : int {
  NONE = 0,
  NOSPACE = 1,
  CORRUPT = 2,
  AlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AlarmType_IsValid(int value);
constexpr AlarmType AlarmType_MIN = static_cast<AlarmType>(0);
constexpr AlarmType AlarmType_MAX = static_cast<AlarmType>(2);
constexpr int AlarmType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AlarmType_descriptor();
template <typename T>
const std::string& AlarmType_Name(T value) {
  static_assert(std::is_same<T, AlarmType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AlarmType_Name().");
  return AlarmType_Name(static_cast<AlarmType>(value));
}
template <>
inline const std::string& AlarmType_Name(AlarmType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AlarmType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AlarmType_Parse(absl::string_view name, AlarmType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlarmType>(
      AlarmType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseHeader& from) {
    ResponseHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterIdFieldNumber = 1,
    kMemberIdFieldNumber = 2,
    kRevisionFieldNumber = 3,
    kRaftTermFieldNumber = 4,
  };
  // uint64 cluster_id = 1;
  void clear_cluster_id() ;
  ::uint64_t cluster_id() const;
  void set_cluster_id(::uint64_t value);

  private:
  ::uint64_t _internal_cluster_id() const;
  void _internal_set_cluster_id(::uint64_t value);

  public:
  // uint64 member_id = 2;
  void clear_member_id() ;
  ::uint64_t member_id() const;
  void set_member_id(::uint64_t value);

  private:
  ::uint64_t _internal_member_id() const;
  void _internal_set_member_id(::uint64_t value);

  public:
  // int64 revision = 3;
  void clear_revision() ;
  ::int64_t revision() const;
  void set_revision(::int64_t value);

  private:
  ::int64_t _internal_revision() const;
  void _internal_set_revision(::int64_t value);

  public:
  // uint64 raft_term = 4;
  void clear_raft_term() ;
  ::uint64_t raft_term() const;
  void set_raft_term(::uint64_t value);

  private:
  ::uint64_t _internal_raft_term() const;
  void _internal_set_raft_term(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t cluster_id_;
    ::uint64_t member_id_;
    ::int64_t revision_;
    ::uint64_t raft_term_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class RangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.RangeRequest) */ {
 public:
  inline RangeRequest() : RangeRequest(nullptr) {}
  ~RangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeRequest(const RangeRequest& from);
  RangeRequest(RangeRequest&& from) noexcept
    : RangeRequest() {
    *this = ::std::move(from);
  }

  inline RangeRequest& operator=(const RangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeRequest& operator=(RangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeRequest* internal_default_instance() {
    return reinterpret_cast<const RangeRequest*>(
               &_RangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RangeRequest& a, RangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeRequest& from) {
    RangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.RangeRequest";
  }
  protected:
  explicit RangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SortOrder = RangeRequest_SortOrder;
  static constexpr SortOrder NONE = RangeRequest_SortOrder_NONE;
  static constexpr SortOrder ASCEND = RangeRequest_SortOrder_ASCEND;
  static constexpr SortOrder DESCEND = RangeRequest_SortOrder_DESCEND;
  static inline bool SortOrder_IsValid(int value) {
    return RangeRequest_SortOrder_IsValid(value);
  }
  static constexpr SortOrder SortOrder_MIN = RangeRequest_SortOrder_SortOrder_MIN;
  static constexpr SortOrder SortOrder_MAX = RangeRequest_SortOrder_SortOrder_MAX;
  static constexpr int SortOrder_ARRAYSIZE = RangeRequest_SortOrder_SortOrder_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortOrder_descriptor() {
    return RangeRequest_SortOrder_descriptor();
  }
  template <typename T>
  static inline const std::string& SortOrder_Name(T value) {
    return RangeRequest_SortOrder_Name(value);
  }
  static inline bool SortOrder_Parse(absl::string_view name, SortOrder* value) {
    return RangeRequest_SortOrder_Parse(name, value);
  }

  using SortTarget = RangeRequest_SortTarget;
  static constexpr SortTarget KEY = RangeRequest_SortTarget_KEY;
  static constexpr SortTarget VERSION = RangeRequest_SortTarget_VERSION;
  static constexpr SortTarget CREATE = RangeRequest_SortTarget_CREATE;
  static constexpr SortTarget MOD = RangeRequest_SortTarget_MOD;
  static constexpr SortTarget VALUE = RangeRequest_SortTarget_VALUE;
  static inline bool SortTarget_IsValid(int value) {
    return RangeRequest_SortTarget_IsValid(value);
  }
  static constexpr SortTarget SortTarget_MIN = RangeRequest_SortTarget_SortTarget_MIN;
  static constexpr SortTarget SortTarget_MAX = RangeRequest_SortTarget_SortTarget_MAX;
  static constexpr int SortTarget_ARRAYSIZE = RangeRequest_SortTarget_SortTarget_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortTarget_descriptor() {
    return RangeRequest_SortTarget_descriptor();
  }
  template <typename T>
  static inline const std::string& SortTarget_Name(T value) {
    return RangeRequest_SortTarget_Name(value);
  }
  static inline bool SortTarget_Parse(absl::string_view name, SortTarget* value) {
    return RangeRequest_SortTarget_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kRangeEndFieldNumber = 2,
    kLimitFieldNumber = 3,
    kRevisionFieldNumber = 4,
    kSortOrderFieldNumber = 5,
    kSortTargetFieldNumber = 6,
    kMinModRevisionFieldNumber = 10,
    kMaxModRevisionFieldNumber = 11,
    kMinCreateRevisionFieldNumber = 12,
    kMaxCreateRevisionFieldNumber = 13,
    kSerializableFieldNumber = 7,
    kKeysOnlyFieldNumber = 8,
    kCountOnlyFieldNumber = 9,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes range_end = 2;
  void clear_range_end() ;
  const std::string& range_end() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* ptr);

  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(
      const std::string& value);
  std::string* _internal_mutable_range_end();

  public:
  // int64 limit = 3;
  void clear_limit() ;
  ::int64_t limit() const;
  void set_limit(::int64_t value);

  private:
  ::int64_t _internal_limit() const;
  void _internal_set_limit(::int64_t value);

  public:
  // int64 revision = 4;
  void clear_revision() ;
  ::int64_t revision() const;
  void set_revision(::int64_t value);

  private:
  ::int64_t _internal_revision() const;
  void _internal_set_revision(::int64_t value);

  public:
  // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;
  void clear_sort_order() ;
  ::etcdserverpb::RangeRequest_SortOrder sort_order() const;
  void set_sort_order(::etcdserverpb::RangeRequest_SortOrder value);

  private:
  ::etcdserverpb::RangeRequest_SortOrder _internal_sort_order() const;
  void _internal_set_sort_order(::etcdserverpb::RangeRequest_SortOrder value);

  public:
  // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;
  void clear_sort_target() ;
  ::etcdserverpb::RangeRequest_SortTarget sort_target() const;
  void set_sort_target(::etcdserverpb::RangeRequest_SortTarget value);

  private:
  ::etcdserverpb::RangeRequest_SortTarget _internal_sort_target() const;
  void _internal_set_sort_target(::etcdserverpb::RangeRequest_SortTarget value);

  public:
  // int64 min_mod_revision = 10;
  void clear_min_mod_revision() ;
  ::int64_t min_mod_revision() const;
  void set_min_mod_revision(::int64_t value);

  private:
  ::int64_t _internal_min_mod_revision() const;
  void _internal_set_min_mod_revision(::int64_t value);

  public:
  // int64 max_mod_revision = 11;
  void clear_max_mod_revision() ;
  ::int64_t max_mod_revision() const;
  void set_max_mod_revision(::int64_t value);

  private:
  ::int64_t _internal_max_mod_revision() const;
  void _internal_set_max_mod_revision(::int64_t value);

  public:
  // int64 min_create_revision = 12;
  void clear_min_create_revision() ;
  ::int64_t min_create_revision() const;
  void set_min_create_revision(::int64_t value);

  private:
  ::int64_t _internal_min_create_revision() const;
  void _internal_set_min_create_revision(::int64_t value);

  public:
  // int64 max_create_revision = 13;
  void clear_max_create_revision() ;
  ::int64_t max_create_revision() const;
  void set_max_create_revision(::int64_t value);

  private:
  ::int64_t _internal_max_create_revision() const;
  void _internal_set_max_create_revision(::int64_t value);

  public:
  // bool serializable = 7;
  void clear_serializable() ;
  bool serializable() const;
  void set_serializable(bool value);

  private:
  bool _internal_serializable() const;
  void _internal_set_serializable(bool value);

  public:
  // bool keys_only = 8;
  void clear_keys_only() ;
  bool keys_only() const;
  void set_keys_only(bool value);

  private:
  bool _internal_keys_only() const;
  void _internal_set_keys_only(bool value);

  public:
  // bool count_only = 9;
  void clear_count_only() ;
  bool count_only() const;
  void set_count_only(bool value);

  private:
  bool _internal_count_only() const;
  void _internal_set_count_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.RangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    ::int64_t limit_;
    ::int64_t revision_;
    int sort_order_;
    int sort_target_;
    ::int64_t min_mod_revision_;
    ::int64_t max_mod_revision_;
    ::int64_t min_create_revision_;
    ::int64_t max_create_revision_;
    bool serializable_;
    bool keys_only_;
    bool count_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class RangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.RangeResponse) */ {
 public:
  inline RangeResponse() : RangeResponse(nullptr) {}
  ~RangeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeResponse(const RangeResponse& from);
  RangeResponse(RangeResponse&& from) noexcept
    : RangeResponse() {
    *this = ::std::move(from);
  }

  inline RangeResponse& operator=(const RangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeResponse& operator=(RangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeResponse* internal_default_instance() {
    return reinterpret_cast<const RangeResponse*>(
               &_RangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RangeResponse& a, RangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeResponse& from) {
    RangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.RangeResponse";
  }
  protected:
  explicit RangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kCountFieldNumber = 4,
    kMoreFieldNumber = 3,
  };
  // repeated .mvccpb.KeyValue kvs = 2;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;

  public:
  void clear_kvs() ;
  ::mvccpb::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >*
      mutable_kvs();
  private:
  const ::mvccpb::KeyValue& _internal_kvs(int index) const;
  ::mvccpb::KeyValue* _internal_add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>& _internal_kvs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>* _internal_mutable_kvs();
  public:
  const ::mvccpb::KeyValue& kvs(int index) const;
  ::mvccpb::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >&
      kvs() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 count = 4;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // bool more = 3;
  void clear_more() ;
  bool more() const;
  void set_more(bool value);

  private:
  bool _internal_more() const;
  void _internal_set_more(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.RangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue > kvs_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t count_;
    bool more_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class PutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.PutRequest) */ {
 public:
  inline PutRequest() : PutRequest(nullptr) {}
  ~PutRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutRequest(const PutRequest& from);
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutRequest& from) {
    PutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.PutRequest";
  }
  protected:
  explicit PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeaseFieldNumber = 3,
    kPrevKvFieldNumber = 4,
    kIgnoreValueFieldNumber = 5,
    kIgnoreLeaseFieldNumber = 6,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int64 lease = 3;
  void clear_lease() ;
  ::int64_t lease() const;
  void set_lease(::int64_t value);

  private:
  ::int64_t _internal_lease() const;
  void _internal_set_lease(::int64_t value);

  public:
  // bool prev_kv = 4;
  void clear_prev_kv() ;
  bool prev_kv() const;
  void set_prev_kv(bool value);

  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);

  public:
  // bool ignore_value = 5;
  void clear_ignore_value() ;
  bool ignore_value() const;
  void set_ignore_value(bool value);

  private:
  bool _internal_ignore_value() const;
  void _internal_set_ignore_value(bool value);

  public:
  // bool ignore_lease = 6;
  void clear_ignore_lease() ;
  bool ignore_lease() const;
  void set_ignore_lease(bool value);

  private:
  bool _internal_ignore_lease() const;
  void _internal_set_ignore_lease(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.PutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::int64_t lease_;
    bool prev_kv_;
    bool ignore_value_;
    bool ignore_lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class PutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.PutResponse) */ {
 public:
  inline PutResponse() : PutResponse(nullptr) {}
  ~PutResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutResponse(const PutResponse& from);
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutResponse& from) {
    PutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.PutResponse";
  }
  protected:
  explicit PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 2,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // .mvccpb.KeyValue prev_kv = 2;
  bool has_prev_kv() const;
  void clear_prev_kv() ;
  const ::mvccpb::KeyValue& prev_kv() const;
  PROTOBUF_NODISCARD ::mvccpb::KeyValue* release_prev_kv();
  ::mvccpb::KeyValue* mutable_prev_kv();
  void set_allocated_prev_kv(::mvccpb::KeyValue* prev_kv);
  private:
  const ::mvccpb::KeyValue& _internal_prev_kv() const;
  ::mvccpb::KeyValue* _internal_mutable_prev_kv();
  public:
  void unsafe_arena_set_allocated_prev_kv(
      ::mvccpb::KeyValue* prev_kv);
  ::mvccpb::KeyValue* unsafe_arena_release_prev_kv();
  // @@protoc_insertion_point(class_scope:etcdserverpb.PutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
    ::mvccpb::KeyValue* prev_kv_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class DeleteRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.DeleteRangeRequest) */ {
 public:
  inline DeleteRangeRequest() : DeleteRangeRequest(nullptr) {}
  ~DeleteRangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRangeRequest(const DeleteRangeRequest& from);
  DeleteRangeRequest(DeleteRangeRequest&& from) noexcept
    : DeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRangeRequest& operator=(DeleteRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeRequest*>(
               &_DeleteRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteRangeRequest& a, DeleteRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRangeRequest& from) {
    DeleteRangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.DeleteRangeRequest";
  }
  protected:
  explicit DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kRangeEndFieldNumber = 2,
    kPrevKvFieldNumber = 3,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes range_end = 2;
  void clear_range_end() ;
  const std::string& range_end() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* ptr);

  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(
      const std::string& value);
  std::string* _internal_mutable_range_end();

  public:
  // bool prev_kv = 3;
  void clear_prev_kv() ;
  bool prev_kv() const;
  void set_prev_kv(bool value);

  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.DeleteRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    bool prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class DeleteRangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.DeleteRangeResponse) */ {
 public:
  inline DeleteRangeResponse() : DeleteRangeResponse(nullptr) {}
  ~DeleteRangeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRangeResponse(const DeleteRangeResponse& from);
  DeleteRangeResponse(DeleteRangeResponse&& from) noexcept
    : DeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRangeResponse& operator=(DeleteRangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeResponse*>(
               &_DeleteRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteRangeResponse& a, DeleteRangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRangeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRangeResponse& from) {
    DeleteRangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.DeleteRangeResponse";
  }
  protected:
  explicit DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevKvsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kDeletedFieldNumber = 2,
  };
  // repeated .mvccpb.KeyValue prev_kvs = 3;
  int prev_kvs_size() const;
  private:
  int _internal_prev_kvs_size() const;

  public:
  void clear_prev_kvs() ;
  ::mvccpb::KeyValue* mutable_prev_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >*
      mutable_prev_kvs();
  private:
  const ::mvccpb::KeyValue& _internal_prev_kvs(int index) const;
  ::mvccpb::KeyValue* _internal_add_prev_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>& _internal_prev_kvs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>* _internal_mutable_prev_kvs();
  public:
  const ::mvccpb::KeyValue& prev_kvs(int index) const;
  ::mvccpb::KeyValue* add_prev_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >&
      prev_kvs() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 deleted = 2;
  void clear_deleted() ;
  ::int64_t deleted() const;
  void set_deleted(::int64_t value);

  private:
  ::int64_t _internal_deleted() const;
  void _internal_set_deleted(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.DeleteRangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue > prev_kvs_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t deleted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class RequestOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.RequestOp) */ {
 public:
  inline RequestOp() : RequestOp(nullptr) {}
  ~RequestOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestOp(const RequestOp& from);
  RequestOp(RequestOp&& from) noexcept
    : RequestOp() {
    *this = ::std::move(from);
  }

  inline RequestOp& operator=(const RequestOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestOp& operator=(RequestOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestOp& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kRequestRange = 1,
    kRequestPut = 2,
    kRequestDeleteRange = 3,
    kRequestTxn = 4,
    REQUEST_NOT_SET = 0,
  };

  static inline const RequestOp* internal_default_instance() {
    return reinterpret_cast<const RequestOp*>(
               &_RequestOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestOp& a, RequestOp& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestOp& from) {
    RequestOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.RequestOp";
  }
  protected:
  explicit RequestOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestRangeFieldNumber = 1,
    kRequestPutFieldNumber = 2,
    kRequestDeleteRangeFieldNumber = 3,
    kRequestTxnFieldNumber = 4,
  };
  // .etcdserverpb.RangeRequest request_range = 1;
  bool has_request_range() const;
  private:
  bool _internal_has_request_range() const;

  public:
  void clear_request_range() ;
  const ::etcdserverpb::RangeRequest& request_range() const;
  PROTOBUF_NODISCARD ::etcdserverpb::RangeRequest* release_request_range();
  ::etcdserverpb::RangeRequest* mutable_request_range();
  void set_allocated_request_range(::etcdserverpb::RangeRequest* request_range);
  private:
  const ::etcdserverpb::RangeRequest& _internal_request_range() const;
  ::etcdserverpb::RangeRequest* _internal_mutable_request_range();
  public:
  void unsafe_arena_set_allocated_request_range(
      ::etcdserverpb::RangeRequest* request_range);
  ::etcdserverpb::RangeRequest* unsafe_arena_release_request_range();
  // .etcdserverpb.PutRequest request_put = 2;
  bool has_request_put() const;
  private:
  bool _internal_has_request_put() const;

  public:
  void clear_request_put() ;
  const ::etcdserverpb::PutRequest& request_put() const;
  PROTOBUF_NODISCARD ::etcdserverpb::PutRequest* release_request_put();
  ::etcdserverpb::PutRequest* mutable_request_put();
  void set_allocated_request_put(::etcdserverpb::PutRequest* request_put);
  private:
  const ::etcdserverpb::PutRequest& _internal_request_put() const;
  ::etcdserverpb::PutRequest* _internal_mutable_request_put();
  public:
  void unsafe_arena_set_allocated_request_put(
      ::etcdserverpb::PutRequest* request_put);
  ::etcdserverpb::PutRequest* unsafe_arena_release_request_put();
  // .etcdserverpb.DeleteRangeRequest request_delete_range = 3;
  bool has_request_delete_range() const;
  private:
  bool _internal_has_request_delete_range() const;

  public:
  void clear_request_delete_range() ;
  const ::etcdserverpb::DeleteRangeRequest& request_delete_range() const;
  PROTOBUF_NODISCARD ::etcdserverpb::DeleteRangeRequest* release_request_delete_range();
  ::etcdserverpb::DeleteRangeRequest* mutable_request_delete_range();
  void set_allocated_request_delete_range(::etcdserverpb::DeleteRangeRequest* request_delete_range);
  private:
  const ::etcdserverpb::DeleteRangeRequest& _internal_request_delete_range() const;
  ::etcdserverpb::DeleteRangeRequest* _internal_mutable_request_delete_range();
  public:
  void unsafe_arena_set_allocated_request_delete_range(
      ::etcdserverpb::DeleteRangeRequest* request_delete_range);
  ::etcdserverpb::DeleteRangeRequest* unsafe_arena_release_request_delete_range();
  // .etcdserverpb.TxnRequest request_txn = 4;
  bool has_request_txn() const;
  private:
  bool _internal_has_request_txn() const;

  public:
  void clear_request_txn() ;
  const ::etcdserverpb::TxnRequest& request_txn() const;
  PROTOBUF_NODISCARD ::etcdserverpb::TxnRequest* release_request_txn();
  ::etcdserverpb::TxnRequest* mutable_request_txn();
  void set_allocated_request_txn(::etcdserverpb::TxnRequest* request_txn);
  private:
  const ::etcdserverpb::TxnRequest& _internal_request_txn() const;
  ::etcdserverpb::TxnRequest* _internal_mutable_request_txn();
  public:
  void unsafe_arena_set_allocated_request_txn(
      ::etcdserverpb::TxnRequest* request_txn);
  ::etcdserverpb::TxnRequest* unsafe_arena_release_request_txn();
  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.RequestOp)
 private:
  class _Internal;
  void set_has_request_range();
  void set_has_request_put();
  void set_has_request_delete_range();
  void set_has_request_txn();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::etcdserverpb::RangeRequest* request_range_;
      ::etcdserverpb::PutRequest* request_put_;
      ::etcdserverpb::DeleteRangeRequest* request_delete_range_;
      ::etcdserverpb::TxnRequest* request_txn_;
    } request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class ResponseOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.ResponseOp) */ {
 public:
  inline ResponseOp() : ResponseOp(nullptr) {}
  ~ResponseOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseOp(const ResponseOp& from);
  ResponseOp(ResponseOp&& from) noexcept
    : ResponseOp() {
    *this = ::std::move(from);
  }

  inline ResponseOp& operator=(const ResponseOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseOp& operator=(ResponseOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseOp& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kResponseRange = 1,
    kResponsePut = 2,
    kResponseDeleteRange = 3,
    kResponseTxn = 4,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ResponseOp* internal_default_instance() {
    return reinterpret_cast<const ResponseOp*>(
               &_ResponseOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResponseOp& a, ResponseOp& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseOp& from) {
    ResponseOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.ResponseOp";
  }
  protected:
  explicit ResponseOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseRangeFieldNumber = 1,
    kResponsePutFieldNumber = 2,
    kResponseDeleteRangeFieldNumber = 3,
    kResponseTxnFieldNumber = 4,
  };
  // .etcdserverpb.RangeResponse response_range = 1;
  bool has_response_range() const;
  private:
  bool _internal_has_response_range() const;

  public:
  void clear_response_range() ;
  const ::etcdserverpb::RangeResponse& response_range() const;
  PROTOBUF_NODISCARD ::etcdserverpb::RangeResponse* release_response_range();
  ::etcdserverpb::RangeResponse* mutable_response_range();
  void set_allocated_response_range(::etcdserverpb::RangeResponse* response_range);
  private:
  const ::etcdserverpb::RangeResponse& _internal_response_range() const;
  ::etcdserverpb::RangeResponse* _internal_mutable_response_range();
  public:
  void unsafe_arena_set_allocated_response_range(
      ::etcdserverpb::RangeResponse* response_range);
  ::etcdserverpb::RangeResponse* unsafe_arena_release_response_range();
  // .etcdserverpb.PutResponse response_put = 2;
  bool has_response_put() const;
  private:
  bool _internal_has_response_put() const;

  public:
  void clear_response_put() ;
  const ::etcdserverpb::PutResponse& response_put() const;
  PROTOBUF_NODISCARD ::etcdserverpb::PutResponse* release_response_put();
  ::etcdserverpb::PutResponse* mutable_response_put();
  void set_allocated_response_put(::etcdserverpb::PutResponse* response_put);
  private:
  const ::etcdserverpb::PutResponse& _internal_response_put() const;
  ::etcdserverpb::PutResponse* _internal_mutable_response_put();
  public:
  void unsafe_arena_set_allocated_response_put(
      ::etcdserverpb::PutResponse* response_put);
  ::etcdserverpb::PutResponse* unsafe_arena_release_response_put();
  // .etcdserverpb.DeleteRangeResponse response_delete_range = 3;
  bool has_response_delete_range() const;
  private:
  bool _internal_has_response_delete_range() const;

  public:
  void clear_response_delete_range() ;
  const ::etcdserverpb::DeleteRangeResponse& response_delete_range() const;
  PROTOBUF_NODISCARD ::etcdserverpb::DeleteRangeResponse* release_response_delete_range();
  ::etcdserverpb::DeleteRangeResponse* mutable_response_delete_range();
  void set_allocated_response_delete_range(::etcdserverpb::DeleteRangeResponse* response_delete_range);
  private:
  const ::etcdserverpb::DeleteRangeResponse& _internal_response_delete_range() const;
  ::etcdserverpb::DeleteRangeResponse* _internal_mutable_response_delete_range();
  public:
  void unsafe_arena_set_allocated_response_delete_range(
      ::etcdserverpb::DeleteRangeResponse* response_delete_range);
  ::etcdserverpb::DeleteRangeResponse* unsafe_arena_release_response_delete_range();
  // .etcdserverpb.TxnResponse response_txn = 4;
  bool has_response_txn() const;
  private:
  bool _internal_has_response_txn() const;

  public:
  void clear_response_txn() ;
  const ::etcdserverpb::TxnResponse& response_txn() const;
  PROTOBUF_NODISCARD ::etcdserverpb::TxnResponse* release_response_txn();
  ::etcdserverpb::TxnResponse* mutable_response_txn();
  void set_allocated_response_txn(::etcdserverpb::TxnResponse* response_txn);
  private:
  const ::etcdserverpb::TxnResponse& _internal_response_txn() const;
  ::etcdserverpb::TxnResponse* _internal_mutable_response_txn();
  public:
  void unsafe_arena_set_allocated_response_txn(
      ::etcdserverpb::TxnResponse* response_txn);
  ::etcdserverpb::TxnResponse* unsafe_arena_release_response_txn();
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.ResponseOp)
 private:
  class _Internal;
  void set_has_response_range();
  void set_has_response_put();
  void set_has_response_delete_range();
  void set_has_response_txn();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::etcdserverpb::RangeResponse* response_range_;
      ::etcdserverpb::PutResponse* response_put_;
      ::etcdserverpb::DeleteRangeResponse* response_delete_range_;
      ::etcdserverpb::TxnResponse* response_txn_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class Compare final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.Compare) */ {
 public:
  inline Compare() : Compare(nullptr) {}
  ~Compare() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Compare(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Compare(const Compare& from);
  Compare(Compare&& from) noexcept
    : Compare() {
    *this = ::std::move(from);
  }

  inline Compare& operator=(const Compare& from) {
    CopyFrom(from);
    return *this;
  }
  inline Compare& operator=(Compare&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Compare& default_instance() {
    return *internal_default_instance();
  }
  enum TargetUnionCase {
    kVersion = 4,
    kCreateRevision = 5,
    kModRevision = 6,
    kValue = 7,
    kLease = 8,
    TARGET_UNION_NOT_SET = 0,
  };

  static inline const Compare* internal_default_instance() {
    return reinterpret_cast<const Compare*>(
               &_Compare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Compare& a, Compare& b) {
    a.Swap(&b);
  }
  inline void Swap(Compare* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Compare* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Compare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Compare>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Compare& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Compare& from) {
    Compare::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Compare* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.Compare";
  }
  protected:
  explicit Compare(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CompareResult = Compare_CompareResult;
  static constexpr CompareResult EQUAL = Compare_CompareResult_EQUAL;
  static constexpr CompareResult GREATER = Compare_CompareResult_GREATER;
  static constexpr CompareResult LESS = Compare_CompareResult_LESS;
  static constexpr CompareResult NOT_EQUAL = Compare_CompareResult_NOT_EQUAL;
  static inline bool CompareResult_IsValid(int value) {
    return Compare_CompareResult_IsValid(value);
  }
  static constexpr CompareResult CompareResult_MIN = Compare_CompareResult_CompareResult_MIN;
  static constexpr CompareResult CompareResult_MAX = Compare_CompareResult_CompareResult_MAX;
  static constexpr int CompareResult_ARRAYSIZE = Compare_CompareResult_CompareResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareResult_descriptor() {
    return Compare_CompareResult_descriptor();
  }
  template <typename T>
  static inline const std::string& CompareResult_Name(T value) {
    return Compare_CompareResult_Name(value);
  }
  static inline bool CompareResult_Parse(absl::string_view name, CompareResult* value) {
    return Compare_CompareResult_Parse(name, value);
  }

  using CompareTarget = Compare_CompareTarget;
  static constexpr CompareTarget VERSION = Compare_CompareTarget_VERSION;
  static constexpr CompareTarget CREATE = Compare_CompareTarget_CREATE;
  static constexpr CompareTarget MOD = Compare_CompareTarget_MOD;
  static constexpr CompareTarget VALUE = Compare_CompareTarget_VALUE;
  static constexpr CompareTarget LEASE = Compare_CompareTarget_LEASE;
  static inline bool CompareTarget_IsValid(int value) {
    return Compare_CompareTarget_IsValid(value);
  }
  static constexpr CompareTarget CompareTarget_MIN = Compare_CompareTarget_CompareTarget_MIN;
  static constexpr CompareTarget CompareTarget_MAX = Compare_CompareTarget_CompareTarget_MAX;
  static constexpr int CompareTarget_ARRAYSIZE = Compare_CompareTarget_CompareTarget_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareTarget_descriptor() {
    return Compare_CompareTarget_descriptor();
  }
  template <typename T>
  static inline const std::string& CompareTarget_Name(T value) {
    return Compare_CompareTarget_Name(value);
  }
  static inline bool CompareTarget_Parse(absl::string_view name, CompareTarget* value) {
    return Compare_CompareTarget_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 3,
    kRangeEndFieldNumber = 64,
    kResultFieldNumber = 1,
    kTargetFieldNumber = 2,
    kVersionFieldNumber = 4,
    kCreateRevisionFieldNumber = 5,
    kModRevisionFieldNumber = 6,
    kValueFieldNumber = 7,
    kLeaseFieldNumber = 8,
  };
  // bytes key = 3;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes range_end = 64;
  void clear_range_end() ;
  const std::string& range_end() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* ptr);

  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(
      const std::string& value);
  std::string* _internal_mutable_range_end();

  public:
  // .etcdserverpb.Compare.CompareResult result = 1;
  void clear_result() ;
  ::etcdserverpb::Compare_CompareResult result() const;
  void set_result(::etcdserverpb::Compare_CompareResult value);

  private:
  ::etcdserverpb::Compare_CompareResult _internal_result() const;
  void _internal_set_result(::etcdserverpb::Compare_CompareResult value);

  public:
  // .etcdserverpb.Compare.CompareTarget target = 2;
  void clear_target() ;
  ::etcdserverpb::Compare_CompareTarget target() const;
  void set_target(::etcdserverpb::Compare_CompareTarget value);

  private:
  ::etcdserverpb::Compare_CompareTarget _internal_target() const;
  void _internal_set_target(::etcdserverpb::Compare_CompareTarget value);

  public:
  // int64 version = 4;
  bool has_version() const;
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // int64 create_revision = 5;
  bool has_create_revision() const;
  void clear_create_revision() ;
  ::int64_t create_revision() const;
  void set_create_revision(::int64_t value);

  private:
  ::int64_t _internal_create_revision() const;
  void _internal_set_create_revision(::int64_t value);

  public:
  // int64 mod_revision = 6;
  bool has_mod_revision() const;
  void clear_mod_revision() ;
  ::int64_t mod_revision() const;
  void set_mod_revision(::int64_t value);

  private:
  ::int64_t _internal_mod_revision() const;
  void _internal_set_mod_revision(::int64_t value);

  public:
  // bytes value = 7;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int64 lease = 8;
  bool has_lease() const;
  void clear_lease() ;
  ::int64_t lease() const;
  void set_lease(::int64_t value);

  private:
  ::int64_t _internal_lease() const;
  void _internal_set_lease(::int64_t value);

  public:
  void clear_target_union();
  TargetUnionCase target_union_case() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.Compare)
 private:
  class _Internal;
  void set_has_version();
  void set_has_create_revision();
  void set_has_mod_revision();
  void set_has_value();
  void set_has_lease();

  inline bool has_target_union() const;
  inline void clear_has_target_union();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    int result_;
    int target_;
    union TargetUnionUnion {
      constexpr TargetUnionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int64_t version_;
      ::int64_t create_revision_;
      ::int64_t mod_revision_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
      ::int64_t lease_;
    } target_union_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class TxnRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.TxnRequest) */ {
 public:
  inline TxnRequest() : TxnRequest(nullptr) {}
  ~TxnRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxnRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnRequest(const TxnRequest& from);
  TxnRequest(TxnRequest&& from) noexcept
    : TxnRequest() {
    *this = ::std::move(from);
  }

  inline TxnRequest& operator=(const TxnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnRequest& operator=(TxnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnRequest* internal_default_instance() {
    return reinterpret_cast<const TxnRequest*>(
               &_TxnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TxnRequest& a, TxnRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxnRequest& from) {
    TxnRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.TxnRequest";
  }
  protected:
  explicit TxnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompareFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kFailureFieldNumber = 3,
  };
  // repeated .etcdserverpb.Compare compare = 1;
  int compare_size() const;
  private:
  int _internal_compare_size() const;

  public:
  void clear_compare() ;
  ::etcdserverpb::Compare* mutable_compare(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Compare >*
      mutable_compare();
  private:
  const ::etcdserverpb::Compare& _internal_compare(int index) const;
  ::etcdserverpb::Compare* _internal_add_compare();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Compare>& _internal_compare() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Compare>* _internal_mutable_compare();
  public:
  const ::etcdserverpb::Compare& compare(int index) const;
  ::etcdserverpb::Compare* add_compare();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Compare >&
      compare() const;
  // repeated .etcdserverpb.RequestOp success = 2;
  int success_size() const;
  private:
  int _internal_success_size() const;

  public:
  void clear_success() ;
  ::etcdserverpb::RequestOp* mutable_success(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >*
      mutable_success();
  private:
  const ::etcdserverpb::RequestOp& _internal_success(int index) const;
  ::etcdserverpb::RequestOp* _internal_add_success();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>& _internal_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>* _internal_mutable_success();
  public:
  const ::etcdserverpb::RequestOp& success(int index) const;
  ::etcdserverpb::RequestOp* add_success();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >&
      success() const;
  // repeated .etcdserverpb.RequestOp failure = 3;
  int failure_size() const;
  private:
  int _internal_failure_size() const;

  public:
  void clear_failure() ;
  ::etcdserverpb::RequestOp* mutable_failure(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >*
      mutable_failure();
  private:
  const ::etcdserverpb::RequestOp& _internal_failure(int index) const;
  ::etcdserverpb::RequestOp* _internal_add_failure();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>& _internal_failure() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>* _internal_mutable_failure();
  public:
  const ::etcdserverpb::RequestOp& failure(int index) const;
  ::etcdserverpb::RequestOp* add_failure();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >&
      failure() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.TxnRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Compare > compare_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp > success_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp > failure_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class TxnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.TxnResponse) */ {
 public:
  inline TxnResponse() : TxnResponse(nullptr) {}
  ~TxnResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnResponse(const TxnResponse& from);
  TxnResponse(TxnResponse&& from) noexcept
    : TxnResponse() {
    *this = ::std::move(from);
  }

  inline TxnResponse& operator=(const TxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnResponse& operator=(TxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnResponse* internal_default_instance() {
    return reinterpret_cast<const TxnResponse*>(
               &_TxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TxnResponse& a, TxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxnResponse& from) {
    TxnResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.TxnResponse";
  }
  protected:
  explicit TxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kSucceededFieldNumber = 2,
  };
  // repeated .etcdserverpb.ResponseOp responses = 3;
  int responses_size() const;
  private:
  int _internal_responses_size() const;

  public:
  void clear_responses() ;
  ::etcdserverpb::ResponseOp* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::ResponseOp >*
      mutable_responses();
  private:
  const ::etcdserverpb::ResponseOp& _internal_responses(int index) const;
  ::etcdserverpb::ResponseOp* _internal_add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::ResponseOp>& _internal_responses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::ResponseOp>* _internal_mutable_responses();
  public:
  const ::etcdserverpb::ResponseOp& responses(int index) const;
  ::etcdserverpb::ResponseOp* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::ResponseOp >&
      responses() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // bool succeeded = 2;
  void clear_succeeded() ;
  bool succeeded() const;
  void set_succeeded(bool value);

  private:
  bool _internal_succeeded() const;
  void _internal_set_succeeded(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.TxnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::ResponseOp > responses_;
    ::etcdserverpb::ResponseHeader* header_;
    bool succeeded_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class CompactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.CompactionRequest) */ {
 public:
  inline CompactionRequest() : CompactionRequest(nullptr) {}
  ~CompactionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactionRequest(const CompactionRequest& from);
  CompactionRequest(CompactionRequest&& from) noexcept
    : CompactionRequest() {
    *this = ::std::move(from);
  }

  inline CompactionRequest& operator=(const CompactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionRequest& operator=(CompactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactionRequest* internal_default_instance() {
    return reinterpret_cast<const CompactionRequest*>(
               &_CompactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CompactionRequest& a, CompactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompactionRequest& from) {
    CompactionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.CompactionRequest";
  }
  protected:
  explicit CompactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 1,
    kPhysicalFieldNumber = 2,
  };
  // int64 revision = 1;
  void clear_revision() ;
  ::int64_t revision() const;
  void set_revision(::int64_t value);

  private:
  ::int64_t _internal_revision() const;
  void _internal_set_revision(::int64_t value);

  public:
  // bool physical = 2;
  void clear_physical() ;
  bool physical() const;
  void set_physical(bool value);

  private:
  bool _internal_physical() const;
  void _internal_set_physical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.CompactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t revision_;
    bool physical_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class CompactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.CompactionResponse) */ {
 public:
  inline CompactionResponse() : CompactionResponse(nullptr) {}
  ~CompactionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactionResponse(const CompactionResponse& from);
  CompactionResponse(CompactionResponse&& from) noexcept
    : CompactionResponse() {
    *this = ::std::move(from);
  }

  inline CompactionResponse& operator=(const CompactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionResponse& operator=(CompactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactionResponse* internal_default_instance() {
    return reinterpret_cast<const CompactionResponse*>(
               &_CompactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CompactionResponse& a, CompactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompactionResponse& from) {
    CompactionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.CompactionResponse";
  }
  protected:
  explicit CompactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.CompactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class HashRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.HashRequest) */ {
 public:
  inline HashRequest() : HashRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HashRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashRequest(const HashRequest& from);
  HashRequest(HashRequest&& from) noexcept
    : HashRequest() {
    *this = ::std::move(from);
  }

  inline HashRequest& operator=(const HashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashRequest& operator=(HashRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashRequest* internal_default_instance() {
    return reinterpret_cast<const HashRequest*>(
               &_HashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HashRequest& a, HashRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HashRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HashRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HashRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.HashRequest";
  }
  protected:
  explicit HashRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.HashRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class HashKVRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.HashKVRequest) */ {
 public:
  inline HashKVRequest() : HashKVRequest(nullptr) {}
  ~HashKVRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HashKVRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashKVRequest(const HashKVRequest& from);
  HashKVRequest(HashKVRequest&& from) noexcept
    : HashKVRequest() {
    *this = ::std::move(from);
  }

  inline HashKVRequest& operator=(const HashKVRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashKVRequest& operator=(HashKVRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashKVRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashKVRequest* internal_default_instance() {
    return reinterpret_cast<const HashKVRequest*>(
               &_HashKVRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HashKVRequest& a, HashKVRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HashKVRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashKVRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashKVRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashKVRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashKVRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashKVRequest& from) {
    HashKVRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashKVRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.HashKVRequest";
  }
  protected:
  explicit HashKVRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 1,
  };
  // int64 revision = 1;
  void clear_revision() ;
  ::int64_t revision() const;
  void set_revision(::int64_t value);

  private:
  ::int64_t _internal_revision() const;
  void _internal_set_revision(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.HashKVRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t revision_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class HashKVResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.HashKVResponse) */ {
 public:
  inline HashKVResponse() : HashKVResponse(nullptr) {}
  ~HashKVResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HashKVResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashKVResponse(const HashKVResponse& from);
  HashKVResponse(HashKVResponse&& from) noexcept
    : HashKVResponse() {
    *this = ::std::move(from);
  }

  inline HashKVResponse& operator=(const HashKVResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashKVResponse& operator=(HashKVResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashKVResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashKVResponse* internal_default_instance() {
    return reinterpret_cast<const HashKVResponse*>(
               &_HashKVResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HashKVResponse& a, HashKVResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HashKVResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashKVResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashKVResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashKVResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashKVResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashKVResponse& from) {
    HashKVResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashKVResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.HashKVResponse";
  }
  protected:
  explicit HashKVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCompactRevisionFieldNumber = 3,
    kHashFieldNumber = 2,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 compact_revision = 3;
  void clear_compact_revision() ;
  ::int64_t compact_revision() const;
  void set_compact_revision(::int64_t value);

  private:
  ::int64_t _internal_compact_revision() const;
  void _internal_set_compact_revision(::int64_t value);

  public:
  // uint32 hash = 2;
  void clear_hash() ;
  ::uint32_t hash() const;
  void set_hash(::uint32_t value);

  private:
  ::uint32_t _internal_hash() const;
  void _internal_set_hash(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.HashKVResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t compact_revision_;
    ::uint32_t hash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class HashResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.HashResponse) */ {
 public:
  inline HashResponse() : HashResponse(nullptr) {}
  ~HashResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HashResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashResponse(const HashResponse& from);
  HashResponse(HashResponse&& from) noexcept
    : HashResponse() {
    *this = ::std::move(from);
  }

  inline HashResponse& operator=(const HashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashResponse& operator=(HashResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashResponse* internal_default_instance() {
    return reinterpret_cast<const HashResponse*>(
               &_HashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HashResponse& a, HashResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HashResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashResponse& from) {
    HashResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.HashResponse";
  }
  protected:
  explicit HashResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // uint32 hash = 2;
  void clear_hash() ;
  ::uint32_t hash() const;
  void set_hash(::uint32_t value);

  private:
  ::uint32_t _internal_hash() const;
  void _internal_set_hash(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.HashResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
    ::uint32_t hash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class SnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.SnapshotRequest) */ {
 public:
  inline SnapshotRequest() : SnapshotRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotRequest(const SnapshotRequest& from);
  SnapshotRequest(SnapshotRequest&& from) noexcept
    : SnapshotRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotRequest& operator=(const SnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotRequest& operator=(SnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotRequest*>(
               &_SnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SnapshotRequest& a, SnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.SnapshotRequest";
  }
  protected:
  explicit SnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.SnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class SnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.SnapshotResponse) */ {
 public:
  inline SnapshotResponse() : SnapshotResponse(nullptr) {}
  ~SnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotResponse(const SnapshotResponse& from);
  SnapshotResponse(SnapshotResponse&& from) noexcept
    : SnapshotResponse() {
    *this = ::std::move(from);
  }

  inline SnapshotResponse& operator=(const SnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotResponse& operator=(SnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const SnapshotResponse*>(
               &_SnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SnapshotResponse& a, SnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotResponse& from) {
    SnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.SnapshotResponse";
  }
  protected:
  explicit SnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kRemainingBytesFieldNumber = 2,
  };
  // bytes blob = 3;
  void clear_blob() ;
  const std::string& blob() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blob(Arg_&& arg, Args_... args);
  std::string* mutable_blob();
  PROTOBUF_NODISCARD std::string* release_blob();
  void set_allocated_blob(std::string* ptr);

  private:
  const std::string& _internal_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob(
      const std::string& value);
  std::string* _internal_mutable_blob();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // uint64 remaining_bytes = 2;
  void clear_remaining_bytes() ;
  ::uint64_t remaining_bytes() const;
  void set_remaining_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_remaining_bytes() const;
  void _internal_set_remaining_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.SnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
    ::etcdserverpb::ResponseHeader* header_;
    ::uint64_t remaining_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class WatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.WatchRequest) */ {
 public:
  inline WatchRequest() : WatchRequest(nullptr) {}
  ~WatchRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchRequest(const WatchRequest& from);
  WatchRequest(WatchRequest&& from) noexcept
    : WatchRequest() {
    *this = ::std::move(from);
  }

  inline WatchRequest& operator=(const WatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchRequest& operator=(WatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestUnionCase {
    kCreateRequest = 1,
    kCancelRequest = 2,
    kProgressRequest = 3,
    REQUEST_UNION_NOT_SET = 0,
  };

  static inline const WatchRequest* internal_default_instance() {
    return reinterpret_cast<const WatchRequest*>(
               &_WatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WatchRequest& a, WatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchRequest& from) {
    WatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.WatchRequest";
  }
  protected:
  explicit WatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateRequestFieldNumber = 1,
    kCancelRequestFieldNumber = 2,
    kProgressRequestFieldNumber = 3,
  };
  // .etcdserverpb.WatchCreateRequest create_request = 1;
  bool has_create_request() const;
  private:
  bool _internal_has_create_request() const;

  public:
  void clear_create_request() ;
  const ::etcdserverpb::WatchCreateRequest& create_request() const;
  PROTOBUF_NODISCARD ::etcdserverpb::WatchCreateRequest* release_create_request();
  ::etcdserverpb::WatchCreateRequest* mutable_create_request();
  void set_allocated_create_request(::etcdserverpb::WatchCreateRequest* create_request);
  private:
  const ::etcdserverpb::WatchCreateRequest& _internal_create_request() const;
  ::etcdserverpb::WatchCreateRequest* _internal_mutable_create_request();
  public:
  void unsafe_arena_set_allocated_create_request(
      ::etcdserverpb::WatchCreateRequest* create_request);
  ::etcdserverpb::WatchCreateRequest* unsafe_arena_release_create_request();
  // .etcdserverpb.WatchCancelRequest cancel_request = 2;
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;

  public:
  void clear_cancel_request() ;
  const ::etcdserverpb::WatchCancelRequest& cancel_request() const;
  PROTOBUF_NODISCARD ::etcdserverpb::WatchCancelRequest* release_cancel_request();
  ::etcdserverpb::WatchCancelRequest* mutable_cancel_request();
  void set_allocated_cancel_request(::etcdserverpb::WatchCancelRequest* cancel_request);
  private:
  const ::etcdserverpb::WatchCancelRequest& _internal_cancel_request() const;
  ::etcdserverpb::WatchCancelRequest* _internal_mutable_cancel_request();
  public:
  void unsafe_arena_set_allocated_cancel_request(
      ::etcdserverpb::WatchCancelRequest* cancel_request);
  ::etcdserverpb::WatchCancelRequest* unsafe_arena_release_cancel_request();
  // .etcdserverpb.WatchProgressRequest progress_request = 3;
  bool has_progress_request() const;
  private:
  bool _internal_has_progress_request() const;

  public:
  void clear_progress_request() ;
  const ::etcdserverpb::WatchProgressRequest& progress_request() const;
  PROTOBUF_NODISCARD ::etcdserverpb::WatchProgressRequest* release_progress_request();
  ::etcdserverpb::WatchProgressRequest* mutable_progress_request();
  void set_allocated_progress_request(::etcdserverpb::WatchProgressRequest* progress_request);
  private:
  const ::etcdserverpb::WatchProgressRequest& _internal_progress_request() const;
  ::etcdserverpb::WatchProgressRequest* _internal_mutable_progress_request();
  public:
  void unsafe_arena_set_allocated_progress_request(
      ::etcdserverpb::WatchProgressRequest* progress_request);
  ::etcdserverpb::WatchProgressRequest* unsafe_arena_release_progress_request();
  void clear_request_union();
  RequestUnionCase request_union_case() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.WatchRequest)
 private:
  class _Internal;
  void set_has_create_request();
  void set_has_cancel_request();
  void set_has_progress_request();

  inline bool has_request_union() const;
  inline void clear_has_request_union();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestUnionUnion {
      constexpr RequestUnionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::etcdserverpb::WatchCreateRequest* create_request_;
      ::etcdserverpb::WatchCancelRequest* cancel_request_;
      ::etcdserverpb::WatchProgressRequest* progress_request_;
    } request_union_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class WatchCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.WatchCreateRequest) */ {
 public:
  inline WatchCreateRequest() : WatchCreateRequest(nullptr) {}
  ~WatchCreateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WatchCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchCreateRequest(const WatchCreateRequest& from);
  WatchCreateRequest(WatchCreateRequest&& from) noexcept
    : WatchCreateRequest() {
    *this = ::std::move(from);
  }

  inline WatchCreateRequest& operator=(const WatchCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchCreateRequest& operator=(WatchCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchCreateRequest* internal_default_instance() {
    return reinterpret_cast<const WatchCreateRequest*>(
               &_WatchCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WatchCreateRequest& a, WatchCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchCreateRequest& from) {
    WatchCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.WatchCreateRequest";
  }
  protected:
  explicit WatchCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FilterType = WatchCreateRequest_FilterType;
  static constexpr FilterType NOPUT = WatchCreateRequest_FilterType_NOPUT;
  static constexpr FilterType NODELETE = WatchCreateRequest_FilterType_NODELETE;
  static inline bool FilterType_IsValid(int value) {
    return WatchCreateRequest_FilterType_IsValid(value);
  }
  static constexpr FilterType FilterType_MIN = WatchCreateRequest_FilterType_FilterType_MIN;
  static constexpr FilterType FilterType_MAX = WatchCreateRequest_FilterType_FilterType_MAX;
  static constexpr int FilterType_ARRAYSIZE = WatchCreateRequest_FilterType_FilterType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterType_descriptor() {
    return WatchCreateRequest_FilterType_descriptor();
  }
  template <typename T>
  static inline const std::string& FilterType_Name(T value) {
    return WatchCreateRequest_FilterType_Name(value);
  }
  static inline bool FilterType_Parse(absl::string_view name, FilterType* value) {
    return WatchCreateRequest_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 5,
    kKeyFieldNumber = 1,
    kRangeEndFieldNumber = 2,
    kStartRevisionFieldNumber = 3,
    kWatchIdFieldNumber = 7,
    kProgressNotifyFieldNumber = 4,
    kPrevKvFieldNumber = 6,
    kFragmentFieldNumber = 8,
  };
  // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  public:
  ::etcdserverpb::WatchCreateRequest_FilterType filters(int index) const;
  void set_filters(int index, ::etcdserverpb::WatchCreateRequest_FilterType value);
  void add_filters(::etcdserverpb::WatchCreateRequest_FilterType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_filters();

  private:
  ::etcdserverpb::WatchCreateRequest_FilterType _internal_filters(int index) const;
  void _internal_add_filters(::etcdserverpb::WatchCreateRequest_FilterType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_filters();

  public:
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes range_end = 2;
  void clear_range_end() ;
  const std::string& range_end() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* ptr);

  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(
      const std::string& value);
  std::string* _internal_mutable_range_end();

  public:
  // int64 start_revision = 3;
  void clear_start_revision() ;
  ::int64_t start_revision() const;
  void set_start_revision(::int64_t value);

  private:
  ::int64_t _internal_start_revision() const;
  void _internal_set_start_revision(::int64_t value);

  public:
  // int64 watch_id = 7;
  void clear_watch_id() ;
  ::int64_t watch_id() const;
  void set_watch_id(::int64_t value);

  private:
  ::int64_t _internal_watch_id() const;
  void _internal_set_watch_id(::int64_t value);

  public:
  // bool progress_notify = 4;
  void clear_progress_notify() ;
  bool progress_notify() const;
  void set_progress_notify(bool value);

  private:
  bool _internal_progress_notify() const;
  void _internal_set_progress_notify(bool value);

  public:
  // bool prev_kv = 6;
  void clear_prev_kv() ;
  bool prev_kv() const;
  void set_prev_kv(bool value);

  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);

  public:
  // bool fragment = 8;
  void clear_fragment() ;
  bool fragment() const;
  void set_fragment(bool value);

  private:
  bool _internal_fragment() const;
  void _internal_set_fragment(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.WatchCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> filters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _filters_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    ::int64_t start_revision_;
    ::int64_t watch_id_;
    bool progress_notify_;
    bool prev_kv_;
    bool fragment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class WatchCancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.WatchCancelRequest) */ {
 public:
  inline WatchCancelRequest() : WatchCancelRequest(nullptr) {}
  ~WatchCancelRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WatchCancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchCancelRequest(const WatchCancelRequest& from);
  WatchCancelRequest(WatchCancelRequest&& from) noexcept
    : WatchCancelRequest() {
    *this = ::std::move(from);
  }

  inline WatchCancelRequest& operator=(const WatchCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchCancelRequest& operator=(WatchCancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchCancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchCancelRequest* internal_default_instance() {
    return reinterpret_cast<const WatchCancelRequest*>(
               &_WatchCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WatchCancelRequest& a, WatchCancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchCancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchCancelRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchCancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchCancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchCancelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchCancelRequest& from) {
    WatchCancelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchCancelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.WatchCancelRequest";
  }
  protected:
  explicit WatchCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWatchIdFieldNumber = 1,
  };
  // int64 watch_id = 1;
  void clear_watch_id() ;
  ::int64_t watch_id() const;
  void set_watch_id(::int64_t value);

  private:
  ::int64_t _internal_watch_id() const;
  void _internal_set_watch_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.WatchCancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t watch_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class WatchProgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.WatchProgressRequest) */ {
 public:
  inline WatchProgressRequest() : WatchProgressRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WatchProgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchProgressRequest(const WatchProgressRequest& from);
  WatchProgressRequest(WatchProgressRequest&& from) noexcept
    : WatchProgressRequest() {
    *this = ::std::move(from);
  }

  inline WatchProgressRequest& operator=(const WatchProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchProgressRequest& operator=(WatchProgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchProgressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchProgressRequest* internal_default_instance() {
    return reinterpret_cast<const WatchProgressRequest*>(
               &_WatchProgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WatchProgressRequest& a, WatchProgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchProgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchProgressRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchProgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchProgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WatchProgressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WatchProgressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.WatchProgressRequest";
  }
  protected:
  explicit WatchProgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.WatchProgressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class WatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.WatchResponse) */ {
 public:
  inline WatchResponse() : WatchResponse(nullptr) {}
  ~WatchResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchResponse(const WatchResponse& from);
  WatchResponse(WatchResponse&& from) noexcept
    : WatchResponse() {
    *this = ::std::move(from);
  }

  inline WatchResponse& operator=(const WatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchResponse& operator=(WatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchResponse* internal_default_instance() {
    return reinterpret_cast<const WatchResponse*>(
               &_WatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WatchResponse& a, WatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchResponse& from) {
    WatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.WatchResponse";
  }
  protected:
  explicit WatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 11,
    kCancelReasonFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kWatchIdFieldNumber = 2,
    kCompactRevisionFieldNumber = 5,
    kCreatedFieldNumber = 3,
    kCanceledFieldNumber = 4,
    kFragmentFieldNumber = 7,
  };
  // repeated .mvccpb.Event events = 11;
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::mvccpb::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::Event >*
      mutable_events();
  private:
  const ::mvccpb::Event& _internal_events(int index) const;
  ::mvccpb::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::Event>* _internal_mutable_events();
  public:
  const ::mvccpb::Event& events(int index) const;
  ::mvccpb::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::Event >&
      events() const;
  // string cancel_reason = 6;
  void clear_cancel_reason() ;
  const std::string& cancel_reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cancel_reason(Arg_&& arg, Args_... args);
  std::string* mutable_cancel_reason();
  PROTOBUF_NODISCARD std::string* release_cancel_reason();
  void set_allocated_cancel_reason(std::string* ptr);

  private:
  const std::string& _internal_cancel_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancel_reason(
      const std::string& value);
  std::string* _internal_mutable_cancel_reason();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 watch_id = 2;
  void clear_watch_id() ;
  ::int64_t watch_id() const;
  void set_watch_id(::int64_t value);

  private:
  ::int64_t _internal_watch_id() const;
  void _internal_set_watch_id(::int64_t value);

  public:
  // int64 compact_revision = 5;
  void clear_compact_revision() ;
  ::int64_t compact_revision() const;
  void set_compact_revision(::int64_t value);

  private:
  ::int64_t _internal_compact_revision() const;
  void _internal_set_compact_revision(::int64_t value);

  public:
  // bool created = 3;
  void clear_created() ;
  bool created() const;
  void set_created(bool value);

  private:
  bool _internal_created() const;
  void _internal_set_created(bool value);

  public:
  // bool canceled = 4;
  void clear_canceled() ;
  bool canceled() const;
  void set_canceled(bool value);

  private:
  bool _internal_canceled() const;
  void _internal_set_canceled(bool value);

  public:
  // bool fragment = 7;
  void clear_fragment() ;
  bool fragment() const;
  void set_fragment(bool value);

  private:
  bool _internal_fragment() const;
  void _internal_set_fragment(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.WatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cancel_reason_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t watch_id_;
    ::int64_t compact_revision_;
    bool created_;
    bool canceled_;
    bool fragment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseGrantRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseGrantRequest) */ {
 public:
  inline LeaseGrantRequest() : LeaseGrantRequest(nullptr) {}
  ~LeaseGrantRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseGrantRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseGrantRequest(const LeaseGrantRequest& from);
  LeaseGrantRequest(LeaseGrantRequest&& from) noexcept
    : LeaseGrantRequest() {
    *this = ::std::move(from);
  }

  inline LeaseGrantRequest& operator=(const LeaseGrantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseGrantRequest& operator=(LeaseGrantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseGrantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseGrantRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseGrantRequest*>(
               &_LeaseGrantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LeaseGrantRequest& a, LeaseGrantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseGrantRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseGrantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseGrantRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseGrantRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseGrantRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseGrantRequest& from) {
    LeaseGrantRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseGrantRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseGrantRequest";
  }
  protected:
  explicit LeaseGrantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTTLFieldNumber = 1,
    kIDFieldNumber = 2,
  };
  // int64 TTL = 1;
  void clear_ttl() ;
  ::int64_t ttl() const;
  void set_ttl(::int64_t value);

  private:
  ::int64_t _internal_ttl() const;
  void _internal_set_ttl(::int64_t value);

  public:
  // int64 ID = 2;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseGrantRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t ttl_;
    ::int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseGrantResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseGrantResponse) */ {
 public:
  inline LeaseGrantResponse() : LeaseGrantResponse(nullptr) {}
  ~LeaseGrantResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseGrantResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseGrantResponse(const LeaseGrantResponse& from);
  LeaseGrantResponse(LeaseGrantResponse&& from) noexcept
    : LeaseGrantResponse() {
    *this = ::std::move(from);
  }

  inline LeaseGrantResponse& operator=(const LeaseGrantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseGrantResponse& operator=(LeaseGrantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseGrantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseGrantResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseGrantResponse*>(
               &_LeaseGrantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LeaseGrantResponse& a, LeaseGrantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseGrantResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseGrantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseGrantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseGrantResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseGrantResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseGrantResponse& from) {
    LeaseGrantResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseGrantResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseGrantResponse";
  }
  protected:
  explicit LeaseGrantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kIDFieldNumber = 2,
    kTTLFieldNumber = 3,
  };
  // string error = 4;
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 ID = 2;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 TTL = 3;
  void clear_ttl() ;
  ::int64_t ttl() const;
  void set_ttl(::int64_t value);

  private:
  ::int64_t _internal_ttl() const;
  void _internal_set_ttl(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseGrantResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t id_;
    ::int64_t ttl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseRevokeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseRevokeRequest) */ {
 public:
  inline LeaseRevokeRequest() : LeaseRevokeRequest(nullptr) {}
  ~LeaseRevokeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseRevokeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseRevokeRequest(const LeaseRevokeRequest& from);
  LeaseRevokeRequest(LeaseRevokeRequest&& from) noexcept
    : LeaseRevokeRequest() {
    *this = ::std::move(from);
  }

  inline LeaseRevokeRequest& operator=(const LeaseRevokeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseRevokeRequest& operator=(LeaseRevokeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseRevokeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseRevokeRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseRevokeRequest*>(
               &_LeaseRevokeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LeaseRevokeRequest& a, LeaseRevokeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseRevokeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseRevokeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseRevokeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseRevokeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseRevokeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseRevokeRequest& from) {
    LeaseRevokeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseRevokeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseRevokeRequest";
  }
  protected:
  explicit LeaseRevokeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // int64 ID = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseRevokeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseRevokeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseRevokeResponse) */ {
 public:
  inline LeaseRevokeResponse() : LeaseRevokeResponse(nullptr) {}
  ~LeaseRevokeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseRevokeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseRevokeResponse(const LeaseRevokeResponse& from);
  LeaseRevokeResponse(LeaseRevokeResponse&& from) noexcept
    : LeaseRevokeResponse() {
    *this = ::std::move(from);
  }

  inline LeaseRevokeResponse& operator=(const LeaseRevokeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseRevokeResponse& operator=(LeaseRevokeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseRevokeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseRevokeResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseRevokeResponse*>(
               &_LeaseRevokeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LeaseRevokeResponse& a, LeaseRevokeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseRevokeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseRevokeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseRevokeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseRevokeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseRevokeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseRevokeResponse& from) {
    LeaseRevokeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseRevokeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseRevokeResponse";
  }
  protected:
  explicit LeaseRevokeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseRevokeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseCheckpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseCheckpoint) */ {
 public:
  inline LeaseCheckpoint() : LeaseCheckpoint(nullptr) {}
  ~LeaseCheckpoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseCheckpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseCheckpoint(const LeaseCheckpoint& from);
  LeaseCheckpoint(LeaseCheckpoint&& from) noexcept
    : LeaseCheckpoint() {
    *this = ::std::move(from);
  }

  inline LeaseCheckpoint& operator=(const LeaseCheckpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseCheckpoint& operator=(LeaseCheckpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseCheckpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseCheckpoint* internal_default_instance() {
    return reinterpret_cast<const LeaseCheckpoint*>(
               &_LeaseCheckpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(LeaseCheckpoint& a, LeaseCheckpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseCheckpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseCheckpoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseCheckpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseCheckpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseCheckpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseCheckpoint& from) {
    LeaseCheckpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseCheckpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseCheckpoint";
  }
  protected:
  explicit LeaseCheckpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kRemainingTTLFieldNumber = 2,
  };
  // int64 ID = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 remaining_TTL = 2;
  void clear_remaining_ttl() ;
  ::int64_t remaining_ttl() const;
  void set_remaining_ttl(::int64_t value);

  private:
  ::int64_t _internal_remaining_ttl() const;
  void _internal_set_remaining_ttl(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseCheckpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t id_;
    ::int64_t remaining_ttl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseCheckpointRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseCheckpointRequest) */ {
 public:
  inline LeaseCheckpointRequest() : LeaseCheckpointRequest(nullptr) {}
  ~LeaseCheckpointRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseCheckpointRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseCheckpointRequest(const LeaseCheckpointRequest& from);
  LeaseCheckpointRequest(LeaseCheckpointRequest&& from) noexcept
    : LeaseCheckpointRequest() {
    *this = ::std::move(from);
  }

  inline LeaseCheckpointRequest& operator=(const LeaseCheckpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseCheckpointRequest& operator=(LeaseCheckpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseCheckpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseCheckpointRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseCheckpointRequest*>(
               &_LeaseCheckpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(LeaseCheckpointRequest& a, LeaseCheckpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseCheckpointRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseCheckpointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseCheckpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseCheckpointRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseCheckpointRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseCheckpointRequest& from) {
    LeaseCheckpointRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseCheckpointRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseCheckpointRequest";
  }
  protected:
  explicit LeaseCheckpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckpointsFieldNumber = 1,
  };
  // repeated .etcdserverpb.LeaseCheckpoint checkpoints = 1;
  int checkpoints_size() const;
  private:
  int _internal_checkpoints_size() const;

  public:
  void clear_checkpoints() ;
  ::etcdserverpb::LeaseCheckpoint* mutable_checkpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseCheckpoint >*
      mutable_checkpoints();
  private:
  const ::etcdserverpb::LeaseCheckpoint& _internal_checkpoints(int index) const;
  ::etcdserverpb::LeaseCheckpoint* _internal_add_checkpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseCheckpoint>& _internal_checkpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseCheckpoint>* _internal_mutable_checkpoints();
  public:
  const ::etcdserverpb::LeaseCheckpoint& checkpoints(int index) const;
  ::etcdserverpb::LeaseCheckpoint* add_checkpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseCheckpoint >&
      checkpoints() const;
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseCheckpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseCheckpoint > checkpoints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseCheckpointResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseCheckpointResponse) */ {
 public:
  inline LeaseCheckpointResponse() : LeaseCheckpointResponse(nullptr) {}
  ~LeaseCheckpointResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseCheckpointResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseCheckpointResponse(const LeaseCheckpointResponse& from);
  LeaseCheckpointResponse(LeaseCheckpointResponse&& from) noexcept
    : LeaseCheckpointResponse() {
    *this = ::std::move(from);
  }

  inline LeaseCheckpointResponse& operator=(const LeaseCheckpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseCheckpointResponse& operator=(LeaseCheckpointResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseCheckpointResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseCheckpointResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseCheckpointResponse*>(
               &_LeaseCheckpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LeaseCheckpointResponse& a, LeaseCheckpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseCheckpointResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseCheckpointResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseCheckpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseCheckpointResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseCheckpointResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseCheckpointResponse& from) {
    LeaseCheckpointResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseCheckpointResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseCheckpointResponse";
  }
  protected:
  explicit LeaseCheckpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseCheckpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseKeepAliveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseKeepAliveRequest) */ {
 public:
  inline LeaseKeepAliveRequest() : LeaseKeepAliveRequest(nullptr) {}
  ~LeaseKeepAliveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseKeepAliveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseKeepAliveRequest(const LeaseKeepAliveRequest& from);
  LeaseKeepAliveRequest(LeaseKeepAliveRequest&& from) noexcept
    : LeaseKeepAliveRequest() {
    *this = ::std::move(from);
  }

  inline LeaseKeepAliveRequest& operator=(const LeaseKeepAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseKeepAliveRequest& operator=(LeaseKeepAliveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseKeepAliveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseKeepAliveRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseKeepAliveRequest*>(
               &_LeaseKeepAliveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LeaseKeepAliveRequest& a, LeaseKeepAliveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseKeepAliveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseKeepAliveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseKeepAliveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseKeepAliveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseKeepAliveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseKeepAliveRequest& from) {
    LeaseKeepAliveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseKeepAliveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseKeepAliveRequest";
  }
  protected:
  explicit LeaseKeepAliveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // int64 ID = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseKeepAliveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseKeepAliveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseKeepAliveResponse) */ {
 public:
  inline LeaseKeepAliveResponse() : LeaseKeepAliveResponse(nullptr) {}
  ~LeaseKeepAliveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseKeepAliveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseKeepAliveResponse(const LeaseKeepAliveResponse& from);
  LeaseKeepAliveResponse(LeaseKeepAliveResponse&& from) noexcept
    : LeaseKeepAliveResponse() {
    *this = ::std::move(from);
  }

  inline LeaseKeepAliveResponse& operator=(const LeaseKeepAliveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseKeepAliveResponse& operator=(LeaseKeepAliveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseKeepAliveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseKeepAliveResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseKeepAliveResponse*>(
               &_LeaseKeepAliveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LeaseKeepAliveResponse& a, LeaseKeepAliveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseKeepAliveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseKeepAliveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseKeepAliveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseKeepAliveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseKeepAliveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseKeepAliveResponse& from) {
    LeaseKeepAliveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseKeepAliveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseKeepAliveResponse";
  }
  protected:
  explicit LeaseKeepAliveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kIDFieldNumber = 2,
    kTTLFieldNumber = 3,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 ID = 2;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 TTL = 3;
  void clear_ttl() ;
  ::int64_t ttl() const;
  void set_ttl(::int64_t value);

  private:
  ::int64_t _internal_ttl() const;
  void _internal_set_ttl(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseKeepAliveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t id_;
    ::int64_t ttl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseTimeToLiveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseTimeToLiveRequest) */ {
 public:
  inline LeaseTimeToLiveRequest() : LeaseTimeToLiveRequest(nullptr) {}
  ~LeaseTimeToLiveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseTimeToLiveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseTimeToLiveRequest(const LeaseTimeToLiveRequest& from);
  LeaseTimeToLiveRequest(LeaseTimeToLiveRequest&& from) noexcept
    : LeaseTimeToLiveRequest() {
    *this = ::std::move(from);
  }

  inline LeaseTimeToLiveRequest& operator=(const LeaseTimeToLiveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseTimeToLiveRequest& operator=(LeaseTimeToLiveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseTimeToLiveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseTimeToLiveRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseTimeToLiveRequest*>(
               &_LeaseTimeToLiveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(LeaseTimeToLiveRequest& a, LeaseTimeToLiveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseTimeToLiveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseTimeToLiveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseTimeToLiveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseTimeToLiveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseTimeToLiveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseTimeToLiveRequest& from) {
    LeaseTimeToLiveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseTimeToLiveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseTimeToLiveRequest";
  }
  protected:
  explicit LeaseTimeToLiveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kKeysFieldNumber = 2,
  };
  // int64 ID = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // bool keys = 2;
  void clear_keys() ;
  bool keys() const;
  void set_keys(bool value);

  private:
  bool _internal_keys() const;
  void _internal_set_keys(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseTimeToLiveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t id_;
    bool keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseTimeToLiveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseTimeToLiveResponse) */ {
 public:
  inline LeaseTimeToLiveResponse() : LeaseTimeToLiveResponse(nullptr) {}
  ~LeaseTimeToLiveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseTimeToLiveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseTimeToLiveResponse(const LeaseTimeToLiveResponse& from);
  LeaseTimeToLiveResponse(LeaseTimeToLiveResponse&& from) noexcept
    : LeaseTimeToLiveResponse() {
    *this = ::std::move(from);
  }

  inline LeaseTimeToLiveResponse& operator=(const LeaseTimeToLiveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseTimeToLiveResponse& operator=(LeaseTimeToLiveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseTimeToLiveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseTimeToLiveResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseTimeToLiveResponse*>(
               &_LeaseTimeToLiveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(LeaseTimeToLiveResponse& a, LeaseTimeToLiveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseTimeToLiveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseTimeToLiveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseTimeToLiveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseTimeToLiveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseTimeToLiveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseTimeToLiveResponse& from) {
    LeaseTimeToLiveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseTimeToLiveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseTimeToLiveResponse";
  }
  protected:
  explicit LeaseTimeToLiveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kIDFieldNumber = 2,
    kTTLFieldNumber = 3,
    kGrantedTTLFieldNumber = 4,
  };
  // repeated bytes keys = 5;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, std::size_t size);
  void set_keys(int index, absl::string_view value);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, std::size_t size);
  void add_keys(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 ID = 2;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 TTL = 3;
  void clear_ttl() ;
  ::int64_t ttl() const;
  void set_ttl(::int64_t value);

  private:
  ::int64_t _internal_ttl() const;
  void _internal_set_ttl(::int64_t value);

  public:
  // int64 grantedTTL = 4;
  void clear_grantedttl() ;
  ::int64_t grantedttl() const;
  void set_grantedttl(::int64_t value);

  private:
  ::int64_t _internal_grantedttl() const;
  void _internal_set_grantedttl(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseTimeToLiveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t id_;
    ::int64_t ttl_;
    ::int64_t grantedttl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseLeasesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseLeasesRequest) */ {
 public:
  inline LeaseLeasesRequest() : LeaseLeasesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseLeasesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseLeasesRequest(const LeaseLeasesRequest& from);
  LeaseLeasesRequest(LeaseLeasesRequest&& from) noexcept
    : LeaseLeasesRequest() {
    *this = ::std::move(from);
  }

  inline LeaseLeasesRequest& operator=(const LeaseLeasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseLeasesRequest& operator=(LeaseLeasesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseLeasesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseLeasesRequest* internal_default_instance() {
    return reinterpret_cast<const LeaseLeasesRequest*>(
               &_LeaseLeasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(LeaseLeasesRequest& a, LeaseLeasesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseLeasesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseLeasesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseLeasesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseLeasesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LeaseLeasesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LeaseLeasesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseLeasesRequest";
  }
  protected:
  explicit LeaseLeasesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseLeasesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseStatus) */ {
 public:
  inline LeaseStatus() : LeaseStatus(nullptr) {}
  ~LeaseStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseStatus(const LeaseStatus& from);
  LeaseStatus(LeaseStatus&& from) noexcept
    : LeaseStatus() {
    *this = ::std::move(from);
  }

  inline LeaseStatus& operator=(const LeaseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseStatus& operator=(LeaseStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseStatus* internal_default_instance() {
    return reinterpret_cast<const LeaseStatus*>(
               &_LeaseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LeaseStatus& a, LeaseStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseStatus& from) {
    LeaseStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseStatus";
  }
  protected:
  explicit LeaseStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // int64 ID = 1;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class LeaseLeasesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.LeaseLeasesResponse) */ {
 public:
  inline LeaseLeasesResponse() : LeaseLeasesResponse(nullptr) {}
  ~LeaseLeasesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaseLeasesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseLeasesResponse(const LeaseLeasesResponse& from);
  LeaseLeasesResponse(LeaseLeasesResponse&& from) noexcept
    : LeaseLeasesResponse() {
    *this = ::std::move(from);
  }

  inline LeaseLeasesResponse& operator=(const LeaseLeasesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseLeasesResponse& operator=(LeaseLeasesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseLeasesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseLeasesResponse* internal_default_instance() {
    return reinterpret_cast<const LeaseLeasesResponse*>(
               &_LeaseLeasesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(LeaseLeasesResponse& a, LeaseLeasesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseLeasesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseLeasesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseLeasesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseLeasesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseLeasesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseLeasesResponse& from) {
    LeaseLeasesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseLeasesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.LeaseLeasesResponse";
  }
  protected:
  explicit LeaseLeasesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.LeaseStatus leases = 2;
  int leases_size() const;
  private:
  int _internal_leases_size() const;

  public:
  void clear_leases() ;
  ::etcdserverpb::LeaseStatus* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseStatus >*
      mutable_leases();
  private:
  const ::etcdserverpb::LeaseStatus& _internal_leases(int index) const;
  ::etcdserverpb::LeaseStatus* _internal_add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseStatus>& _internal_leases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseStatus>* _internal_mutable_leases();
  public:
  const ::etcdserverpb::LeaseStatus& leases(int index) const;
  ::etcdserverpb::LeaseStatus* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseStatus >&
      leases() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.LeaseLeasesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseStatus > leases_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class Member final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.Member) */ {
 public:
  inline Member() : Member(nullptr) {}
  ~Member() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Member(const Member& from);
  Member(Member&& from) noexcept
    : Member() {
    *this = ::std::move(from);
  }

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Member& operator=(Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(
               &_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Member& a, Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Member* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Member* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Member>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Member& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Member& from) {
    Member::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Member* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.Member";
  }
  protected:
  explicit Member(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerURLsFieldNumber = 3,
    kClientURLsFieldNumber = 4,
    kNameFieldNumber = 2,
    kIDFieldNumber = 1,
    kIsLearnerFieldNumber = 5,
  };
  // repeated string peerURLs = 3;
  int peerurls_size() const;
  private:
  int _internal_peerurls_size() const;

  public:
  void clear_peerurls() ;
  const std::string& peerurls(int index) const;
  std::string* mutable_peerurls(int index);
  void set_peerurls(int index, const std::string& value);
  void set_peerurls(int index, std::string&& value);
  void set_peerurls(int index, const char* value);
  void set_peerurls(int index, const char* value, std::size_t size);
  void set_peerurls(int index, absl::string_view value);
  std::string* add_peerurls();
  void add_peerurls(const std::string& value);
  void add_peerurls(std::string&& value);
  void add_peerurls(const char* value);
  void add_peerurls(const char* value, std::size_t size);
  void add_peerurls(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peerurls();

  private:
  const std::string& _internal_peerurls(int index) const;
  std::string* _internal_add_peerurls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_peerurls();

  public:
  // repeated string clientURLs = 4;
  int clienturls_size() const;
  private:
  int _internal_clienturls_size() const;

  public:
  void clear_clienturls() ;
  const std::string& clienturls(int index) const;
  std::string* mutable_clienturls(int index);
  void set_clienturls(int index, const std::string& value);
  void set_clienturls(int index, std::string&& value);
  void set_clienturls(int index, const char* value);
  void set_clienturls(int index, const char* value, std::size_t size);
  void set_clienturls(int index, absl::string_view value);
  std::string* add_clienturls();
  void add_clienturls(const std::string& value);
  void add_clienturls(std::string&& value);
  void add_clienturls(const char* value);
  void add_clienturls(const char* value, std::size_t size);
  void add_clienturls(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clienturls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clienturls();

  private:
  const std::string& _internal_clienturls(int index) const;
  std::string* _internal_add_clienturls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_clienturls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_clienturls();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint64 ID = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool isLearner = 5;
  void clear_islearner() ;
  bool islearner() const;
  void set_islearner(bool value);

  private:
  bool _internal_islearner() const;
  void _internal_set_islearner(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.Member)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peerurls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clienturls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint64_t id_;
    bool islearner_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberAddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberAddRequest) */ {
 public:
  inline MemberAddRequest() : MemberAddRequest(nullptr) {}
  ~MemberAddRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberAddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberAddRequest(const MemberAddRequest& from);
  MemberAddRequest(MemberAddRequest&& from) noexcept
    : MemberAddRequest() {
    *this = ::std::move(from);
  }

  inline MemberAddRequest& operator=(const MemberAddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberAddRequest& operator=(MemberAddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberAddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberAddRequest* internal_default_instance() {
    return reinterpret_cast<const MemberAddRequest*>(
               &_MemberAddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MemberAddRequest& a, MemberAddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberAddRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberAddRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberAddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberAddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberAddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberAddRequest& from) {
    MemberAddRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberAddRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberAddRequest";
  }
  protected:
  explicit MemberAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerURLsFieldNumber = 1,
    kIsLearnerFieldNumber = 2,
  };
  // repeated string peerURLs = 1;
  int peerurls_size() const;
  private:
  int _internal_peerurls_size() const;

  public:
  void clear_peerurls() ;
  const std::string& peerurls(int index) const;
  std::string* mutable_peerurls(int index);
  void set_peerurls(int index, const std::string& value);
  void set_peerurls(int index, std::string&& value);
  void set_peerurls(int index, const char* value);
  void set_peerurls(int index, const char* value, std::size_t size);
  void set_peerurls(int index, absl::string_view value);
  std::string* add_peerurls();
  void add_peerurls(const std::string& value);
  void add_peerurls(std::string&& value);
  void add_peerurls(const char* value);
  void add_peerurls(const char* value, std::size_t size);
  void add_peerurls(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peerurls();

  private:
  const std::string& _internal_peerurls(int index) const;
  std::string* _internal_add_peerurls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_peerurls();

  public:
  // bool isLearner = 2;
  void clear_islearner() ;
  bool islearner() const;
  void set_islearner(bool value);

  private:
  bool _internal_islearner() const;
  void _internal_set_islearner(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberAddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peerurls_;
    bool islearner_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberAddResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberAddResponse) */ {
 public:
  inline MemberAddResponse() : MemberAddResponse(nullptr) {}
  ~MemberAddResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberAddResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberAddResponse(const MemberAddResponse& from);
  MemberAddResponse(MemberAddResponse&& from) noexcept
    : MemberAddResponse() {
    *this = ::std::move(from);
  }

  inline MemberAddResponse& operator=(const MemberAddResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberAddResponse& operator=(MemberAddResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberAddResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberAddResponse* internal_default_instance() {
    return reinterpret_cast<const MemberAddResponse*>(
               &_MemberAddResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MemberAddResponse& a, MemberAddResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberAddResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberAddResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberAddResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberAddResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberAddResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberAddResponse& from) {
    MemberAddResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberAddResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberAddResponse";
  }
  protected:
  explicit MemberAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kMemberFieldNumber = 2,
  };
  // repeated .etcdserverpb.Member members = 3;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::etcdserverpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
      mutable_members();
  private:
  const ::etcdserverpb::Member& _internal_members(int index) const;
  ::etcdserverpb::Member* _internal_add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>& _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>* _internal_mutable_members();
  public:
  const ::etcdserverpb::Member& members(int index) const;
  ::etcdserverpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
      members() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // .etcdserverpb.Member member = 2;
  bool has_member() const;
  void clear_member() ;
  const ::etcdserverpb::Member& member() const;
  PROTOBUF_NODISCARD ::etcdserverpb::Member* release_member();
  ::etcdserverpb::Member* mutable_member();
  void set_allocated_member(::etcdserverpb::Member* member);
  private:
  const ::etcdserverpb::Member& _internal_member() const;
  ::etcdserverpb::Member* _internal_mutable_member();
  public:
  void unsafe_arena_set_allocated_member(
      ::etcdserverpb::Member* member);
  ::etcdserverpb::Member* unsafe_arena_release_member();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberAddResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member > members_;
    ::etcdserverpb::ResponseHeader* header_;
    ::etcdserverpb::Member* member_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberRemoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberRemoveRequest) */ {
 public:
  inline MemberRemoveRequest() : MemberRemoveRequest(nullptr) {}
  ~MemberRemoveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberRemoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberRemoveRequest(const MemberRemoveRequest& from);
  MemberRemoveRequest(MemberRemoveRequest&& from) noexcept
    : MemberRemoveRequest() {
    *this = ::std::move(from);
  }

  inline MemberRemoveRequest& operator=(const MemberRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberRemoveRequest& operator=(MemberRemoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberRemoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberRemoveRequest* internal_default_instance() {
    return reinterpret_cast<const MemberRemoveRequest*>(
               &_MemberRemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MemberRemoveRequest& a, MemberRemoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberRemoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberRemoveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberRemoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberRemoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberRemoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberRemoveRequest& from) {
    MemberRemoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberRemoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberRemoveRequest";
  }
  protected:
  explicit MemberRemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // uint64 ID = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberRemoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberRemoveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberRemoveResponse) */ {
 public:
  inline MemberRemoveResponse() : MemberRemoveResponse(nullptr) {}
  ~MemberRemoveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberRemoveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberRemoveResponse(const MemberRemoveResponse& from);
  MemberRemoveResponse(MemberRemoveResponse&& from) noexcept
    : MemberRemoveResponse() {
    *this = ::std::move(from);
  }

  inline MemberRemoveResponse& operator=(const MemberRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberRemoveResponse& operator=(MemberRemoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberRemoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberRemoveResponse* internal_default_instance() {
    return reinterpret_cast<const MemberRemoveResponse*>(
               &_MemberRemoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MemberRemoveResponse& a, MemberRemoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberRemoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberRemoveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberRemoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberRemoveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberRemoveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberRemoveResponse& from) {
    MemberRemoveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberRemoveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberRemoveResponse";
  }
  protected:
  explicit MemberRemoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.Member members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::etcdserverpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
      mutable_members();
  private:
  const ::etcdserverpb::Member& _internal_members(int index) const;
  ::etcdserverpb::Member* _internal_add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>& _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>* _internal_mutable_members();
  public:
  const ::etcdserverpb::Member& members(int index) const;
  ::etcdserverpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
      members() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberRemoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member > members_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberUpdateRequest) */ {
 public:
  inline MemberUpdateRequest() : MemberUpdateRequest(nullptr) {}
  ~MemberUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberUpdateRequest(const MemberUpdateRequest& from);
  MemberUpdateRequest(MemberUpdateRequest&& from) noexcept
    : MemberUpdateRequest() {
    *this = ::std::move(from);
  }

  inline MemberUpdateRequest& operator=(const MemberUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberUpdateRequest& operator=(MemberUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const MemberUpdateRequest*>(
               &_MemberUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(MemberUpdateRequest& a, MemberUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberUpdateRequest& from) {
    MemberUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberUpdateRequest";
  }
  protected:
  explicit MemberUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerURLsFieldNumber = 2,
    kIDFieldNumber = 1,
  };
  // repeated string peerURLs = 2;
  int peerurls_size() const;
  private:
  int _internal_peerurls_size() const;

  public:
  void clear_peerurls() ;
  const std::string& peerurls(int index) const;
  std::string* mutable_peerurls(int index);
  void set_peerurls(int index, const std::string& value);
  void set_peerurls(int index, std::string&& value);
  void set_peerurls(int index, const char* value);
  void set_peerurls(int index, const char* value, std::size_t size);
  void set_peerurls(int index, absl::string_view value);
  std::string* add_peerurls();
  void add_peerurls(const std::string& value);
  void add_peerurls(std::string&& value);
  void add_peerurls(const char* value);
  void add_peerurls(const char* value, std::size_t size);
  void add_peerurls(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peerurls();

  private:
  const std::string& _internal_peerurls(int index) const;
  std::string* _internal_add_peerurls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_peerurls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_peerurls();

  public:
  // uint64 ID = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peerurls_;
    ::uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberUpdateResponse) */ {
 public:
  inline MemberUpdateResponse() : MemberUpdateResponse(nullptr) {}
  ~MemberUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberUpdateResponse(const MemberUpdateResponse& from);
  MemberUpdateResponse(MemberUpdateResponse&& from) noexcept
    : MemberUpdateResponse() {
    *this = ::std::move(from);
  }

  inline MemberUpdateResponse& operator=(const MemberUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberUpdateResponse& operator=(MemberUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const MemberUpdateResponse*>(
               &_MemberUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MemberUpdateResponse& a, MemberUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberUpdateResponse& from) {
    MemberUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberUpdateResponse";
  }
  protected:
  explicit MemberUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.Member members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::etcdserverpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
      mutable_members();
  private:
  const ::etcdserverpb::Member& _internal_members(int index) const;
  ::etcdserverpb::Member* _internal_add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>& _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>* _internal_mutable_members();
  public:
  const ::etcdserverpb::Member& members(int index) const;
  ::etcdserverpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
      members() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member > members_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberListRequest) */ {
 public:
  inline MemberListRequest() : MemberListRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberListRequest(const MemberListRequest& from);
  MemberListRequest(MemberListRequest&& from) noexcept
    : MemberListRequest() {
    *this = ::std::move(from);
  }

  inline MemberListRequest& operator=(const MemberListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberListRequest& operator=(MemberListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberListRequest* internal_default_instance() {
    return reinterpret_cast<const MemberListRequest*>(
               &_MemberListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MemberListRequest& a, MemberListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MemberListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MemberListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberListRequest";
  }
  protected:
  explicit MemberListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberListResponse) */ {
 public:
  inline MemberListResponse() : MemberListResponse(nullptr) {}
  ~MemberListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberListResponse(const MemberListResponse& from);
  MemberListResponse(MemberListResponse&& from) noexcept
    : MemberListResponse() {
    *this = ::std::move(from);
  }

  inline MemberListResponse& operator=(const MemberListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberListResponse& operator=(MemberListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberListResponse* internal_default_instance() {
    return reinterpret_cast<const MemberListResponse*>(
               &_MemberListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(MemberListResponse& a, MemberListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberListResponse& from) {
    MemberListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberListResponse";
  }
  protected:
  explicit MemberListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.Member members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::etcdserverpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
      mutable_members();
  private:
  const ::etcdserverpb::Member& _internal_members(int index) const;
  ::etcdserverpb::Member* _internal_add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>& _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>* _internal_mutable_members();
  public:
  const ::etcdserverpb::Member& members(int index) const;
  ::etcdserverpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
      members() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member > members_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberPromoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberPromoteRequest) */ {
 public:
  inline MemberPromoteRequest() : MemberPromoteRequest(nullptr) {}
  ~MemberPromoteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberPromoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberPromoteRequest(const MemberPromoteRequest& from);
  MemberPromoteRequest(MemberPromoteRequest&& from) noexcept
    : MemberPromoteRequest() {
    *this = ::std::move(from);
  }

  inline MemberPromoteRequest& operator=(const MemberPromoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberPromoteRequest& operator=(MemberPromoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberPromoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberPromoteRequest* internal_default_instance() {
    return reinterpret_cast<const MemberPromoteRequest*>(
               &_MemberPromoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(MemberPromoteRequest& a, MemberPromoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberPromoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberPromoteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberPromoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberPromoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberPromoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberPromoteRequest& from) {
    MemberPromoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberPromoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberPromoteRequest";
  }
  protected:
  explicit MemberPromoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
  };
  // uint64 ID = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberPromoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MemberPromoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MemberPromoteResponse) */ {
 public:
  inline MemberPromoteResponse() : MemberPromoteResponse(nullptr) {}
  ~MemberPromoteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberPromoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemberPromoteResponse(const MemberPromoteResponse& from);
  MemberPromoteResponse(MemberPromoteResponse&& from) noexcept
    : MemberPromoteResponse() {
    *this = ::std::move(from);
  }

  inline MemberPromoteResponse& operator=(const MemberPromoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberPromoteResponse& operator=(MemberPromoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberPromoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberPromoteResponse* internal_default_instance() {
    return reinterpret_cast<const MemberPromoteResponse*>(
               &_MemberPromoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(MemberPromoteResponse& a, MemberPromoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberPromoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberPromoteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberPromoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberPromoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemberPromoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemberPromoteResponse& from) {
    MemberPromoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemberPromoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MemberPromoteResponse";
  }
  protected:
  explicit MemberPromoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.Member members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::etcdserverpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
      mutable_members();
  private:
  const ::etcdserverpb::Member& _internal_members(int index) const;
  ::etcdserverpb::Member* _internal_add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>& _internal_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>* _internal_mutable_members();
  public:
  const ::etcdserverpb::Member& members(int index) const;
  ::etcdserverpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
      members() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MemberPromoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member > members_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class DefragmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.DefragmentRequest) */ {
 public:
  inline DefragmentRequest() : DefragmentRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DefragmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefragmentRequest(const DefragmentRequest& from);
  DefragmentRequest(DefragmentRequest&& from) noexcept
    : DefragmentRequest() {
    *this = ::std::move(from);
  }

  inline DefragmentRequest& operator=(const DefragmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefragmentRequest& operator=(DefragmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefragmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefragmentRequest* internal_default_instance() {
    return reinterpret_cast<const DefragmentRequest*>(
               &_DefragmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(DefragmentRequest& a, DefragmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DefragmentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefragmentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefragmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefragmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DefragmentRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DefragmentRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.DefragmentRequest";
  }
  protected:
  explicit DefragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.DefragmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class DefragmentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.DefragmentResponse) */ {
 public:
  inline DefragmentResponse() : DefragmentResponse(nullptr) {}
  ~DefragmentResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DefragmentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefragmentResponse(const DefragmentResponse& from);
  DefragmentResponse(DefragmentResponse&& from) noexcept
    : DefragmentResponse() {
    *this = ::std::move(from);
  }

  inline DefragmentResponse& operator=(const DefragmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefragmentResponse& operator=(DefragmentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefragmentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefragmentResponse* internal_default_instance() {
    return reinterpret_cast<const DefragmentResponse*>(
               &_DefragmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(DefragmentResponse& a, DefragmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DefragmentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefragmentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefragmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefragmentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefragmentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefragmentResponse& from) {
    DefragmentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefragmentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.DefragmentResponse";
  }
  protected:
  explicit DefragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.DefragmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MoveLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MoveLeaderRequest) */ {
 public:
  inline MoveLeaderRequest() : MoveLeaderRequest(nullptr) {}
  ~MoveLeaderRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveLeaderRequest(const MoveLeaderRequest& from);
  MoveLeaderRequest(MoveLeaderRequest&& from) noexcept
    : MoveLeaderRequest() {
    *this = ::std::move(from);
  }

  inline MoveLeaderRequest& operator=(const MoveLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveLeaderRequest& operator=(MoveLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const MoveLeaderRequest*>(
               &_MoveLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(MoveLeaderRequest& a, MoveLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveLeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveLeaderRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveLeaderRequest& from) {
    MoveLeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveLeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MoveLeaderRequest";
  }
  protected:
  explicit MoveLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIDFieldNumber = 1,
  };
  // uint64 targetID = 1;
  void clear_targetid() ;
  ::uint64_t targetid() const;
  void set_targetid(::uint64_t value);

  private:
  ::uint64_t _internal_targetid() const;
  void _internal_set_targetid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.MoveLeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t targetid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class MoveLeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.MoveLeaderResponse) */ {
 public:
  inline MoveLeaderResponse() : MoveLeaderResponse(nullptr) {}
  ~MoveLeaderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveLeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveLeaderResponse(const MoveLeaderResponse& from);
  MoveLeaderResponse(MoveLeaderResponse&& from) noexcept
    : MoveLeaderResponse() {
    *this = ::std::move(from);
  }

  inline MoveLeaderResponse& operator=(const MoveLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveLeaderResponse& operator=(MoveLeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveLeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const MoveLeaderResponse*>(
               &_MoveLeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(MoveLeaderResponse& a, MoveLeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveLeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveLeaderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveLeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveLeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveLeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveLeaderResponse& from) {
    MoveLeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveLeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.MoveLeaderResponse";
  }
  protected:
  explicit MoveLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.MoveLeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AlarmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AlarmRequest) */ {
 public:
  inline AlarmRequest() : AlarmRequest(nullptr) {}
  ~AlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlarmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmRequest(const AlarmRequest& from);
  AlarmRequest(AlarmRequest&& from) noexcept
    : AlarmRequest() {
    *this = ::std::move(from);
  }

  inline AlarmRequest& operator=(const AlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmRequest& operator=(AlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmRequest* internal_default_instance() {
    return reinterpret_cast<const AlarmRequest*>(
               &_AlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(AlarmRequest& a, AlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmRequest& from) {
    AlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AlarmRequest";
  }
  protected:
  explicit AlarmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AlarmAction = AlarmRequest_AlarmAction;
  static constexpr AlarmAction GET = AlarmRequest_AlarmAction_GET;
  static constexpr AlarmAction ACTIVATE = AlarmRequest_AlarmAction_ACTIVATE;
  static constexpr AlarmAction DEACTIVATE = AlarmRequest_AlarmAction_DEACTIVATE;
  static inline bool AlarmAction_IsValid(int value) {
    return AlarmRequest_AlarmAction_IsValid(value);
  }
  static constexpr AlarmAction AlarmAction_MIN = AlarmRequest_AlarmAction_AlarmAction_MIN;
  static constexpr AlarmAction AlarmAction_MAX = AlarmRequest_AlarmAction_AlarmAction_MAX;
  static constexpr int AlarmAction_ARRAYSIZE = AlarmRequest_AlarmAction_AlarmAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlarmAction_descriptor() {
    return AlarmRequest_AlarmAction_descriptor();
  }
  template <typename T>
  static inline const std::string& AlarmAction_Name(T value) {
    return AlarmRequest_AlarmAction_Name(value);
  }
  static inline bool AlarmAction_Parse(absl::string_view name, AlarmAction* value) {
    return AlarmRequest_AlarmAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMemberIDFieldNumber = 2,
    kActionFieldNumber = 1,
    kAlarmFieldNumber = 3,
  };
  // uint64 memberID = 2;
  void clear_memberid() ;
  ::uint64_t memberid() const;
  void set_memberid(::uint64_t value);

  private:
  ::uint64_t _internal_memberid() const;
  void _internal_set_memberid(::uint64_t value);

  public:
  // .etcdserverpb.AlarmRequest.AlarmAction action = 1;
  void clear_action() ;
  ::etcdserverpb::AlarmRequest_AlarmAction action() const;
  void set_action(::etcdserverpb::AlarmRequest_AlarmAction value);

  private:
  ::etcdserverpb::AlarmRequest_AlarmAction _internal_action() const;
  void _internal_set_action(::etcdserverpb::AlarmRequest_AlarmAction value);

  public:
  // .etcdserverpb.AlarmType alarm = 3;
  void clear_alarm() ;
  ::etcdserverpb::AlarmType alarm() const;
  void set_alarm(::etcdserverpb::AlarmType value);

  private:
  ::etcdserverpb::AlarmType _internal_alarm() const;
  void _internal_set_alarm(::etcdserverpb::AlarmType value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AlarmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t memberid_;
    int action_;
    int alarm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AlarmMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AlarmMember) */ {
 public:
  inline AlarmMember() : AlarmMember(nullptr) {}
  ~AlarmMember() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlarmMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmMember(const AlarmMember& from);
  AlarmMember(AlarmMember&& from) noexcept
    : AlarmMember() {
    *this = ::std::move(from);
  }

  inline AlarmMember& operator=(const AlarmMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmMember& operator=(AlarmMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmMember* internal_default_instance() {
    return reinterpret_cast<const AlarmMember*>(
               &_AlarmMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(AlarmMember& a, AlarmMember& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmMember* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmMember& from) {
    AlarmMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AlarmMember";
  }
  protected:
  explicit AlarmMember(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberIDFieldNumber = 1,
    kAlarmFieldNumber = 2,
  };
  // uint64 memberID = 1;
  void clear_memberid() ;
  ::uint64_t memberid() const;
  void set_memberid(::uint64_t value);

  private:
  ::uint64_t _internal_memberid() const;
  void _internal_set_memberid(::uint64_t value);

  public:
  // .etcdserverpb.AlarmType alarm = 2;
  void clear_alarm() ;
  ::etcdserverpb::AlarmType alarm() const;
  void set_alarm(::etcdserverpb::AlarmType value);

  private:
  ::etcdserverpb::AlarmType _internal_alarm() const;
  void _internal_set_alarm(::etcdserverpb::AlarmType value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AlarmMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t memberid_;
    int alarm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AlarmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AlarmResponse) */ {
 public:
  inline AlarmResponse() : AlarmResponse(nullptr) {}
  ~AlarmResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlarmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmResponse(const AlarmResponse& from);
  AlarmResponse(AlarmResponse&& from) noexcept
    : AlarmResponse() {
    *this = ::std::move(from);
  }

  inline AlarmResponse& operator=(const AlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmResponse& operator=(AlarmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmResponse* internal_default_instance() {
    return reinterpret_cast<const AlarmResponse*>(
               &_AlarmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(AlarmResponse& a, AlarmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmResponse& from) {
    AlarmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AlarmResponse";
  }
  protected:
  explicit AlarmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlarmsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .etcdserverpb.AlarmMember alarms = 2;
  int alarms_size() const;
  private:
  int _internal_alarms_size() const;

  public:
  void clear_alarms() ;
  ::etcdserverpb::AlarmMember* mutable_alarms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::AlarmMember >*
      mutable_alarms();
  private:
  const ::etcdserverpb::AlarmMember& _internal_alarms(int index) const;
  ::etcdserverpb::AlarmMember* _internal_add_alarms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::AlarmMember>& _internal_alarms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::AlarmMember>* _internal_mutable_alarms();
  public:
  const ::etcdserverpb::AlarmMember& alarms(int index) const;
  ::etcdserverpb::AlarmMember* add_alarms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::AlarmMember >&
      alarms() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AlarmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::AlarmMember > alarms_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class StatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.StatusRequest) */ {
 public:
  inline StatusRequest() : StatusRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusRequest(const StatusRequest& from);
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.StatusRequest";
  }
  protected:
  explicit StatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.StatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 8,
    kVersionFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kDbSizeFieldNumber = 3,
    kLeaderFieldNumber = 4,
    kRaftIndexFieldNumber = 5,
    kRaftTermFieldNumber = 6,
    kRaftAppliedIndexFieldNumber = 7,
    kDbSizeInUseFieldNumber = 9,
    kIsLearnerFieldNumber = 10,
  };
  // repeated string errors = 8;
  int errors_size() const;
  private:
  int _internal_errors_size() const;

  public:
  void clear_errors() ;
  const std::string& errors(int index) const;
  std::string* mutable_errors(int index);
  void set_errors(int index, const std::string& value);
  void set_errors(int index, std::string&& value);
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, std::size_t size);
  void set_errors(int index, absl::string_view value);
  std::string* add_errors();
  void add_errors(const std::string& value);
  void add_errors(std::string&& value);
  void add_errors(const char* value);
  void add_errors(const char* value, std::size_t size);
  void add_errors(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_errors();

  private:
  const std::string& _internal_errors(int index) const;
  std::string* _internal_add_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_errors();

  public:
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // int64 dbSize = 3;
  void clear_dbsize() ;
  ::int64_t dbsize() const;
  void set_dbsize(::int64_t value);

  private:
  ::int64_t _internal_dbsize() const;
  void _internal_set_dbsize(::int64_t value);

  public:
  // uint64 leader = 4;
  void clear_leader() ;
  ::uint64_t leader() const;
  void set_leader(::uint64_t value);

  private:
  ::uint64_t _internal_leader() const;
  void _internal_set_leader(::uint64_t value);

  public:
  // uint64 raftIndex = 5;
  void clear_raftindex() ;
  ::uint64_t raftindex() const;
  void set_raftindex(::uint64_t value);

  private:
  ::uint64_t _internal_raftindex() const;
  void _internal_set_raftindex(::uint64_t value);

  public:
  // uint64 raftTerm = 6;
  void clear_raftterm() ;
  ::uint64_t raftterm() const;
  void set_raftterm(::uint64_t value);

  private:
  ::uint64_t _internal_raftterm() const;
  void _internal_set_raftterm(::uint64_t value);

  public:
  // uint64 raftAppliedIndex = 7;
  void clear_raftappliedindex() ;
  ::uint64_t raftappliedindex() const;
  void set_raftappliedindex(::uint64_t value);

  private:
  ::uint64_t _internal_raftappliedindex() const;
  void _internal_set_raftappliedindex(::uint64_t value);

  public:
  // int64 dbSizeInUse = 9;
  void clear_dbsizeinuse() ;
  ::int64_t dbsizeinuse() const;
  void set_dbsizeinuse(::int64_t value);

  private:
  ::int64_t _internal_dbsizeinuse() const;
  void _internal_set_dbsizeinuse(::int64_t value);

  public:
  // bool isLearner = 10;
  void clear_islearner() ;
  bool islearner() const;
  void set_islearner(bool value);

  private:
  bool _internal_islearner() const;
  void _internal_set_islearner(bool value);

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> errors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::etcdserverpb::ResponseHeader* header_;
    ::int64_t dbsize_;
    ::uint64_t leader_;
    ::uint64_t raftindex_;
    ::uint64_t raftterm_;
    ::uint64_t raftappliedindex_;
    ::int64_t dbsizeinuse_;
    bool islearner_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthEnableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthEnableRequest) */ {
 public:
  inline AuthEnableRequest() : AuthEnableRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthEnableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthEnableRequest(const AuthEnableRequest& from);
  AuthEnableRequest(AuthEnableRequest&& from) noexcept
    : AuthEnableRequest() {
    *this = ::std::move(from);
  }

  inline AuthEnableRequest& operator=(const AuthEnableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthEnableRequest& operator=(AuthEnableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthEnableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthEnableRequest* internal_default_instance() {
    return reinterpret_cast<const AuthEnableRequest*>(
               &_AuthEnableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AuthEnableRequest& a, AuthEnableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthEnableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthEnableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthEnableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthEnableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AuthEnableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AuthEnableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthEnableRequest";
  }
  protected:
  explicit AuthEnableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthEnableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthDisableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthDisableRequest) */ {
 public:
  inline AuthDisableRequest() : AuthDisableRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthDisableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthDisableRequest(const AuthDisableRequest& from);
  AuthDisableRequest(AuthDisableRequest&& from) noexcept
    : AuthDisableRequest() {
    *this = ::std::move(from);
  }

  inline AuthDisableRequest& operator=(const AuthDisableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthDisableRequest& operator=(AuthDisableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthDisableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthDisableRequest* internal_default_instance() {
    return reinterpret_cast<const AuthDisableRequest*>(
               &_AuthDisableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(AuthDisableRequest& a, AuthDisableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthDisableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthDisableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthDisableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthDisableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AuthDisableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AuthDisableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthDisableRequest";
  }
  protected:
  explicit AuthDisableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthDisableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthenticateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthenticateRequest) */ {
 public:
  inline AuthenticateRequest() : AuthenticateRequest(nullptr) {}
  ~AuthenticateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateRequest(const AuthenticateRequest& from);
  AuthenticateRequest(AuthenticateRequest&& from) noexcept
    : AuthenticateRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticateRequest& operator=(const AuthenticateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateRequest& operator=(AuthenticateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticateRequest*>(
               &_AuthenticateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(AuthenticateRequest& a, AuthenticateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateRequest& from) {
    AuthenticateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthenticateRequest";
  }
  protected:
  explicit AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthenticateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserAddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserAddRequest) */ {
 public:
  inline AuthUserAddRequest() : AuthUserAddRequest(nullptr) {}
  ~AuthUserAddRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserAddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserAddRequest(const AuthUserAddRequest& from);
  AuthUserAddRequest(AuthUserAddRequest&& from) noexcept
    : AuthUserAddRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserAddRequest& operator=(const AuthUserAddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserAddRequest& operator=(AuthUserAddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserAddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserAddRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserAddRequest*>(
               &_AuthUserAddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(AuthUserAddRequest& a, AuthUserAddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserAddRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserAddRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserAddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserAddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserAddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserAddRequest& from) {
    AuthUserAddRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserAddRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserAddRequest";
  }
  protected:
  explicit AuthUserAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // .authpb.UserAddOptions options = 3;
  bool has_options() const;
  void clear_options() ;
  const ::authpb::UserAddOptions& options() const;
  PROTOBUF_NODISCARD ::authpb::UserAddOptions* release_options();
  ::authpb::UserAddOptions* mutable_options();
  void set_allocated_options(::authpb::UserAddOptions* options);
  private:
  const ::authpb::UserAddOptions& _internal_options() const;
  ::authpb::UserAddOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::authpb::UserAddOptions* options);
  ::authpb::UserAddOptions* unsafe_arena_release_options();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserAddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::authpb::UserAddOptions* options_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserGetRequest) */ {
 public:
  inline AuthUserGetRequest() : AuthUserGetRequest(nullptr) {}
  ~AuthUserGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserGetRequest(const AuthUserGetRequest& from);
  AuthUserGetRequest(AuthUserGetRequest&& from) noexcept
    : AuthUserGetRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserGetRequest& operator=(const AuthUserGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserGetRequest& operator=(AuthUserGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserGetRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserGetRequest*>(
               &_AuthUserGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(AuthUserGetRequest& a, AuthUserGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserGetRequest& from) {
    AuthUserGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserGetRequest";
  }
  protected:
  explicit AuthUserGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserDeleteRequest) */ {
 public:
  inline AuthUserDeleteRequest() : AuthUserDeleteRequest(nullptr) {}
  ~AuthUserDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserDeleteRequest(const AuthUserDeleteRequest& from);
  AuthUserDeleteRequest(AuthUserDeleteRequest&& from) noexcept
    : AuthUserDeleteRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserDeleteRequest& operator=(const AuthUserDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserDeleteRequest& operator=(AuthUserDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserDeleteRequest*>(
               &_AuthUserDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(AuthUserDeleteRequest& a, AuthUserDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserDeleteRequest& from) {
    AuthUserDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserDeleteRequest";
  }
  protected:
  explicit AuthUserDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserChangePasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserChangePasswordRequest) */ {
 public:
  inline AuthUserChangePasswordRequest() : AuthUserChangePasswordRequest(nullptr) {}
  ~AuthUserChangePasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserChangePasswordRequest(const AuthUserChangePasswordRequest& from);
  AuthUserChangePasswordRequest(AuthUserChangePasswordRequest&& from) noexcept
    : AuthUserChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserChangePasswordRequest& operator=(const AuthUserChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserChangePasswordRequest& operator=(AuthUserChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserChangePasswordRequest*>(
               &_AuthUserChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(AuthUserChangePasswordRequest& a, AuthUserChangePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserChangePasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserChangePasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserChangePasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserChangePasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserChangePasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserChangePasswordRequest& from) {
    AuthUserChangePasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserChangePasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserChangePasswordRequest";
  }
  protected:
  explicit AuthUserChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserChangePasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserGrantRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserGrantRoleRequest) */ {
 public:
  inline AuthUserGrantRoleRequest() : AuthUserGrantRoleRequest(nullptr) {}
  ~AuthUserGrantRoleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserGrantRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserGrantRoleRequest(const AuthUserGrantRoleRequest& from);
  AuthUserGrantRoleRequest(AuthUserGrantRoleRequest&& from) noexcept
    : AuthUserGrantRoleRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserGrantRoleRequest& operator=(const AuthUserGrantRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserGrantRoleRequest& operator=(AuthUserGrantRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserGrantRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserGrantRoleRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserGrantRoleRequest*>(
               &_AuthUserGrantRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(AuthUserGrantRoleRequest& a, AuthUserGrantRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserGrantRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserGrantRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserGrantRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserGrantRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserGrantRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserGrantRoleRequest& from) {
    AuthUserGrantRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserGrantRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserGrantRoleRequest";
  }
  protected:
  explicit AuthUserGrantRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string user = 1;
  void clear_user() ;
  const std::string& user() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* ptr);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string role = 2;
  void clear_role() ;
  const std::string& role() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* ptr);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserGrantRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserRevokeRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserRevokeRoleRequest) */ {
 public:
  inline AuthUserRevokeRoleRequest() : AuthUserRevokeRoleRequest(nullptr) {}
  ~AuthUserRevokeRoleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserRevokeRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserRevokeRoleRequest(const AuthUserRevokeRoleRequest& from);
  AuthUserRevokeRoleRequest(AuthUserRevokeRoleRequest&& from) noexcept
    : AuthUserRevokeRoleRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserRevokeRoleRequest& operator=(const AuthUserRevokeRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserRevokeRoleRequest& operator=(AuthUserRevokeRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserRevokeRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserRevokeRoleRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserRevokeRoleRequest*>(
               &_AuthUserRevokeRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(AuthUserRevokeRoleRequest& a, AuthUserRevokeRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserRevokeRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserRevokeRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserRevokeRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserRevokeRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserRevokeRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserRevokeRoleRequest& from) {
    AuthUserRevokeRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserRevokeRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserRevokeRoleRequest";
  }
  protected:
  explicit AuthUserRevokeRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string role = 2;
  void clear_role() ;
  const std::string& role() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* ptr);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserRevokeRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleAddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleAddRequest) */ {
 public:
  inline AuthRoleAddRequest() : AuthRoleAddRequest(nullptr) {}
  ~AuthRoleAddRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleAddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleAddRequest(const AuthRoleAddRequest& from);
  AuthRoleAddRequest(AuthRoleAddRequest&& from) noexcept
    : AuthRoleAddRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleAddRequest& operator=(const AuthRoleAddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleAddRequest& operator=(AuthRoleAddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleAddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleAddRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleAddRequest*>(
               &_AuthRoleAddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AuthRoleAddRequest& a, AuthRoleAddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleAddRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleAddRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleAddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleAddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleAddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleAddRequest& from) {
    AuthRoleAddRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleAddRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleAddRequest";
  }
  protected:
  explicit AuthRoleAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleAddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleGetRequest) */ {
 public:
  inline AuthRoleGetRequest() : AuthRoleGetRequest(nullptr) {}
  ~AuthRoleGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleGetRequest(const AuthRoleGetRequest& from);
  AuthRoleGetRequest(AuthRoleGetRequest&& from) noexcept
    : AuthRoleGetRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleGetRequest& operator=(const AuthRoleGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleGetRequest& operator=(AuthRoleGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleGetRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleGetRequest*>(
               &_AuthRoleGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AuthRoleGetRequest& a, AuthRoleGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleGetRequest& from) {
    AuthRoleGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleGetRequest";
  }
  protected:
  explicit AuthRoleGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
  };
  // string role = 1;
  void clear_role() ;
  const std::string& role() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* ptr);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserListRequest) */ {
 public:
  inline AuthUserListRequest() : AuthUserListRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserListRequest(const AuthUserListRequest& from);
  AuthUserListRequest(AuthUserListRequest&& from) noexcept
    : AuthUserListRequest() {
    *this = ::std::move(from);
  }

  inline AuthUserListRequest& operator=(const AuthUserListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserListRequest& operator=(AuthUserListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserListRequest* internal_default_instance() {
    return reinterpret_cast<const AuthUserListRequest*>(
               &_AuthUserListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(AuthUserListRequest& a, AuthUserListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AuthUserListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AuthUserListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserListRequest";
  }
  protected:
  explicit AuthUserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleListRequest) */ {
 public:
  inline AuthRoleListRequest() : AuthRoleListRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleListRequest(const AuthRoleListRequest& from);
  AuthRoleListRequest(AuthRoleListRequest&& from) noexcept
    : AuthRoleListRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleListRequest& operator=(const AuthRoleListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleListRequest& operator=(AuthRoleListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleListRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleListRequest*>(
               &_AuthRoleListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(AuthRoleListRequest& a, AuthRoleListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AuthRoleListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AuthRoleListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleListRequest";
  }
  protected:
  explicit AuthRoleListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleDeleteRequest) */ {
 public:
  inline AuthRoleDeleteRequest() : AuthRoleDeleteRequest(nullptr) {}
  ~AuthRoleDeleteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleDeleteRequest(const AuthRoleDeleteRequest& from);
  AuthRoleDeleteRequest(AuthRoleDeleteRequest&& from) noexcept
    : AuthRoleDeleteRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleDeleteRequest& operator=(const AuthRoleDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleDeleteRequest& operator=(AuthRoleDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleDeleteRequest*>(
               &_AuthRoleDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(AuthRoleDeleteRequest& a, AuthRoleDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleDeleteRequest& from) {
    AuthRoleDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleDeleteRequest";
  }
  protected:
  explicit AuthRoleDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
  };
  // string role = 1;
  void clear_role() ;
  const std::string& role() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* ptr);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleGrantPermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleGrantPermissionRequest) */ {
 public:
  inline AuthRoleGrantPermissionRequest() : AuthRoleGrantPermissionRequest(nullptr) {}
  ~AuthRoleGrantPermissionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleGrantPermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleGrantPermissionRequest(const AuthRoleGrantPermissionRequest& from);
  AuthRoleGrantPermissionRequest(AuthRoleGrantPermissionRequest&& from) noexcept
    : AuthRoleGrantPermissionRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleGrantPermissionRequest& operator=(const AuthRoleGrantPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleGrantPermissionRequest& operator=(AuthRoleGrantPermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleGrantPermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleGrantPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleGrantPermissionRequest*>(
               &_AuthRoleGrantPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(AuthRoleGrantPermissionRequest& a, AuthRoleGrantPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleGrantPermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleGrantPermissionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleGrantPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleGrantPermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleGrantPermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleGrantPermissionRequest& from) {
    AuthRoleGrantPermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleGrantPermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleGrantPermissionRequest";
  }
  protected:
  explicit AuthRoleGrantPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPermFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .authpb.Permission perm = 2;
  bool has_perm() const;
  void clear_perm() ;
  const ::authpb::Permission& perm() const;
  PROTOBUF_NODISCARD ::authpb::Permission* release_perm();
  ::authpb::Permission* mutable_perm();
  void set_allocated_perm(::authpb::Permission* perm);
  private:
  const ::authpb::Permission& _internal_perm() const;
  ::authpb::Permission* _internal_mutable_perm();
  public:
  void unsafe_arena_set_allocated_perm(
      ::authpb::Permission* perm);
  ::authpb::Permission* unsafe_arena_release_perm();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleGrantPermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::authpb::Permission* perm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleRevokePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleRevokePermissionRequest) */ {
 public:
  inline AuthRoleRevokePermissionRequest() : AuthRoleRevokePermissionRequest(nullptr) {}
  ~AuthRoleRevokePermissionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleRevokePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleRevokePermissionRequest(const AuthRoleRevokePermissionRequest& from);
  AuthRoleRevokePermissionRequest(AuthRoleRevokePermissionRequest&& from) noexcept
    : AuthRoleRevokePermissionRequest() {
    *this = ::std::move(from);
  }

  inline AuthRoleRevokePermissionRequest& operator=(const AuthRoleRevokePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleRevokePermissionRequest& operator=(AuthRoleRevokePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleRevokePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleRevokePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRoleRevokePermissionRequest*>(
               &_AuthRoleRevokePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(AuthRoleRevokePermissionRequest& a, AuthRoleRevokePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleRevokePermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleRevokePermissionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleRevokePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleRevokePermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleRevokePermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleRevokePermissionRequest& from) {
    AuthRoleRevokePermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleRevokePermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleRevokePermissionRequest";
  }
  protected:
  explicit AuthRoleRevokePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kKeyFieldNumber = 2,
    kRangeEndFieldNumber = 3,
  };
  // string role = 1;
  void clear_role() ;
  const std::string& role() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* ptr);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // bytes key = 2;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes range_end = 3;
  void clear_range_end() ;
  const std::string& range_end() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* ptr);

  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(
      const std::string& value);
  std::string* _internal_mutable_range_end();

  public:
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleRevokePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthEnableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthEnableResponse) */ {
 public:
  inline AuthEnableResponse() : AuthEnableResponse(nullptr) {}
  ~AuthEnableResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthEnableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthEnableResponse(const AuthEnableResponse& from);
  AuthEnableResponse(AuthEnableResponse&& from) noexcept
    : AuthEnableResponse() {
    *this = ::std::move(from);
  }

  inline AuthEnableResponse& operator=(const AuthEnableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthEnableResponse& operator=(AuthEnableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthEnableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthEnableResponse* internal_default_instance() {
    return reinterpret_cast<const AuthEnableResponse*>(
               &_AuthEnableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(AuthEnableResponse& a, AuthEnableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthEnableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthEnableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthEnableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthEnableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthEnableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthEnableResponse& from) {
    AuthEnableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthEnableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthEnableResponse";
  }
  protected:
  explicit AuthEnableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthEnableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthDisableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthDisableResponse) */ {
 public:
  inline AuthDisableResponse() : AuthDisableResponse(nullptr) {}
  ~AuthDisableResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthDisableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthDisableResponse(const AuthDisableResponse& from);
  AuthDisableResponse(AuthDisableResponse&& from) noexcept
    : AuthDisableResponse() {
    *this = ::std::move(from);
  }

  inline AuthDisableResponse& operator=(const AuthDisableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthDisableResponse& operator=(AuthDisableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthDisableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthDisableResponse* internal_default_instance() {
    return reinterpret_cast<const AuthDisableResponse*>(
               &_AuthDisableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(AuthDisableResponse& a, AuthDisableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthDisableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthDisableResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthDisableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthDisableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthDisableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthDisableResponse& from) {
    AuthDisableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthDisableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthDisableResponse";
  }
  protected:
  explicit AuthDisableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthDisableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthenticateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthenticateResponse) */ {
 public:
  inline AuthenticateResponse() : AuthenticateResponse(nullptr) {}
  ~AuthenticateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateResponse(const AuthenticateResponse& from);
  AuthenticateResponse(AuthenticateResponse&& from) noexcept
    : AuthenticateResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateResponse& operator=(AuthenticateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateResponse*>(
               &_AuthenticateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(AuthenticateResponse& a, AuthenticateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticateResponse& from) {
    AuthenticateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthenticateResponse";
  }
  protected:
  explicit AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string token = 2;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthenticateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserAddResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserAddResponse) */ {
 public:
  inline AuthUserAddResponse() : AuthUserAddResponse(nullptr) {}
  ~AuthUserAddResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserAddResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserAddResponse(const AuthUserAddResponse& from);
  AuthUserAddResponse(AuthUserAddResponse&& from) noexcept
    : AuthUserAddResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserAddResponse& operator=(const AuthUserAddResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserAddResponse& operator=(AuthUserAddResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserAddResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserAddResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserAddResponse*>(
               &_AuthUserAddResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(AuthUserAddResponse& a, AuthUserAddResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserAddResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserAddResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserAddResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserAddResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserAddResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserAddResponse& from) {
    AuthUserAddResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserAddResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserAddResponse";
  }
  protected:
  explicit AuthUserAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserAddResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserGetResponse) */ {
 public:
  inline AuthUserGetResponse() : AuthUserGetResponse(nullptr) {}
  ~AuthUserGetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserGetResponse(const AuthUserGetResponse& from);
  AuthUserGetResponse(AuthUserGetResponse&& from) noexcept
    : AuthUserGetResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserGetResponse& operator=(const AuthUserGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserGetResponse& operator=(AuthUserGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserGetResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserGetResponse*>(
               &_AuthUserGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(AuthUserGetResponse& a, AuthUserGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserGetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserGetResponse& from) {
    AuthUserGetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserGetResponse";
  }
  protected:
  explicit AuthUserGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, std::size_t size);
  void set_roles(int index, absl::string_view value);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, std::size_t size);
  void add_roles(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();

  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_roles();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserDeleteResponse) */ {
 public:
  inline AuthUserDeleteResponse() : AuthUserDeleteResponse(nullptr) {}
  ~AuthUserDeleteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserDeleteResponse(const AuthUserDeleteResponse& from);
  AuthUserDeleteResponse(AuthUserDeleteResponse&& from) noexcept
    : AuthUserDeleteResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserDeleteResponse& operator=(const AuthUserDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserDeleteResponse& operator=(AuthUserDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserDeleteResponse*>(
               &_AuthUserDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(AuthUserDeleteResponse& a, AuthUserDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserDeleteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserDeleteResponse& from) {
    AuthUserDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserDeleteResponse";
  }
  protected:
  explicit AuthUserDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserChangePasswordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserChangePasswordResponse) */ {
 public:
  inline AuthUserChangePasswordResponse() : AuthUserChangePasswordResponse(nullptr) {}
  ~AuthUserChangePasswordResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserChangePasswordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserChangePasswordResponse(const AuthUserChangePasswordResponse& from);
  AuthUserChangePasswordResponse(AuthUserChangePasswordResponse&& from) noexcept
    : AuthUserChangePasswordResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserChangePasswordResponse& operator=(const AuthUserChangePasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserChangePasswordResponse& operator=(AuthUserChangePasswordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserChangePasswordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserChangePasswordResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserChangePasswordResponse*>(
               &_AuthUserChangePasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(AuthUserChangePasswordResponse& a, AuthUserChangePasswordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserChangePasswordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserChangePasswordResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserChangePasswordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserChangePasswordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserChangePasswordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserChangePasswordResponse& from) {
    AuthUserChangePasswordResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserChangePasswordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserChangePasswordResponse";
  }
  protected:
  explicit AuthUserChangePasswordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserChangePasswordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserGrantRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserGrantRoleResponse) */ {
 public:
  inline AuthUserGrantRoleResponse() : AuthUserGrantRoleResponse(nullptr) {}
  ~AuthUserGrantRoleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserGrantRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserGrantRoleResponse(const AuthUserGrantRoleResponse& from);
  AuthUserGrantRoleResponse(AuthUserGrantRoleResponse&& from) noexcept
    : AuthUserGrantRoleResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserGrantRoleResponse& operator=(const AuthUserGrantRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserGrantRoleResponse& operator=(AuthUserGrantRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserGrantRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserGrantRoleResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserGrantRoleResponse*>(
               &_AuthUserGrantRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(AuthUserGrantRoleResponse& a, AuthUserGrantRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserGrantRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserGrantRoleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserGrantRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserGrantRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserGrantRoleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserGrantRoleResponse& from) {
    AuthUserGrantRoleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserGrantRoleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserGrantRoleResponse";
  }
  protected:
  explicit AuthUserGrantRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserGrantRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserRevokeRoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserRevokeRoleResponse) */ {
 public:
  inline AuthUserRevokeRoleResponse() : AuthUserRevokeRoleResponse(nullptr) {}
  ~AuthUserRevokeRoleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserRevokeRoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserRevokeRoleResponse(const AuthUserRevokeRoleResponse& from);
  AuthUserRevokeRoleResponse(AuthUserRevokeRoleResponse&& from) noexcept
    : AuthUserRevokeRoleResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserRevokeRoleResponse& operator=(const AuthUserRevokeRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserRevokeRoleResponse& operator=(AuthUserRevokeRoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserRevokeRoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserRevokeRoleResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserRevokeRoleResponse*>(
               &_AuthUserRevokeRoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(AuthUserRevokeRoleResponse& a, AuthUserRevokeRoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserRevokeRoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserRevokeRoleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserRevokeRoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserRevokeRoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserRevokeRoleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserRevokeRoleResponse& from) {
    AuthUserRevokeRoleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserRevokeRoleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserRevokeRoleResponse";
  }
  protected:
  explicit AuthUserRevokeRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserRevokeRoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleAddResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleAddResponse) */ {
 public:
  inline AuthRoleAddResponse() : AuthRoleAddResponse(nullptr) {}
  ~AuthRoleAddResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleAddResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleAddResponse(const AuthRoleAddResponse& from);
  AuthRoleAddResponse(AuthRoleAddResponse&& from) noexcept
    : AuthRoleAddResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleAddResponse& operator=(const AuthRoleAddResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleAddResponse& operator=(AuthRoleAddResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleAddResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleAddResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleAddResponse*>(
               &_AuthRoleAddResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(AuthRoleAddResponse& a, AuthRoleAddResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleAddResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleAddResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleAddResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleAddResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleAddResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleAddResponse& from) {
    AuthRoleAddResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleAddResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleAddResponse";
  }
  protected:
  explicit AuthRoleAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleAddResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleGetResponse) */ {
 public:
  inline AuthRoleGetResponse() : AuthRoleGetResponse(nullptr) {}
  ~AuthRoleGetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleGetResponse(const AuthRoleGetResponse& from);
  AuthRoleGetResponse(AuthRoleGetResponse&& from) noexcept
    : AuthRoleGetResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleGetResponse& operator=(const AuthRoleGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleGetResponse& operator=(AuthRoleGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleGetResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleGetResponse*>(
               &_AuthRoleGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(AuthRoleGetResponse& a, AuthRoleGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleGetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleGetResponse& from) {
    AuthRoleGetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleGetResponse";
  }
  protected:
  explicit AuthRoleGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .authpb.Permission perm = 2;
  int perm_size() const;
  private:
  int _internal_perm_size() const;

  public:
  void clear_perm() ;
  ::authpb::Permission* mutable_perm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authpb::Permission >*
      mutable_perm();
  private:
  const ::authpb::Permission& _internal_perm(int index) const;
  ::authpb::Permission* _internal_add_perm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::authpb::Permission>& _internal_perm() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::authpb::Permission>* _internal_mutable_perm();
  public:
  const ::authpb::Permission& perm(int index) const;
  ::authpb::Permission* add_perm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authpb::Permission >&
      perm() const;
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authpb::Permission > perm_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleListResponse) */ {
 public:
  inline AuthRoleListResponse() : AuthRoleListResponse(nullptr) {}
  ~AuthRoleListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleListResponse(const AuthRoleListResponse& from);
  AuthRoleListResponse(AuthRoleListResponse&& from) noexcept
    : AuthRoleListResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleListResponse& operator=(const AuthRoleListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleListResponse& operator=(AuthRoleListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleListResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleListResponse*>(
               &_AuthRoleListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(AuthRoleListResponse& a, AuthRoleListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleListResponse& from) {
    AuthRoleListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleListResponse";
  }
  protected:
  explicit AuthRoleListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, std::size_t size);
  void set_roles(int index, absl::string_view value);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, std::size_t size);
  void add_roles(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();

  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_roles();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthUserListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthUserListResponse) */ {
 public:
  inline AuthUserListResponse() : AuthUserListResponse(nullptr) {}
  ~AuthUserListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthUserListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthUserListResponse(const AuthUserListResponse& from);
  AuthUserListResponse(AuthUserListResponse&& from) noexcept
    : AuthUserListResponse() {
    *this = ::std::move(from);
  }

  inline AuthUserListResponse& operator=(const AuthUserListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthUserListResponse& operator=(AuthUserListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthUserListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthUserListResponse* internal_default_instance() {
    return reinterpret_cast<const AuthUserListResponse*>(
               &_AuthUserListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(AuthUserListResponse& a, AuthUserListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthUserListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthUserListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthUserListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthUserListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthUserListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthUserListResponse& from) {
    AuthUserListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthUserListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthUserListResponse";
  }
  protected:
  explicit AuthUserListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string users = 2;
  int users_size() const;
  private:
  int _internal_users_size() const;

  public:
  void clear_users() ;
  const std::string& users(int index) const;
  std::string* mutable_users(int index);
  void set_users(int index, const std::string& value);
  void set_users(int index, std::string&& value);
  void set_users(int index, const char* value);
  void set_users(int index, const char* value, std::size_t size);
  void set_users(int index, absl::string_view value);
  std::string* add_users();
  void add_users(const std::string& value);
  void add_users(std::string&& value);
  void add_users(const char* value);
  void add_users(const char* value, std::size_t size);
  void add_users(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_users();

  private:
  const std::string& _internal_users(int index) const;
  std::string* _internal_add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_users();

  public:
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthUserListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> users_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleDeleteResponse) */ {
 public:
  inline AuthRoleDeleteResponse() : AuthRoleDeleteResponse(nullptr) {}
  ~AuthRoleDeleteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleDeleteResponse(const AuthRoleDeleteResponse& from);
  AuthRoleDeleteResponse(AuthRoleDeleteResponse&& from) noexcept
    : AuthRoleDeleteResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleDeleteResponse& operator=(const AuthRoleDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleDeleteResponse& operator=(AuthRoleDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleDeleteResponse*>(
               &_AuthRoleDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(AuthRoleDeleteResponse& a, AuthRoleDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleDeleteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleDeleteResponse& from) {
    AuthRoleDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleDeleteResponse";
  }
  protected:
  explicit AuthRoleDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleGrantPermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleGrantPermissionResponse) */ {
 public:
  inline AuthRoleGrantPermissionResponse() : AuthRoleGrantPermissionResponse(nullptr) {}
  ~AuthRoleGrantPermissionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleGrantPermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleGrantPermissionResponse(const AuthRoleGrantPermissionResponse& from);
  AuthRoleGrantPermissionResponse(AuthRoleGrantPermissionResponse&& from) noexcept
    : AuthRoleGrantPermissionResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleGrantPermissionResponse& operator=(const AuthRoleGrantPermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleGrantPermissionResponse& operator=(AuthRoleGrantPermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleGrantPermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleGrantPermissionResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleGrantPermissionResponse*>(
               &_AuthRoleGrantPermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(AuthRoleGrantPermissionResponse& a, AuthRoleGrantPermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleGrantPermissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleGrantPermissionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleGrantPermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleGrantPermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleGrantPermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleGrantPermissionResponse& from) {
    AuthRoleGrantPermissionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleGrantPermissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleGrantPermissionResponse";
  }
  protected:
  explicit AuthRoleGrantPermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleGrantPermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};// -------------------------------------------------------------------

class AuthRoleRevokePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:etcdserverpb.AuthRoleRevokePermissionResponse) */ {
 public:
  inline AuthRoleRevokePermissionResponse() : AuthRoleRevokePermissionResponse(nullptr) {}
  ~AuthRoleRevokePermissionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRoleRevokePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRoleRevokePermissionResponse(const AuthRoleRevokePermissionResponse& from);
  AuthRoleRevokePermissionResponse(AuthRoleRevokePermissionResponse&& from) noexcept
    : AuthRoleRevokePermissionResponse() {
    *this = ::std::move(from);
  }

  inline AuthRoleRevokePermissionResponse& operator=(const AuthRoleRevokePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRoleRevokePermissionResponse& operator=(AuthRoleRevokePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRoleRevokePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRoleRevokePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const AuthRoleRevokePermissionResponse*>(
               &_AuthRoleRevokePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(AuthRoleRevokePermissionResponse& a, AuthRoleRevokePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRoleRevokePermissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRoleRevokePermissionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRoleRevokePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRoleRevokePermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRoleRevokePermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRoleRevokePermissionResponse& from) {
    AuthRoleRevokePermissionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRoleRevokePermissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "etcdserverpb.AuthRoleRevokePermissionResponse";
  }
  protected:
  explicit AuthRoleRevokePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .etcdserverpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::etcdserverpb::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::etcdserverpb::ResponseHeader* release_header();
  ::etcdserverpb::ResponseHeader* mutable_header();
  void set_allocated_header(::etcdserverpb::ResponseHeader* header);
  private:
  const ::etcdserverpb::ResponseHeader& _internal_header() const;
  ::etcdserverpb::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::etcdserverpb::ResponseHeader* header);
  ::etcdserverpb::ResponseHeader* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:etcdserverpb.AuthRoleRevokePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::etcdserverpb::ResponseHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  _impl_.cluster_id_ = ::uint64_t{0u};
}
inline ::uint64_t ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseHeader.cluster_id)
  return _internal_cluster_id();
}
inline void ResponseHeader::set_cluster_id(::uint64_t value) {
  _internal_set_cluster_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.ResponseHeader.cluster_id)
}
inline ::uint64_t ResponseHeader::_internal_cluster_id() const {
  return _impl_.cluster_id_;
}
inline void ResponseHeader::_internal_set_cluster_id(::uint64_t value) {
  ;
  _impl_.cluster_id_ = value;
}

// uint64 member_id = 2;
inline void ResponseHeader::clear_member_id() {
  _impl_.member_id_ = ::uint64_t{0u};
}
inline ::uint64_t ResponseHeader::member_id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseHeader.member_id)
  return _internal_member_id();
}
inline void ResponseHeader::set_member_id(::uint64_t value) {
  _internal_set_member_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.ResponseHeader.member_id)
}
inline ::uint64_t ResponseHeader::_internal_member_id() const {
  return _impl_.member_id_;
}
inline void ResponseHeader::_internal_set_member_id(::uint64_t value) {
  ;
  _impl_.member_id_ = value;
}

// int64 revision = 3;
inline void ResponseHeader::clear_revision() {
  _impl_.revision_ = ::int64_t{0};
}
inline ::int64_t ResponseHeader::revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseHeader.revision)
  return _internal_revision();
}
inline void ResponseHeader::set_revision(::int64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.ResponseHeader.revision)
}
inline ::int64_t ResponseHeader::_internal_revision() const {
  return _impl_.revision_;
}
inline void ResponseHeader::_internal_set_revision(::int64_t value) {
  ;
  _impl_.revision_ = value;
}

// uint64 raft_term = 4;
inline void ResponseHeader::clear_raft_term() {
  _impl_.raft_term_ = ::uint64_t{0u};
}
inline ::uint64_t ResponseHeader::raft_term() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseHeader.raft_term)
  return _internal_raft_term();
}
inline void ResponseHeader::set_raft_term(::uint64_t value) {
  _internal_set_raft_term(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.ResponseHeader.raft_term)
}
inline ::uint64_t ResponseHeader::_internal_raft_term() const {
  return _impl_.raft_term_;
}
inline void ResponseHeader::_internal_set_raft_term(::uint64_t value) {
  ;
  _impl_.raft_term_ = value;
}

// -------------------------------------------------------------------

// RangeRequest

// bytes key = 1;
inline void RangeRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RangeRequest::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.key)
}
inline std::string* RangeRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RangeRequest.key)
  return _s;
}
inline const std::string& RangeRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RangeRequest::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeRequest::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* RangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RangeRequest.key)
  return _impl_.key_.Release();
}
inline void RangeRequest::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RangeRequest.key)
}

// bytes range_end = 2;
inline void RangeRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& RangeRequest::range_end() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.range_end)
  return _internal_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeRequest::set_range_end(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.range_end_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.range_end)
}
inline std::string* RangeRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RangeRequest.range_end)
  return _s;
}
inline const std::string& RangeRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void RangeRequest::_internal_set_range_end(const std::string& value) {
  ;


  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeRequest::_internal_mutable_range_end() {
  ;
  return _impl_.range_end_.Mutable( GetArenaForAllocation());
}
inline std::string* RangeRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RangeRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void RangeRequest::set_allocated_range_end(std::string* value) {
  _impl_.range_end_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_end_.IsDefault()) {
          _impl_.range_end_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RangeRequest.range_end)
}

// int64 limit = 3;
inline void RangeRequest::clear_limit() {
  _impl_.limit_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::limit() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.limit)
  return _internal_limit();
}
inline void RangeRequest::set_limit(::int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.limit)
}
inline ::int64_t RangeRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void RangeRequest::_internal_set_limit(::int64_t value) {
  ;
  _impl_.limit_ = value;
}

// int64 revision = 4;
inline void RangeRequest::clear_revision() {
  _impl_.revision_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.revision)
  return _internal_revision();
}
inline void RangeRequest::set_revision(::int64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.revision)
}
inline ::int64_t RangeRequest::_internal_revision() const {
  return _impl_.revision_;
}
inline void RangeRequest::_internal_set_revision(::int64_t value) {
  ;
  _impl_.revision_ = value;
}

// .etcdserverpb.RangeRequest.SortOrder sort_order = 5;
inline void RangeRequest::clear_sort_order() {
  _impl_.sort_order_ = 0;
}
inline ::etcdserverpb::RangeRequest_SortOrder RangeRequest::sort_order() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.sort_order)
  return _internal_sort_order();
}
inline void RangeRequest::set_sort_order(::etcdserverpb::RangeRequest_SortOrder value) {
   _internal_set_sort_order(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.sort_order)
}
inline ::etcdserverpb::RangeRequest_SortOrder RangeRequest::_internal_sort_order() const {
  return static_cast<::etcdserverpb::RangeRequest_SortOrder>(_impl_.sort_order_);
}
inline void RangeRequest::_internal_set_sort_order(::etcdserverpb::RangeRequest_SortOrder value) {
  ;
  _impl_.sort_order_ = value;
}

// .etcdserverpb.RangeRequest.SortTarget sort_target = 6;
inline void RangeRequest::clear_sort_target() {
  _impl_.sort_target_ = 0;
}
inline ::etcdserverpb::RangeRequest_SortTarget RangeRequest::sort_target() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.sort_target)
  return _internal_sort_target();
}
inline void RangeRequest::set_sort_target(::etcdserverpb::RangeRequest_SortTarget value) {
   _internal_set_sort_target(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.sort_target)
}
inline ::etcdserverpb::RangeRequest_SortTarget RangeRequest::_internal_sort_target() const {
  return static_cast<::etcdserverpb::RangeRequest_SortTarget>(_impl_.sort_target_);
}
inline void RangeRequest::_internal_set_sort_target(::etcdserverpb::RangeRequest_SortTarget value) {
  ;
  _impl_.sort_target_ = value;
}

// bool serializable = 7;
inline void RangeRequest::clear_serializable() {
  _impl_.serializable_ = false;
}
inline bool RangeRequest::serializable() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.serializable)
  return _internal_serializable();
}
inline void RangeRequest::set_serializable(bool value) {
  _internal_set_serializable(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.serializable)
}
inline bool RangeRequest::_internal_serializable() const {
  return _impl_.serializable_;
}
inline void RangeRequest::_internal_set_serializable(bool value) {
  ;
  _impl_.serializable_ = value;
}

// bool keys_only = 8;
inline void RangeRequest::clear_keys_only() {
  _impl_.keys_only_ = false;
}
inline bool RangeRequest::keys_only() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.keys_only)
  return _internal_keys_only();
}
inline void RangeRequest::set_keys_only(bool value) {
  _internal_set_keys_only(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.keys_only)
}
inline bool RangeRequest::_internal_keys_only() const {
  return _impl_.keys_only_;
}
inline void RangeRequest::_internal_set_keys_only(bool value) {
  ;
  _impl_.keys_only_ = value;
}

// bool count_only = 9;
inline void RangeRequest::clear_count_only() {
  _impl_.count_only_ = false;
}
inline bool RangeRequest::count_only() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.count_only)
  return _internal_count_only();
}
inline void RangeRequest::set_count_only(bool value) {
  _internal_set_count_only(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.count_only)
}
inline bool RangeRequest::_internal_count_only() const {
  return _impl_.count_only_;
}
inline void RangeRequest::_internal_set_count_only(bool value) {
  ;
  _impl_.count_only_ = value;
}

// int64 min_mod_revision = 10;
inline void RangeRequest::clear_min_mod_revision() {
  _impl_.min_mod_revision_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::min_mod_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.min_mod_revision)
  return _internal_min_mod_revision();
}
inline void RangeRequest::set_min_mod_revision(::int64_t value) {
  _internal_set_min_mod_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.min_mod_revision)
}
inline ::int64_t RangeRequest::_internal_min_mod_revision() const {
  return _impl_.min_mod_revision_;
}
inline void RangeRequest::_internal_set_min_mod_revision(::int64_t value) {
  ;
  _impl_.min_mod_revision_ = value;
}

// int64 max_mod_revision = 11;
inline void RangeRequest::clear_max_mod_revision() {
  _impl_.max_mod_revision_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::max_mod_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.max_mod_revision)
  return _internal_max_mod_revision();
}
inline void RangeRequest::set_max_mod_revision(::int64_t value) {
  _internal_set_max_mod_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.max_mod_revision)
}
inline ::int64_t RangeRequest::_internal_max_mod_revision() const {
  return _impl_.max_mod_revision_;
}
inline void RangeRequest::_internal_set_max_mod_revision(::int64_t value) {
  ;
  _impl_.max_mod_revision_ = value;
}

// int64 min_create_revision = 12;
inline void RangeRequest::clear_min_create_revision() {
  _impl_.min_create_revision_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::min_create_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.min_create_revision)
  return _internal_min_create_revision();
}
inline void RangeRequest::set_min_create_revision(::int64_t value) {
  _internal_set_min_create_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.min_create_revision)
}
inline ::int64_t RangeRequest::_internal_min_create_revision() const {
  return _impl_.min_create_revision_;
}
inline void RangeRequest::_internal_set_min_create_revision(::int64_t value) {
  ;
  _impl_.min_create_revision_ = value;
}

// int64 max_create_revision = 13;
inline void RangeRequest::clear_max_create_revision() {
  _impl_.max_create_revision_ = ::int64_t{0};
}
inline ::int64_t RangeRequest::max_create_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeRequest.max_create_revision)
  return _internal_max_create_revision();
}
inline void RangeRequest::set_max_create_revision(::int64_t value) {
  _internal_set_max_create_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeRequest.max_create_revision)
}
inline ::int64_t RangeRequest::_internal_max_create_revision() const {
  return _impl_.max_create_revision_;
}
inline void RangeRequest::_internal_set_max_create_revision(::int64_t value) {
  ;
  _impl_.max_create_revision_ = value;
}

// -------------------------------------------------------------------

// RangeResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool RangeResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void RangeResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& RangeResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& RangeResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeResponse.header)
  return _internal_header();
}
inline void RangeResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.RangeResponse.header)
}
inline ::etcdserverpb::ResponseHeader* RangeResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* RangeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RangeResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* RangeResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* RangeResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RangeResponse.header)
  return _msg;
}
inline void RangeResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RangeResponse.header)
}

// repeated .mvccpb.KeyValue kvs = 2;
inline int RangeResponse::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int RangeResponse::kvs_size() const {
  return _internal_kvs_size();
}
inline ::mvccpb::KeyValue* RangeResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RangeResponse.kvs)
  return _internal_mutable_kvs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >*
RangeResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.RangeResponse.kvs)
  return _internal_mutable_kvs();
}
inline const ::mvccpb::KeyValue& RangeResponse::_internal_kvs(int index) const {
  return _internal_kvs().Get(index);
}
inline const ::mvccpb::KeyValue& RangeResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeResponse.kvs)
  return _internal_kvs(index);
}
inline ::mvccpb::KeyValue* RangeResponse::_internal_add_kvs() {
  return _internal_mutable_kvs()->Add();
}
inline ::mvccpb::KeyValue* RangeResponse::add_kvs() {
  ::mvccpb::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:etcdserverpb.RangeResponse.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >&
RangeResponse::kvs() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.RangeResponse.kvs)
  return _internal_kvs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>&
RangeResponse::_internal_kvs() const {
  return _impl_.kvs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>*
RangeResponse::_internal_mutable_kvs() {
  return &_impl_.kvs_;
}

// bool more = 3;
inline void RangeResponse::clear_more() {
  _impl_.more_ = false;
}
inline bool RangeResponse::more() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeResponse.more)
  return _internal_more();
}
inline void RangeResponse::set_more(bool value) {
  _internal_set_more(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeResponse.more)
}
inline bool RangeResponse::_internal_more() const {
  return _impl_.more_;
}
inline void RangeResponse::_internal_set_more(bool value) {
  ;
  _impl_.more_ = value;
}

// int64 count = 4;
inline void RangeResponse::clear_count() {
  _impl_.count_ = ::int64_t{0};
}
inline ::int64_t RangeResponse::count() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RangeResponse.count)
  return _internal_count();
}
inline void RangeResponse::set_count(::int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.RangeResponse.count)
}
inline ::int64_t RangeResponse::_internal_count() const {
  return _impl_.count_;
}
inline void RangeResponse::_internal_set_count(::int64_t value) {
  ;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// PutRequest

// bytes key = 1;
inline void PutRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.key)
}
inline std::string* PutRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.PutRequest.key)
  return _s;
}
inline const std::string& PutRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void PutRequest::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.PutRequest.key)
  return _impl_.key_.Release();
}
inline void PutRequest::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.PutRequest.key)
}

// bytes value = 2;
inline void PutRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.value)
}
inline std::string* PutRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.PutRequest.value)
  return _s;
}
inline const std::string& PutRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void PutRequest::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:etcdserverpb.PutRequest.value)
  return _impl_.value_.Release();
}
inline void PutRequest::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.PutRequest.value)
}

// int64 lease = 3;
inline void PutRequest::clear_lease() {
  _impl_.lease_ = ::int64_t{0};
}
inline ::int64_t PutRequest::lease() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.lease)
  return _internal_lease();
}
inline void PutRequest::set_lease(::int64_t value) {
  _internal_set_lease(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.lease)
}
inline ::int64_t PutRequest::_internal_lease() const {
  return _impl_.lease_;
}
inline void PutRequest::_internal_set_lease(::int64_t value) {
  ;
  _impl_.lease_ = value;
}

// bool prev_kv = 4;
inline void PutRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool PutRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.prev_kv)
  return _internal_prev_kv();
}
inline void PutRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.prev_kv)
}
inline bool PutRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline void PutRequest::_internal_set_prev_kv(bool value) {
  ;
  _impl_.prev_kv_ = value;
}

// bool ignore_value = 5;
inline void PutRequest::clear_ignore_value() {
  _impl_.ignore_value_ = false;
}
inline bool PutRequest::ignore_value() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.ignore_value)
  return _internal_ignore_value();
}
inline void PutRequest::set_ignore_value(bool value) {
  _internal_set_ignore_value(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.ignore_value)
}
inline bool PutRequest::_internal_ignore_value() const {
  return _impl_.ignore_value_;
}
inline void PutRequest::_internal_set_ignore_value(bool value) {
  ;
  _impl_.ignore_value_ = value;
}

// bool ignore_lease = 6;
inline void PutRequest::clear_ignore_lease() {
  _impl_.ignore_lease_ = false;
}
inline bool PutRequest::ignore_lease() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutRequest.ignore_lease)
  return _internal_ignore_lease();
}
inline void PutRequest::set_ignore_lease(bool value) {
  _internal_set_ignore_lease(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.PutRequest.ignore_lease)
}
inline bool PutRequest::_internal_ignore_lease() const {
  return _impl_.ignore_lease_;
}
inline void PutRequest::_internal_set_ignore_lease(bool value) {
  ;
  _impl_.ignore_lease_ = value;
}

// -------------------------------------------------------------------

// PutResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool PutResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void PutResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& PutResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutResponse.header)
  return _internal_header();
}
inline void PutResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.PutResponse.header)
}
inline ::etcdserverpb::ResponseHeader* PutResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* PutResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.PutResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* PutResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* PutResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.PutResponse.header)
  return _msg;
}
inline void PutResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.PutResponse.header)
}

// .mvccpb.KeyValue prev_kv = 2;
inline bool PutResponse::has_prev_kv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prev_kv_ != nullptr);
  return value;
}
inline const ::mvccpb::KeyValue& PutResponse::_internal_prev_kv() const {
  const ::mvccpb::KeyValue* p = _impl_.prev_kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::mvccpb::KeyValue&>(
      ::mvccpb::_KeyValue_default_instance_);
}
inline const ::mvccpb::KeyValue& PutResponse::prev_kv() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.PutResponse.prev_kv)
  return _internal_prev_kv();
}
inline void PutResponse::unsafe_arena_set_allocated_prev_kv(
    ::mvccpb::KeyValue* prev_kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  _impl_.prev_kv_ = prev_kv;
  if (prev_kv) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.PutResponse.prev_kv)
}
inline ::mvccpb::KeyValue* PutResponse::release_prev_kv() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mvccpb::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mvccpb::KeyValue* PutResponse::unsafe_arena_release_prev_kv() {
  // @@protoc_insertion_point(field_release:etcdserverpb.PutResponse.prev_kv)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mvccpb::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
  return temp;
}
inline ::mvccpb::KeyValue* PutResponse::_internal_mutable_prev_kv() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.prev_kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::mvccpb::KeyValue>(GetArenaForAllocation());
    _impl_.prev_kv_ = p;
  }
  return _impl_.prev_kv_;
}
inline ::mvccpb::KeyValue* PutResponse::mutable_prev_kv() {
  ::mvccpb::KeyValue* _msg = _internal_mutable_prev_kv();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.PutResponse.prev_kv)
  return _msg;
}
inline void PutResponse::set_allocated_prev_kv(::mvccpb::KeyValue* prev_kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  if (prev_kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_kv));
    if (message_arena != submessage_arena) {
      prev_kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_kv, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.prev_kv_ = prev_kv;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.PutResponse.prev_kv)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// bytes key = 1;
inline void DeleteRangeRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DeleteRangeRequest::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteRangeRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.DeleteRangeRequest.key)
}
inline std::string* DeleteRangeRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.DeleteRangeRequest.key)
  return _s;
}
inline const std::string& DeleteRangeRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DeleteRangeRequest::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.DeleteRangeRequest.key)
  return _impl_.key_.Release();
}
inline void DeleteRangeRequest::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.DeleteRangeRequest.key)
}

// bytes range_end = 2;
inline void DeleteRangeRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& DeleteRangeRequest::range_end() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeRequest.range_end)
  return _internal_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteRangeRequest::set_range_end(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.range_end_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.DeleteRangeRequest.range_end)
}
inline std::string* DeleteRangeRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.DeleteRangeRequest.range_end)
  return _s;
}
inline const std::string& DeleteRangeRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void DeleteRangeRequest::_internal_set_range_end(const std::string& value) {
  ;


  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::_internal_mutable_range_end() {
  ;
  return _impl_.range_end_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:etcdserverpb.DeleteRangeRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void DeleteRangeRequest::set_allocated_range_end(std::string* value) {
  _impl_.range_end_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_end_.IsDefault()) {
          _impl_.range_end_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.DeleteRangeRequest.range_end)
}

// bool prev_kv = 3;
inline void DeleteRangeRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool DeleteRangeRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeRequest.prev_kv)
  return _internal_prev_kv();
}
inline void DeleteRangeRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.DeleteRangeRequest.prev_kv)
}
inline bool DeleteRangeRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline void DeleteRangeRequest::_internal_set_prev_kv(bool value) {
  ;
  _impl_.prev_kv_ = value;
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool DeleteRangeResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void DeleteRangeResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& DeleteRangeResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeResponse.header)
  return _internal_header();
}
inline void DeleteRangeResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.DeleteRangeResponse.header)
}
inline ::etcdserverpb::ResponseHeader* DeleteRangeResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* DeleteRangeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.DeleteRangeResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* DeleteRangeResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* DeleteRangeResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.DeleteRangeResponse.header)
  return _msg;
}
inline void DeleteRangeResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.DeleteRangeResponse.header)
}

// int64 deleted = 2;
inline void DeleteRangeResponse::clear_deleted() {
  _impl_.deleted_ = ::int64_t{0};
}
inline ::int64_t DeleteRangeResponse::deleted() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeResponse.deleted)
  return _internal_deleted();
}
inline void DeleteRangeResponse::set_deleted(::int64_t value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.DeleteRangeResponse.deleted)
}
inline ::int64_t DeleteRangeResponse::_internal_deleted() const {
  return _impl_.deleted_;
}
inline void DeleteRangeResponse::_internal_set_deleted(::int64_t value) {
  ;
  _impl_.deleted_ = value;
}

// repeated .mvccpb.KeyValue prev_kvs = 3;
inline int DeleteRangeResponse::_internal_prev_kvs_size() const {
  return _impl_.prev_kvs_.size();
}
inline int DeleteRangeResponse::prev_kvs_size() const {
  return _internal_prev_kvs_size();
}
inline ::mvccpb::KeyValue* DeleteRangeResponse::mutable_prev_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.DeleteRangeResponse.prev_kvs)
  return _internal_mutable_prev_kvs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >*
DeleteRangeResponse::mutable_prev_kvs() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.DeleteRangeResponse.prev_kvs)
  return _internal_mutable_prev_kvs();
}
inline const ::mvccpb::KeyValue& DeleteRangeResponse::_internal_prev_kvs(int index) const {
  return _internal_prev_kvs().Get(index);
}
inline const ::mvccpb::KeyValue& DeleteRangeResponse::prev_kvs(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DeleteRangeResponse.prev_kvs)
  return _internal_prev_kvs(index);
}
inline ::mvccpb::KeyValue* DeleteRangeResponse::_internal_add_prev_kvs() {
  return _internal_mutable_prev_kvs()->Add();
}
inline ::mvccpb::KeyValue* DeleteRangeResponse::add_prev_kvs() {
  ::mvccpb::KeyValue* _add = _internal_add_prev_kvs();
  // @@protoc_insertion_point(field_add:etcdserverpb.DeleteRangeResponse.prev_kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::KeyValue >&
DeleteRangeResponse::prev_kvs() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.DeleteRangeResponse.prev_kvs)
  return _internal_prev_kvs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>&
DeleteRangeResponse::_internal_prev_kvs() const {
  return _impl_.prev_kvs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::KeyValue>*
DeleteRangeResponse::_internal_mutable_prev_kvs() {
  return &_impl_.prev_kvs_;
}

// -------------------------------------------------------------------

// RequestOp

// .etcdserverpb.RangeRequest request_range = 1;
inline bool RequestOp::has_request_range() const {
  return request_case() == kRequestRange;
}
inline bool RequestOp::_internal_has_request_range() const {
  return request_case() == kRequestRange;
}
inline void RequestOp::set_has_request_range() {
  _impl_._oneof_case_[0] = kRequestRange;
}
inline void RequestOp::clear_request_range() {
  if (request_case() == kRequestRange) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.request_range_;
    }
    clear_has_request();
  }
}
inline ::etcdserverpb::RangeRequest* RequestOp::release_request_range() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RequestOp.request_range)
  if (request_case() == kRequestRange) {
    clear_has_request();
    ::etcdserverpb::RangeRequest* temp = _impl_.request_.request_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.request_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::RangeRequest& RequestOp::_internal_request_range() const {
  return request_case() == kRequestRange
      ? *_impl_.request_.request_range_
      : reinterpret_cast<::etcdserverpb::RangeRequest&>(::etcdserverpb::_RangeRequest_default_instance_);
}
inline const ::etcdserverpb::RangeRequest& RequestOp::request_range() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RequestOp.request_range)
  return _internal_request_range();
}
inline ::etcdserverpb::RangeRequest* RequestOp::unsafe_arena_release_request_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.RequestOp.request_range)
  if (request_case() == kRequestRange) {
    clear_has_request();
    ::etcdserverpb::RangeRequest* temp = _impl_.request_.request_range_;
    _impl_.request_.request_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestOp::unsafe_arena_set_allocated_request_range(::etcdserverpb::RangeRequest* request_range) {
  clear_request();
  if (request_range) {
    set_has_request_range();
    _impl_.request_.request_range_ = request_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.RequestOp.request_range)
}
inline ::etcdserverpb::RangeRequest* RequestOp::_internal_mutable_request_range() {
  if (request_case() != kRequestRange) {
    clear_request();
    set_has_request_range();
    _impl_.request_.request_range_ = CreateMaybeMessage< ::etcdserverpb::RangeRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.request_range_;
}
inline ::etcdserverpb::RangeRequest* RequestOp::mutable_request_range() {
  ::etcdserverpb::RangeRequest* _msg = _internal_mutable_request_range();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RequestOp.request_range)
  return _msg;
}

// .etcdserverpb.PutRequest request_put = 2;
inline bool RequestOp::has_request_put() const {
  return request_case() == kRequestPut;
}
inline bool RequestOp::_internal_has_request_put() const {
  return request_case() == kRequestPut;
}
inline void RequestOp::set_has_request_put() {
  _impl_._oneof_case_[0] = kRequestPut;
}
inline void RequestOp::clear_request_put() {
  if (request_case() == kRequestPut) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.request_put_;
    }
    clear_has_request();
  }
}
inline ::etcdserverpb::PutRequest* RequestOp::release_request_put() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RequestOp.request_put)
  if (request_case() == kRequestPut) {
    clear_has_request();
    ::etcdserverpb::PutRequest* temp = _impl_.request_.request_put_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.request_put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::PutRequest& RequestOp::_internal_request_put() const {
  return request_case() == kRequestPut
      ? *_impl_.request_.request_put_
      : reinterpret_cast<::etcdserverpb::PutRequest&>(::etcdserverpb::_PutRequest_default_instance_);
}
inline const ::etcdserverpb::PutRequest& RequestOp::request_put() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RequestOp.request_put)
  return _internal_request_put();
}
inline ::etcdserverpb::PutRequest* RequestOp::unsafe_arena_release_request_put() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.RequestOp.request_put)
  if (request_case() == kRequestPut) {
    clear_has_request();
    ::etcdserverpb::PutRequest* temp = _impl_.request_.request_put_;
    _impl_.request_.request_put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestOp::unsafe_arena_set_allocated_request_put(::etcdserverpb::PutRequest* request_put) {
  clear_request();
  if (request_put) {
    set_has_request_put();
    _impl_.request_.request_put_ = request_put;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.RequestOp.request_put)
}
inline ::etcdserverpb::PutRequest* RequestOp::_internal_mutable_request_put() {
  if (request_case() != kRequestPut) {
    clear_request();
    set_has_request_put();
    _impl_.request_.request_put_ = CreateMaybeMessage< ::etcdserverpb::PutRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.request_put_;
}
inline ::etcdserverpb::PutRequest* RequestOp::mutable_request_put() {
  ::etcdserverpb::PutRequest* _msg = _internal_mutable_request_put();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RequestOp.request_put)
  return _msg;
}

// .etcdserverpb.DeleteRangeRequest request_delete_range = 3;
inline bool RequestOp::has_request_delete_range() const {
  return request_case() == kRequestDeleteRange;
}
inline bool RequestOp::_internal_has_request_delete_range() const {
  return request_case() == kRequestDeleteRange;
}
inline void RequestOp::set_has_request_delete_range() {
  _impl_._oneof_case_[0] = kRequestDeleteRange;
}
inline void RequestOp::clear_request_delete_range() {
  if (request_case() == kRequestDeleteRange) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.request_delete_range_;
    }
    clear_has_request();
  }
}
inline ::etcdserverpb::DeleteRangeRequest* RequestOp::release_request_delete_range() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RequestOp.request_delete_range)
  if (request_case() == kRequestDeleteRange) {
    clear_has_request();
    ::etcdserverpb::DeleteRangeRequest* temp = _impl_.request_.request_delete_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.request_delete_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::DeleteRangeRequest& RequestOp::_internal_request_delete_range() const {
  return request_case() == kRequestDeleteRange
      ? *_impl_.request_.request_delete_range_
      : reinterpret_cast<::etcdserverpb::DeleteRangeRequest&>(::etcdserverpb::_DeleteRangeRequest_default_instance_);
}
inline const ::etcdserverpb::DeleteRangeRequest& RequestOp::request_delete_range() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RequestOp.request_delete_range)
  return _internal_request_delete_range();
}
inline ::etcdserverpb::DeleteRangeRequest* RequestOp::unsafe_arena_release_request_delete_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.RequestOp.request_delete_range)
  if (request_case() == kRequestDeleteRange) {
    clear_has_request();
    ::etcdserverpb::DeleteRangeRequest* temp = _impl_.request_.request_delete_range_;
    _impl_.request_.request_delete_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestOp::unsafe_arena_set_allocated_request_delete_range(::etcdserverpb::DeleteRangeRequest* request_delete_range) {
  clear_request();
  if (request_delete_range) {
    set_has_request_delete_range();
    _impl_.request_.request_delete_range_ = request_delete_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.RequestOp.request_delete_range)
}
inline ::etcdserverpb::DeleteRangeRequest* RequestOp::_internal_mutable_request_delete_range() {
  if (request_case() != kRequestDeleteRange) {
    clear_request();
    set_has_request_delete_range();
    _impl_.request_.request_delete_range_ = CreateMaybeMessage< ::etcdserverpb::DeleteRangeRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.request_delete_range_;
}
inline ::etcdserverpb::DeleteRangeRequest* RequestOp::mutable_request_delete_range() {
  ::etcdserverpb::DeleteRangeRequest* _msg = _internal_mutable_request_delete_range();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RequestOp.request_delete_range)
  return _msg;
}

// .etcdserverpb.TxnRequest request_txn = 4;
inline bool RequestOp::has_request_txn() const {
  return request_case() == kRequestTxn;
}
inline bool RequestOp::_internal_has_request_txn() const {
  return request_case() == kRequestTxn;
}
inline void RequestOp::set_has_request_txn() {
  _impl_._oneof_case_[0] = kRequestTxn;
}
inline void RequestOp::clear_request_txn() {
  if (request_case() == kRequestTxn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.request_txn_;
    }
    clear_has_request();
  }
}
inline ::etcdserverpb::TxnRequest* RequestOp::release_request_txn() {
  // @@protoc_insertion_point(field_release:etcdserverpb.RequestOp.request_txn)
  if (request_case() == kRequestTxn) {
    clear_has_request();
    ::etcdserverpb::TxnRequest* temp = _impl_.request_.request_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.request_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::TxnRequest& RequestOp::_internal_request_txn() const {
  return request_case() == kRequestTxn
      ? *_impl_.request_.request_txn_
      : reinterpret_cast<::etcdserverpb::TxnRequest&>(::etcdserverpb::_TxnRequest_default_instance_);
}
inline const ::etcdserverpb::TxnRequest& RequestOp::request_txn() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.RequestOp.request_txn)
  return _internal_request_txn();
}
inline ::etcdserverpb::TxnRequest* RequestOp::unsafe_arena_release_request_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.RequestOp.request_txn)
  if (request_case() == kRequestTxn) {
    clear_has_request();
    ::etcdserverpb::TxnRequest* temp = _impl_.request_.request_txn_;
    _impl_.request_.request_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestOp::unsafe_arena_set_allocated_request_txn(::etcdserverpb::TxnRequest* request_txn) {
  clear_request();
  if (request_txn) {
    set_has_request_txn();
    _impl_.request_.request_txn_ = request_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.RequestOp.request_txn)
}
inline ::etcdserverpb::TxnRequest* RequestOp::_internal_mutable_request_txn() {
  if (request_case() != kRequestTxn) {
    clear_request();
    set_has_request_txn();
    _impl_.request_.request_txn_ = CreateMaybeMessage< ::etcdserverpb::TxnRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.request_txn_;
}
inline ::etcdserverpb::TxnRequest* RequestOp::mutable_request_txn() {
  ::etcdserverpb::TxnRequest* _msg = _internal_mutable_request_txn();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.RequestOp.request_txn)
  return _msg;
}

inline bool RequestOp::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void RequestOp::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline RequestOp::RequestCase RequestOp::request_case() const {
  return RequestOp::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseOp

// .etcdserverpb.RangeResponse response_range = 1;
inline bool ResponseOp::has_response_range() const {
  return response_case() == kResponseRange;
}
inline bool ResponseOp::_internal_has_response_range() const {
  return response_case() == kResponseRange;
}
inline void ResponseOp::set_has_response_range() {
  _impl_._oneof_case_[0] = kResponseRange;
}
inline void ResponseOp::clear_response_range() {
  if (response_case() == kResponseRange) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.response_range_;
    }
    clear_has_response();
  }
}
inline ::etcdserverpb::RangeResponse* ResponseOp::release_response_range() {
  // @@protoc_insertion_point(field_release:etcdserverpb.ResponseOp.response_range)
  if (response_case() == kResponseRange) {
    clear_has_response();
    ::etcdserverpb::RangeResponse* temp = _impl_.response_.response_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.response_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::RangeResponse& ResponseOp::_internal_response_range() const {
  return response_case() == kResponseRange
      ? *_impl_.response_.response_range_
      : reinterpret_cast<::etcdserverpb::RangeResponse&>(::etcdserverpb::_RangeResponse_default_instance_);
}
inline const ::etcdserverpb::RangeResponse& ResponseOp::response_range() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseOp.response_range)
  return _internal_response_range();
}
inline ::etcdserverpb::RangeResponse* ResponseOp::unsafe_arena_release_response_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.ResponseOp.response_range)
  if (response_case() == kResponseRange) {
    clear_has_response();
    ::etcdserverpb::RangeResponse* temp = _impl_.response_.response_range_;
    _impl_.response_.response_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOp::unsafe_arena_set_allocated_response_range(::etcdserverpb::RangeResponse* response_range) {
  clear_response();
  if (response_range) {
    set_has_response_range();
    _impl_.response_.response_range_ = response_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.ResponseOp.response_range)
}
inline ::etcdserverpb::RangeResponse* ResponseOp::_internal_mutable_response_range() {
  if (response_case() != kResponseRange) {
    clear_response();
    set_has_response_range();
    _impl_.response_.response_range_ = CreateMaybeMessage< ::etcdserverpb::RangeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.response_range_;
}
inline ::etcdserverpb::RangeResponse* ResponseOp::mutable_response_range() {
  ::etcdserverpb::RangeResponse* _msg = _internal_mutable_response_range();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.ResponseOp.response_range)
  return _msg;
}

// .etcdserverpb.PutResponse response_put = 2;
inline bool ResponseOp::has_response_put() const {
  return response_case() == kResponsePut;
}
inline bool ResponseOp::_internal_has_response_put() const {
  return response_case() == kResponsePut;
}
inline void ResponseOp::set_has_response_put() {
  _impl_._oneof_case_[0] = kResponsePut;
}
inline void ResponseOp::clear_response_put() {
  if (response_case() == kResponsePut) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.response_put_;
    }
    clear_has_response();
  }
}
inline ::etcdserverpb::PutResponse* ResponseOp::release_response_put() {
  // @@protoc_insertion_point(field_release:etcdserverpb.ResponseOp.response_put)
  if (response_case() == kResponsePut) {
    clear_has_response();
    ::etcdserverpb::PutResponse* temp = _impl_.response_.response_put_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.response_put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::PutResponse& ResponseOp::_internal_response_put() const {
  return response_case() == kResponsePut
      ? *_impl_.response_.response_put_
      : reinterpret_cast<::etcdserverpb::PutResponse&>(::etcdserverpb::_PutResponse_default_instance_);
}
inline const ::etcdserverpb::PutResponse& ResponseOp::response_put() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseOp.response_put)
  return _internal_response_put();
}
inline ::etcdserverpb::PutResponse* ResponseOp::unsafe_arena_release_response_put() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.ResponseOp.response_put)
  if (response_case() == kResponsePut) {
    clear_has_response();
    ::etcdserverpb::PutResponse* temp = _impl_.response_.response_put_;
    _impl_.response_.response_put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOp::unsafe_arena_set_allocated_response_put(::etcdserverpb::PutResponse* response_put) {
  clear_response();
  if (response_put) {
    set_has_response_put();
    _impl_.response_.response_put_ = response_put;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.ResponseOp.response_put)
}
inline ::etcdserverpb::PutResponse* ResponseOp::_internal_mutable_response_put() {
  if (response_case() != kResponsePut) {
    clear_response();
    set_has_response_put();
    _impl_.response_.response_put_ = CreateMaybeMessage< ::etcdserverpb::PutResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.response_put_;
}
inline ::etcdserverpb::PutResponse* ResponseOp::mutable_response_put() {
  ::etcdserverpb::PutResponse* _msg = _internal_mutable_response_put();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.ResponseOp.response_put)
  return _msg;
}

// .etcdserverpb.DeleteRangeResponse response_delete_range = 3;
inline bool ResponseOp::has_response_delete_range() const {
  return response_case() == kResponseDeleteRange;
}
inline bool ResponseOp::_internal_has_response_delete_range() const {
  return response_case() == kResponseDeleteRange;
}
inline void ResponseOp::set_has_response_delete_range() {
  _impl_._oneof_case_[0] = kResponseDeleteRange;
}
inline void ResponseOp::clear_response_delete_range() {
  if (response_case() == kResponseDeleteRange) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.response_delete_range_;
    }
    clear_has_response();
  }
}
inline ::etcdserverpb::DeleteRangeResponse* ResponseOp::release_response_delete_range() {
  // @@protoc_insertion_point(field_release:etcdserverpb.ResponseOp.response_delete_range)
  if (response_case() == kResponseDeleteRange) {
    clear_has_response();
    ::etcdserverpb::DeleteRangeResponse* temp = _impl_.response_.response_delete_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.response_delete_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::DeleteRangeResponse& ResponseOp::_internal_response_delete_range() const {
  return response_case() == kResponseDeleteRange
      ? *_impl_.response_.response_delete_range_
      : reinterpret_cast<::etcdserverpb::DeleteRangeResponse&>(::etcdserverpb::_DeleteRangeResponse_default_instance_);
}
inline const ::etcdserverpb::DeleteRangeResponse& ResponseOp::response_delete_range() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseOp.response_delete_range)
  return _internal_response_delete_range();
}
inline ::etcdserverpb::DeleteRangeResponse* ResponseOp::unsafe_arena_release_response_delete_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.ResponseOp.response_delete_range)
  if (response_case() == kResponseDeleteRange) {
    clear_has_response();
    ::etcdserverpb::DeleteRangeResponse* temp = _impl_.response_.response_delete_range_;
    _impl_.response_.response_delete_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOp::unsafe_arena_set_allocated_response_delete_range(::etcdserverpb::DeleteRangeResponse* response_delete_range) {
  clear_response();
  if (response_delete_range) {
    set_has_response_delete_range();
    _impl_.response_.response_delete_range_ = response_delete_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.ResponseOp.response_delete_range)
}
inline ::etcdserverpb::DeleteRangeResponse* ResponseOp::_internal_mutable_response_delete_range() {
  if (response_case() != kResponseDeleteRange) {
    clear_response();
    set_has_response_delete_range();
    _impl_.response_.response_delete_range_ = CreateMaybeMessage< ::etcdserverpb::DeleteRangeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.response_delete_range_;
}
inline ::etcdserverpb::DeleteRangeResponse* ResponseOp::mutable_response_delete_range() {
  ::etcdserverpb::DeleteRangeResponse* _msg = _internal_mutable_response_delete_range();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.ResponseOp.response_delete_range)
  return _msg;
}

// .etcdserverpb.TxnResponse response_txn = 4;
inline bool ResponseOp::has_response_txn() const {
  return response_case() == kResponseTxn;
}
inline bool ResponseOp::_internal_has_response_txn() const {
  return response_case() == kResponseTxn;
}
inline void ResponseOp::set_has_response_txn() {
  _impl_._oneof_case_[0] = kResponseTxn;
}
inline void ResponseOp::clear_response_txn() {
  if (response_case() == kResponseTxn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.response_txn_;
    }
    clear_has_response();
  }
}
inline ::etcdserverpb::TxnResponse* ResponseOp::release_response_txn() {
  // @@protoc_insertion_point(field_release:etcdserverpb.ResponseOp.response_txn)
  if (response_case() == kResponseTxn) {
    clear_has_response();
    ::etcdserverpb::TxnResponse* temp = _impl_.response_.response_txn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.response_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::TxnResponse& ResponseOp::_internal_response_txn() const {
  return response_case() == kResponseTxn
      ? *_impl_.response_.response_txn_
      : reinterpret_cast<::etcdserverpb::TxnResponse&>(::etcdserverpb::_TxnResponse_default_instance_);
}
inline const ::etcdserverpb::TxnResponse& ResponseOp::response_txn() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.ResponseOp.response_txn)
  return _internal_response_txn();
}
inline ::etcdserverpb::TxnResponse* ResponseOp::unsafe_arena_release_response_txn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.ResponseOp.response_txn)
  if (response_case() == kResponseTxn) {
    clear_has_response();
    ::etcdserverpb::TxnResponse* temp = _impl_.response_.response_txn_;
    _impl_.response_.response_txn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseOp::unsafe_arena_set_allocated_response_txn(::etcdserverpb::TxnResponse* response_txn) {
  clear_response();
  if (response_txn) {
    set_has_response_txn();
    _impl_.response_.response_txn_ = response_txn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.ResponseOp.response_txn)
}
inline ::etcdserverpb::TxnResponse* ResponseOp::_internal_mutable_response_txn() {
  if (response_case() != kResponseTxn) {
    clear_response();
    set_has_response_txn();
    _impl_.response_.response_txn_ = CreateMaybeMessage< ::etcdserverpb::TxnResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.response_txn_;
}
inline ::etcdserverpb::TxnResponse* ResponseOp::mutable_response_txn() {
  ::etcdserverpb::TxnResponse* _msg = _internal_mutable_response_txn();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.ResponseOp.response_txn)
  return _msg;
}

inline bool ResponseOp::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ResponseOp::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ResponseOp::ResponseCase ResponseOp::response_case() const {
  return ResponseOp::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Compare

// .etcdserverpb.Compare.CompareResult result = 1;
inline void Compare::clear_result() {
  _impl_.result_ = 0;
}
inline ::etcdserverpb::Compare_CompareResult Compare::result() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.result)
  return _internal_result();
}
inline void Compare::set_result(::etcdserverpb::Compare_CompareResult value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.result)
}
inline ::etcdserverpb::Compare_CompareResult Compare::_internal_result() const {
  return static_cast<::etcdserverpb::Compare_CompareResult>(_impl_.result_);
}
inline void Compare::_internal_set_result(::etcdserverpb::Compare_CompareResult value) {
  ;
  _impl_.result_ = value;
}

// .etcdserverpb.Compare.CompareTarget target = 2;
inline void Compare::clear_target() {
  _impl_.target_ = 0;
}
inline ::etcdserverpb::Compare_CompareTarget Compare::target() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.target)
  return _internal_target();
}
inline void Compare::set_target(::etcdserverpb::Compare_CompareTarget value) {
   _internal_set_target(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.target)
}
inline ::etcdserverpb::Compare_CompareTarget Compare::_internal_target() const {
  return static_cast<::etcdserverpb::Compare_CompareTarget>(_impl_.target_);
}
inline void Compare::_internal_set_target(::etcdserverpb::Compare_CompareTarget value) {
  ;
  _impl_.target_ = value;
}

// bytes key = 3;
inline void Compare::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Compare::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compare::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.key)
}
inline std::string* Compare::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Compare.key)
  return _s;
}
inline const std::string& Compare::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Compare::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Compare::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* Compare::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.Compare.key)
  return _impl_.key_.Release();
}
inline void Compare::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.Compare.key)
}

// int64 version = 4;
inline bool Compare::has_version() const {
  return target_union_case() == kVersion;
}
inline void Compare::set_has_version() {
  _impl_._oneof_case_[0] = kVersion;
}
inline void Compare::clear_version() {
  if (target_union_case() == kVersion) {
    _impl_.target_union_.version_ = ::int64_t{0};
    clear_has_target_union();
  }
}
inline ::int64_t Compare::version() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.version)
  return _internal_version();
}
inline void Compare::set_version(::int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.version)
}
inline ::int64_t Compare::_internal_version() const {
  if (target_union_case() == kVersion) {
    return _impl_.target_union_.version_;
  }
  return ::int64_t{0};
}
inline void Compare::_internal_set_version(::int64_t value) {
  if (target_union_case() != kVersion) {
    clear_target_union();
    set_has_version();
  }
  _impl_.target_union_.version_ = value;
}

// int64 create_revision = 5;
inline bool Compare::has_create_revision() const {
  return target_union_case() == kCreateRevision;
}
inline void Compare::set_has_create_revision() {
  _impl_._oneof_case_[0] = kCreateRevision;
}
inline void Compare::clear_create_revision() {
  if (target_union_case() == kCreateRevision) {
    _impl_.target_union_.create_revision_ = ::int64_t{0};
    clear_has_target_union();
  }
}
inline ::int64_t Compare::create_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.create_revision)
  return _internal_create_revision();
}
inline void Compare::set_create_revision(::int64_t value) {
  _internal_set_create_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.create_revision)
}
inline ::int64_t Compare::_internal_create_revision() const {
  if (target_union_case() == kCreateRevision) {
    return _impl_.target_union_.create_revision_;
  }
  return ::int64_t{0};
}
inline void Compare::_internal_set_create_revision(::int64_t value) {
  if (target_union_case() != kCreateRevision) {
    clear_target_union();
    set_has_create_revision();
  }
  _impl_.target_union_.create_revision_ = value;
}

// int64 mod_revision = 6;
inline bool Compare::has_mod_revision() const {
  return target_union_case() == kModRevision;
}
inline void Compare::set_has_mod_revision() {
  _impl_._oneof_case_[0] = kModRevision;
}
inline void Compare::clear_mod_revision() {
  if (target_union_case() == kModRevision) {
    _impl_.target_union_.mod_revision_ = ::int64_t{0};
    clear_has_target_union();
  }
}
inline ::int64_t Compare::mod_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.mod_revision)
  return _internal_mod_revision();
}
inline void Compare::set_mod_revision(::int64_t value) {
  _internal_set_mod_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.mod_revision)
}
inline ::int64_t Compare::_internal_mod_revision() const {
  if (target_union_case() == kModRevision) {
    return _impl_.target_union_.mod_revision_;
  }
  return ::int64_t{0};
}
inline void Compare::_internal_set_mod_revision(::int64_t value) {
  if (target_union_case() != kModRevision) {
    clear_target_union();
    set_has_mod_revision();
  }
  _impl_.target_union_.mod_revision_ = value;
}

// bytes value = 7;
inline bool Compare::has_value() const {
  return target_union_case() == kValue;
}
inline void Compare::set_has_value() {
  _impl_._oneof_case_[0] = kValue;
}
inline void Compare::clear_value() {
  if (target_union_case() == kValue) {
    _impl_.target_union_.value_.Destroy();
    clear_has_target_union();
  }
}
inline const std::string& Compare::value() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compare::set_value(Arg_&& arg,
                                                     Args_... args) {
  if (target_union_case() != kValue) {
    clear_target_union();

    set_has_value();
    _impl_.target_union_.value_.InitDefault();
  }
  _impl_.target_union_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.value)
}
inline std::string* Compare::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Compare.value)
  return _s;
}
inline const std::string& Compare::_internal_value() const {
  if (target_union_case() != kValue) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.target_union_.value_.Get();
}
inline void Compare::_internal_set_value(const std::string& value) {
  if (target_union_case() != kValue) {
    clear_target_union();

    set_has_value();
    _impl_.target_union_.value_.InitDefault();
  }


  _impl_.target_union_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Compare::_internal_mutable_value() {
  if (target_union_case() != kValue) {
    clear_target_union();

    set_has_value();
    _impl_.target_union_.value_.InitDefault();
  }
  return _impl_.target_union_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* Compare::release_value() {
  // @@protoc_insertion_point(field_release:etcdserverpb.Compare.value)
  if (target_union_case() != kValue) {
    return nullptr;
  }
  clear_has_target_union();
  return _impl_.target_union_.value_.Release();
}
inline void Compare::set_allocated_value(std::string* value) {
  if (has_target_union()) {
    clear_target_union();
  }
  if (value != nullptr) {
    set_has_value();
    _impl_.target_union_.value_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.Compare.value)
}

// int64 lease = 8;
inline bool Compare::has_lease() const {
  return target_union_case() == kLease;
}
inline void Compare::set_has_lease() {
  _impl_._oneof_case_[0] = kLease;
}
inline void Compare::clear_lease() {
  if (target_union_case() == kLease) {
    _impl_.target_union_.lease_ = ::int64_t{0};
    clear_has_target_union();
  }
}
inline ::int64_t Compare::lease() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.lease)
  return _internal_lease();
}
inline void Compare::set_lease(::int64_t value) {
  _internal_set_lease(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.lease)
}
inline ::int64_t Compare::_internal_lease() const {
  if (target_union_case() == kLease) {
    return _impl_.target_union_.lease_;
  }
  return ::int64_t{0};
}
inline void Compare::_internal_set_lease(::int64_t value) {
  if (target_union_case() != kLease) {
    clear_target_union();
    set_has_lease();
  }
  _impl_.target_union_.lease_ = value;
}

// bytes range_end = 64;
inline void Compare::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& Compare::range_end() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Compare.range_end)
  return _internal_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Compare::set_range_end(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.range_end_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.Compare.range_end)
}
inline std::string* Compare::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Compare.range_end)
  return _s;
}
inline const std::string& Compare::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void Compare::_internal_set_range_end(const std::string& value) {
  ;


  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* Compare::_internal_mutable_range_end() {
  ;
  return _impl_.range_end_.Mutable( GetArenaForAllocation());
}
inline std::string* Compare::release_range_end() {
  // @@protoc_insertion_point(field_release:etcdserverpb.Compare.range_end)
  return _impl_.range_end_.Release();
}
inline void Compare::set_allocated_range_end(std::string* value) {
  _impl_.range_end_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_end_.IsDefault()) {
          _impl_.range_end_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.Compare.range_end)
}

inline bool Compare::has_target_union() const {
  return target_union_case() != TARGET_UNION_NOT_SET;
}
inline void Compare::clear_has_target_union() {
  _impl_._oneof_case_[0] = TARGET_UNION_NOT_SET;
}
inline Compare::TargetUnionCase Compare::target_union_case() const {
  return Compare::TargetUnionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TxnRequest

// repeated .etcdserverpb.Compare compare = 1;
inline int TxnRequest::_internal_compare_size() const {
  return _impl_.compare_.size();
}
inline int TxnRequest::compare_size() const {
  return _internal_compare_size();
}
inline void TxnRequest::clear_compare() {
  _internal_mutable_compare()->Clear();
}
inline ::etcdserverpb::Compare* TxnRequest::mutable_compare(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.TxnRequest.compare)
  return _internal_mutable_compare()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Compare >*
TxnRequest::mutable_compare() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.TxnRequest.compare)
  return _internal_mutable_compare();
}
inline const ::etcdserverpb::Compare& TxnRequest::_internal_compare(int index) const {
  return _internal_compare().Get(index);
}
inline const ::etcdserverpb::Compare& TxnRequest::compare(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnRequest.compare)
  return _internal_compare(index);
}
inline ::etcdserverpb::Compare* TxnRequest::_internal_add_compare() {
  return _internal_mutable_compare()->Add();
}
inline ::etcdserverpb::Compare* TxnRequest::add_compare() {
  ::etcdserverpb::Compare* _add = _internal_add_compare();
  // @@protoc_insertion_point(field_add:etcdserverpb.TxnRequest.compare)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Compare >&
TxnRequest::compare() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.TxnRequest.compare)
  return _internal_compare();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Compare>&
TxnRequest::_internal_compare() const {
  return _impl_.compare_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Compare>*
TxnRequest::_internal_mutable_compare() {
  return &_impl_.compare_;
}

// repeated .etcdserverpb.RequestOp success = 2;
inline int TxnRequest::_internal_success_size() const {
  return _impl_.success_.size();
}
inline int TxnRequest::success_size() const {
  return _internal_success_size();
}
inline void TxnRequest::clear_success() {
  _internal_mutable_success()->Clear();
}
inline ::etcdserverpb::RequestOp* TxnRequest::mutable_success(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.TxnRequest.success)
  return _internal_mutable_success()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >*
TxnRequest::mutable_success() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.TxnRequest.success)
  return _internal_mutable_success();
}
inline const ::etcdserverpb::RequestOp& TxnRequest::_internal_success(int index) const {
  return _internal_success().Get(index);
}
inline const ::etcdserverpb::RequestOp& TxnRequest::success(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnRequest.success)
  return _internal_success(index);
}
inline ::etcdserverpb::RequestOp* TxnRequest::_internal_add_success() {
  return _internal_mutable_success()->Add();
}
inline ::etcdserverpb::RequestOp* TxnRequest::add_success() {
  ::etcdserverpb::RequestOp* _add = _internal_add_success();
  // @@protoc_insertion_point(field_add:etcdserverpb.TxnRequest.success)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >&
TxnRequest::success() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.TxnRequest.success)
  return _internal_success();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>&
TxnRequest::_internal_success() const {
  return _impl_.success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>*
TxnRequest::_internal_mutable_success() {
  return &_impl_.success_;
}

// repeated .etcdserverpb.RequestOp failure = 3;
inline int TxnRequest::_internal_failure_size() const {
  return _impl_.failure_.size();
}
inline int TxnRequest::failure_size() const {
  return _internal_failure_size();
}
inline void TxnRequest::clear_failure() {
  _internal_mutable_failure()->Clear();
}
inline ::etcdserverpb::RequestOp* TxnRequest::mutable_failure(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.TxnRequest.failure)
  return _internal_mutable_failure()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >*
TxnRequest::mutable_failure() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.TxnRequest.failure)
  return _internal_mutable_failure();
}
inline const ::etcdserverpb::RequestOp& TxnRequest::_internal_failure(int index) const {
  return _internal_failure().Get(index);
}
inline const ::etcdserverpb::RequestOp& TxnRequest::failure(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnRequest.failure)
  return _internal_failure(index);
}
inline ::etcdserverpb::RequestOp* TxnRequest::_internal_add_failure() {
  return _internal_mutable_failure()->Add();
}
inline ::etcdserverpb::RequestOp* TxnRequest::add_failure() {
  ::etcdserverpb::RequestOp* _add = _internal_add_failure();
  // @@protoc_insertion_point(field_add:etcdserverpb.TxnRequest.failure)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::RequestOp >&
TxnRequest::failure() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.TxnRequest.failure)
  return _internal_failure();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>&
TxnRequest::_internal_failure() const {
  return _impl_.failure_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::RequestOp>*
TxnRequest::_internal_mutable_failure() {
  return &_impl_.failure_;
}

// -------------------------------------------------------------------

// TxnResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool TxnResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void TxnResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& TxnResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& TxnResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnResponse.header)
  return _internal_header();
}
inline void TxnResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.TxnResponse.header)
}
inline ::etcdserverpb::ResponseHeader* TxnResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* TxnResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.TxnResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* TxnResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* TxnResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.TxnResponse.header)
  return _msg;
}
inline void TxnResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.TxnResponse.header)
}

// bool succeeded = 2;
inline void TxnResponse::clear_succeeded() {
  _impl_.succeeded_ = false;
}
inline bool TxnResponse::succeeded() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnResponse.succeeded)
  return _internal_succeeded();
}
inline void TxnResponse::set_succeeded(bool value) {
  _internal_set_succeeded(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.TxnResponse.succeeded)
}
inline bool TxnResponse::_internal_succeeded() const {
  return _impl_.succeeded_;
}
inline void TxnResponse::_internal_set_succeeded(bool value) {
  ;
  _impl_.succeeded_ = value;
}

// repeated .etcdserverpb.ResponseOp responses = 3;
inline int TxnResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int TxnResponse::responses_size() const {
  return _internal_responses_size();
}
inline void TxnResponse::clear_responses() {
  _internal_mutable_responses()->Clear();
}
inline ::etcdserverpb::ResponseOp* TxnResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.TxnResponse.responses)
  return _internal_mutable_responses()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::ResponseOp >*
TxnResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.TxnResponse.responses)
  return _internal_mutable_responses();
}
inline const ::etcdserverpb::ResponseOp& TxnResponse::_internal_responses(int index) const {
  return _internal_responses().Get(index);
}
inline const ::etcdserverpb::ResponseOp& TxnResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.TxnResponse.responses)
  return _internal_responses(index);
}
inline ::etcdserverpb::ResponseOp* TxnResponse::_internal_add_responses() {
  return _internal_mutable_responses()->Add();
}
inline ::etcdserverpb::ResponseOp* TxnResponse::add_responses() {
  ::etcdserverpb::ResponseOp* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:etcdserverpb.TxnResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::ResponseOp >&
TxnResponse::responses() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.TxnResponse.responses)
  return _internal_responses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::ResponseOp>&
TxnResponse::_internal_responses() const {
  return _impl_.responses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::ResponseOp>*
TxnResponse::_internal_mutable_responses() {
  return &_impl_.responses_;
}

// -------------------------------------------------------------------

// CompactionRequest

// int64 revision = 1;
inline void CompactionRequest::clear_revision() {
  _impl_.revision_ = ::int64_t{0};
}
inline ::int64_t CompactionRequest::revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.CompactionRequest.revision)
  return _internal_revision();
}
inline void CompactionRequest::set_revision(::int64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.CompactionRequest.revision)
}
inline ::int64_t CompactionRequest::_internal_revision() const {
  return _impl_.revision_;
}
inline void CompactionRequest::_internal_set_revision(::int64_t value) {
  ;
  _impl_.revision_ = value;
}

// bool physical = 2;
inline void CompactionRequest::clear_physical() {
  _impl_.physical_ = false;
}
inline bool CompactionRequest::physical() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.CompactionRequest.physical)
  return _internal_physical();
}
inline void CompactionRequest::set_physical(bool value) {
  _internal_set_physical(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.CompactionRequest.physical)
}
inline bool CompactionRequest::_internal_physical() const {
  return _impl_.physical_;
}
inline void CompactionRequest::_internal_set_physical(bool value) {
  ;
  _impl_.physical_ = value;
}

// -------------------------------------------------------------------

// CompactionResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool CompactionResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void CompactionResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& CompactionResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& CompactionResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.CompactionResponse.header)
  return _internal_header();
}
inline void CompactionResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.CompactionResponse.header)
}
inline ::etcdserverpb::ResponseHeader* CompactionResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* CompactionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.CompactionResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* CompactionResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* CompactionResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.CompactionResponse.header)
  return _msg;
}
inline void CompactionResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.CompactionResponse.header)
}

// -------------------------------------------------------------------

// HashRequest

// -------------------------------------------------------------------

// HashKVRequest

// int64 revision = 1;
inline void HashKVRequest::clear_revision() {
  _impl_.revision_ = ::int64_t{0};
}
inline ::int64_t HashKVRequest::revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashKVRequest.revision)
  return _internal_revision();
}
inline void HashKVRequest::set_revision(::int64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.HashKVRequest.revision)
}
inline ::int64_t HashKVRequest::_internal_revision() const {
  return _impl_.revision_;
}
inline void HashKVRequest::_internal_set_revision(::int64_t value) {
  ;
  _impl_.revision_ = value;
}

// -------------------------------------------------------------------

// HashKVResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool HashKVResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void HashKVResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& HashKVResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& HashKVResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashKVResponse.header)
  return _internal_header();
}
inline void HashKVResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.HashKVResponse.header)
}
inline ::etcdserverpb::ResponseHeader* HashKVResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* HashKVResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.HashKVResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* HashKVResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* HashKVResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.HashKVResponse.header)
  return _msg;
}
inline void HashKVResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.HashKVResponse.header)
}

// uint32 hash = 2;
inline void HashKVResponse::clear_hash() {
  _impl_.hash_ = 0u;
}
inline ::uint32_t HashKVResponse::hash() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashKVResponse.hash)
  return _internal_hash();
}
inline void HashKVResponse::set_hash(::uint32_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.HashKVResponse.hash)
}
inline ::uint32_t HashKVResponse::_internal_hash() const {
  return _impl_.hash_;
}
inline void HashKVResponse::_internal_set_hash(::uint32_t value) {
  ;
  _impl_.hash_ = value;
}

// int64 compact_revision = 3;
inline void HashKVResponse::clear_compact_revision() {
  _impl_.compact_revision_ = ::int64_t{0};
}
inline ::int64_t HashKVResponse::compact_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashKVResponse.compact_revision)
  return _internal_compact_revision();
}
inline void HashKVResponse::set_compact_revision(::int64_t value) {
  _internal_set_compact_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.HashKVResponse.compact_revision)
}
inline ::int64_t HashKVResponse::_internal_compact_revision() const {
  return _impl_.compact_revision_;
}
inline void HashKVResponse::_internal_set_compact_revision(::int64_t value) {
  ;
  _impl_.compact_revision_ = value;
}

// -------------------------------------------------------------------

// HashResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool HashResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void HashResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& HashResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& HashResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashResponse.header)
  return _internal_header();
}
inline void HashResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.HashResponse.header)
}
inline ::etcdserverpb::ResponseHeader* HashResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* HashResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.HashResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* HashResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* HashResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.HashResponse.header)
  return _msg;
}
inline void HashResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.HashResponse.header)
}

// uint32 hash = 2;
inline void HashResponse::clear_hash() {
  _impl_.hash_ = 0u;
}
inline ::uint32_t HashResponse::hash() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.HashResponse.hash)
  return _internal_hash();
}
inline void HashResponse::set_hash(::uint32_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.HashResponse.hash)
}
inline ::uint32_t HashResponse::_internal_hash() const {
  return _impl_.hash_;
}
inline void HashResponse::_internal_set_hash(::uint32_t value) {
  ;
  _impl_.hash_ = value;
}

// -------------------------------------------------------------------

// SnapshotRequest

// -------------------------------------------------------------------

// SnapshotResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool SnapshotResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void SnapshotResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& SnapshotResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& SnapshotResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.SnapshotResponse.header)
  return _internal_header();
}
inline void SnapshotResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.SnapshotResponse.header)
}
inline ::etcdserverpb::ResponseHeader* SnapshotResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* SnapshotResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.SnapshotResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* SnapshotResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* SnapshotResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.SnapshotResponse.header)
  return _msg;
}
inline void SnapshotResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.SnapshotResponse.header)
}

// uint64 remaining_bytes = 2;
inline void SnapshotResponse::clear_remaining_bytes() {
  _impl_.remaining_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t SnapshotResponse::remaining_bytes() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.SnapshotResponse.remaining_bytes)
  return _internal_remaining_bytes();
}
inline void SnapshotResponse::set_remaining_bytes(::uint64_t value) {
  _internal_set_remaining_bytes(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.SnapshotResponse.remaining_bytes)
}
inline ::uint64_t SnapshotResponse::_internal_remaining_bytes() const {
  return _impl_.remaining_bytes_;
}
inline void SnapshotResponse::_internal_set_remaining_bytes(::uint64_t value) {
  ;
  _impl_.remaining_bytes_ = value;
}

// bytes blob = 3;
inline void SnapshotResponse::clear_blob() {
  _impl_.blob_.ClearToEmpty();
}
inline const std::string& SnapshotResponse::blob() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.SnapshotResponse.blob)
  return _internal_blob();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotResponse::set_blob(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.blob_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.SnapshotResponse.blob)
}
inline std::string* SnapshotResponse::mutable_blob() {
  std::string* _s = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.SnapshotResponse.blob)
  return _s;
}
inline const std::string& SnapshotResponse::_internal_blob() const {
  return _impl_.blob_.Get();
}
inline void SnapshotResponse::_internal_set_blob(const std::string& value) {
  ;


  _impl_.blob_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotResponse::_internal_mutable_blob() {
  ;
  return _impl_.blob_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotResponse::release_blob() {
  // @@protoc_insertion_point(field_release:etcdserverpb.SnapshotResponse.blob)
  return _impl_.blob_.Release();
}
inline void SnapshotResponse::set_allocated_blob(std::string* value) {
  _impl_.blob_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blob_.IsDefault()) {
          _impl_.blob_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.SnapshotResponse.blob)
}

// -------------------------------------------------------------------

// WatchRequest

// .etcdserverpb.WatchCreateRequest create_request = 1;
inline bool WatchRequest::has_create_request() const {
  return request_union_case() == kCreateRequest;
}
inline bool WatchRequest::_internal_has_create_request() const {
  return request_union_case() == kCreateRequest;
}
inline void WatchRequest::set_has_create_request() {
  _impl_._oneof_case_[0] = kCreateRequest;
}
inline void WatchRequest::clear_create_request() {
  if (request_union_case() == kCreateRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_union_.create_request_;
    }
    clear_has_request_union();
  }
}
inline ::etcdserverpb::WatchCreateRequest* WatchRequest::release_create_request() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchRequest.create_request)
  if (request_union_case() == kCreateRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchCreateRequest* temp = _impl_.request_union_.create_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_union_.create_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::WatchCreateRequest& WatchRequest::_internal_create_request() const {
  return request_union_case() == kCreateRequest
      ? *_impl_.request_union_.create_request_
      : reinterpret_cast<::etcdserverpb::WatchCreateRequest&>(::etcdserverpb::_WatchCreateRequest_default_instance_);
}
inline const ::etcdserverpb::WatchCreateRequest& WatchRequest::create_request() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchRequest.create_request)
  return _internal_create_request();
}
inline ::etcdserverpb::WatchCreateRequest* WatchRequest::unsafe_arena_release_create_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.WatchRequest.create_request)
  if (request_union_case() == kCreateRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchCreateRequest* temp = _impl_.request_union_.create_request_;
    _impl_.request_union_.create_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WatchRequest::unsafe_arena_set_allocated_create_request(::etcdserverpb::WatchCreateRequest* create_request) {
  clear_request_union();
  if (create_request) {
    set_has_create_request();
    _impl_.request_union_.create_request_ = create_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.WatchRequest.create_request)
}
inline ::etcdserverpb::WatchCreateRequest* WatchRequest::_internal_mutable_create_request() {
  if (request_union_case() != kCreateRequest) {
    clear_request_union();
    set_has_create_request();
    _impl_.request_union_.create_request_ = CreateMaybeMessage< ::etcdserverpb::WatchCreateRequest >(GetArenaForAllocation());
  }
  return _impl_.request_union_.create_request_;
}
inline ::etcdserverpb::WatchCreateRequest* WatchRequest::mutable_create_request() {
  ::etcdserverpb::WatchCreateRequest* _msg = _internal_mutable_create_request();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchRequest.create_request)
  return _msg;
}

// .etcdserverpb.WatchCancelRequest cancel_request = 2;
inline bool WatchRequest::has_cancel_request() const {
  return request_union_case() == kCancelRequest;
}
inline bool WatchRequest::_internal_has_cancel_request() const {
  return request_union_case() == kCancelRequest;
}
inline void WatchRequest::set_has_cancel_request() {
  _impl_._oneof_case_[0] = kCancelRequest;
}
inline void WatchRequest::clear_cancel_request() {
  if (request_union_case() == kCancelRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_union_.cancel_request_;
    }
    clear_has_request_union();
  }
}
inline ::etcdserverpb::WatchCancelRequest* WatchRequest::release_cancel_request() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchRequest.cancel_request)
  if (request_union_case() == kCancelRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchCancelRequest* temp = _impl_.request_union_.cancel_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_union_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::WatchCancelRequest& WatchRequest::_internal_cancel_request() const {
  return request_union_case() == kCancelRequest
      ? *_impl_.request_union_.cancel_request_
      : reinterpret_cast<::etcdserverpb::WatchCancelRequest&>(::etcdserverpb::_WatchCancelRequest_default_instance_);
}
inline const ::etcdserverpb::WatchCancelRequest& WatchRequest::cancel_request() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchRequest.cancel_request)
  return _internal_cancel_request();
}
inline ::etcdserverpb::WatchCancelRequest* WatchRequest::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.WatchRequest.cancel_request)
  if (request_union_case() == kCancelRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchCancelRequest* temp = _impl_.request_union_.cancel_request_;
    _impl_.request_union_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WatchRequest::unsafe_arena_set_allocated_cancel_request(::etcdserverpb::WatchCancelRequest* cancel_request) {
  clear_request_union();
  if (cancel_request) {
    set_has_cancel_request();
    _impl_.request_union_.cancel_request_ = cancel_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.WatchRequest.cancel_request)
}
inline ::etcdserverpb::WatchCancelRequest* WatchRequest::_internal_mutable_cancel_request() {
  if (request_union_case() != kCancelRequest) {
    clear_request_union();
    set_has_cancel_request();
    _impl_.request_union_.cancel_request_ = CreateMaybeMessage< ::etcdserverpb::WatchCancelRequest >(GetArenaForAllocation());
  }
  return _impl_.request_union_.cancel_request_;
}
inline ::etcdserverpb::WatchCancelRequest* WatchRequest::mutable_cancel_request() {
  ::etcdserverpb::WatchCancelRequest* _msg = _internal_mutable_cancel_request();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchRequest.cancel_request)
  return _msg;
}

// .etcdserverpb.WatchProgressRequest progress_request = 3;
inline bool WatchRequest::has_progress_request() const {
  return request_union_case() == kProgressRequest;
}
inline bool WatchRequest::_internal_has_progress_request() const {
  return request_union_case() == kProgressRequest;
}
inline void WatchRequest::set_has_progress_request() {
  _impl_._oneof_case_[0] = kProgressRequest;
}
inline void WatchRequest::clear_progress_request() {
  if (request_union_case() == kProgressRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_union_.progress_request_;
    }
    clear_has_request_union();
  }
}
inline ::etcdserverpb::WatchProgressRequest* WatchRequest::release_progress_request() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchRequest.progress_request)
  if (request_union_case() == kProgressRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchProgressRequest* temp = _impl_.request_union_.progress_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_union_.progress_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::etcdserverpb::WatchProgressRequest& WatchRequest::_internal_progress_request() const {
  return request_union_case() == kProgressRequest
      ? *_impl_.request_union_.progress_request_
      : reinterpret_cast<::etcdserverpb::WatchProgressRequest&>(::etcdserverpb::_WatchProgressRequest_default_instance_);
}
inline const ::etcdserverpb::WatchProgressRequest& WatchRequest::progress_request() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchRequest.progress_request)
  return _internal_progress_request();
}
inline ::etcdserverpb::WatchProgressRequest* WatchRequest::unsafe_arena_release_progress_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:etcdserverpb.WatchRequest.progress_request)
  if (request_union_case() == kProgressRequest) {
    clear_has_request_union();
    ::etcdserverpb::WatchProgressRequest* temp = _impl_.request_union_.progress_request_;
    _impl_.request_union_.progress_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WatchRequest::unsafe_arena_set_allocated_progress_request(::etcdserverpb::WatchProgressRequest* progress_request) {
  clear_request_union();
  if (progress_request) {
    set_has_progress_request();
    _impl_.request_union_.progress_request_ = progress_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.WatchRequest.progress_request)
}
inline ::etcdserverpb::WatchProgressRequest* WatchRequest::_internal_mutable_progress_request() {
  if (request_union_case() != kProgressRequest) {
    clear_request_union();
    set_has_progress_request();
    _impl_.request_union_.progress_request_ = CreateMaybeMessage< ::etcdserverpb::WatchProgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_union_.progress_request_;
}
inline ::etcdserverpb::WatchProgressRequest* WatchRequest::mutable_progress_request() {
  ::etcdserverpb::WatchProgressRequest* _msg = _internal_mutable_progress_request();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchRequest.progress_request)
  return _msg;
}

inline bool WatchRequest::has_request_union() const {
  return request_union_case() != REQUEST_UNION_NOT_SET;
}
inline void WatchRequest::clear_has_request_union() {
  _impl_._oneof_case_[0] = REQUEST_UNION_NOT_SET;
}
inline WatchRequest::RequestUnionCase WatchRequest::request_union_case() const {
  return WatchRequest::RequestUnionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WatchCreateRequest

// bytes key = 1;
inline void WatchCreateRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& WatchCreateRequest::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WatchCreateRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.key)
}
inline std::string* WatchCreateRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchCreateRequest.key)
  return _s;
}
inline const std::string& WatchCreateRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void WatchCreateRequest::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* WatchCreateRequest::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* WatchCreateRequest::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchCreateRequest.key)
  return _impl_.key_.Release();
}
inline void WatchCreateRequest::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchCreateRequest.key)
}

// bytes range_end = 2;
inline void WatchCreateRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& WatchCreateRequest::range_end() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.range_end)
  return _internal_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WatchCreateRequest::set_range_end(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.range_end_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.range_end)
}
inline std::string* WatchCreateRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchCreateRequest.range_end)
  return _s;
}
inline const std::string& WatchCreateRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void WatchCreateRequest::_internal_set_range_end(const std::string& value) {
  ;


  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* WatchCreateRequest::_internal_mutable_range_end() {
  ;
  return _impl_.range_end_.Mutable( GetArenaForAllocation());
}
inline std::string* WatchCreateRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchCreateRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void WatchCreateRequest::set_allocated_range_end(std::string* value) {
  _impl_.range_end_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_end_.IsDefault()) {
          _impl_.range_end_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchCreateRequest.range_end)
}

// int64 start_revision = 3;
inline void WatchCreateRequest::clear_start_revision() {
  _impl_.start_revision_ = ::int64_t{0};
}
inline ::int64_t WatchCreateRequest::start_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.start_revision)
  return _internal_start_revision();
}
inline void WatchCreateRequest::set_start_revision(::int64_t value) {
  _internal_set_start_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.start_revision)
}
inline ::int64_t WatchCreateRequest::_internal_start_revision() const {
  return _impl_.start_revision_;
}
inline void WatchCreateRequest::_internal_set_start_revision(::int64_t value) {
  ;
  _impl_.start_revision_ = value;
}

// bool progress_notify = 4;
inline void WatchCreateRequest::clear_progress_notify() {
  _impl_.progress_notify_ = false;
}
inline bool WatchCreateRequest::progress_notify() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.progress_notify)
  return _internal_progress_notify();
}
inline void WatchCreateRequest::set_progress_notify(bool value) {
  _internal_set_progress_notify(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.progress_notify)
}
inline bool WatchCreateRequest::_internal_progress_notify() const {
  return _impl_.progress_notify_;
}
inline void WatchCreateRequest::_internal_set_progress_notify(bool value) {
  ;
  _impl_.progress_notify_ = value;
}

// repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;
inline int WatchCreateRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int WatchCreateRequest::filters_size() const {
  return _internal_filters_size();
}
inline void WatchCreateRequest::clear_filters() {
  _internal_mutable_filters()->Clear();
}
inline ::etcdserverpb::WatchCreateRequest_FilterType WatchCreateRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.filters)
  return _internal_filters(index);
}
inline void WatchCreateRequest::set_filters(int index, ::etcdserverpb::WatchCreateRequest_FilterType value) {
  _internal_mutable_filters()->Set(index, value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.filters)
}
inline void WatchCreateRequest::add_filters(::etcdserverpb::WatchCreateRequest_FilterType value) {
  _internal_add_filters(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.WatchCreateRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& WatchCreateRequest::filters() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.WatchCreateRequest.filters)
  return _internal_filters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* WatchCreateRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.WatchCreateRequest.filters)
  return _internal_mutable_filters();
}
inline ::etcdserverpb::WatchCreateRequest_FilterType WatchCreateRequest::_internal_filters(int index) const {
  return static_cast<::etcdserverpb::WatchCreateRequest_FilterType>(_internal_filters().Get(index));
}
inline void WatchCreateRequest::_internal_add_filters(::etcdserverpb::WatchCreateRequest_FilterType value) {
  _internal_mutable_filters()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& WatchCreateRequest::_internal_filters() const {
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* WatchCreateRequest::_internal_mutable_filters() {
  return &_impl_.filters_;
}

// bool prev_kv = 6;
inline void WatchCreateRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool WatchCreateRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.prev_kv)
  return _internal_prev_kv();
}
inline void WatchCreateRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.prev_kv)
}
inline bool WatchCreateRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline void WatchCreateRequest::_internal_set_prev_kv(bool value) {
  ;
  _impl_.prev_kv_ = value;
}

// int64 watch_id = 7;
inline void WatchCreateRequest::clear_watch_id() {
  _impl_.watch_id_ = ::int64_t{0};
}
inline ::int64_t WatchCreateRequest::watch_id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.watch_id)
  return _internal_watch_id();
}
inline void WatchCreateRequest::set_watch_id(::int64_t value) {
  _internal_set_watch_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.watch_id)
}
inline ::int64_t WatchCreateRequest::_internal_watch_id() const {
  return _impl_.watch_id_;
}
inline void WatchCreateRequest::_internal_set_watch_id(::int64_t value) {
  ;
  _impl_.watch_id_ = value;
}

// bool fragment = 8;
inline void WatchCreateRequest::clear_fragment() {
  _impl_.fragment_ = false;
}
inline bool WatchCreateRequest::fragment() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCreateRequest.fragment)
  return _internal_fragment();
}
inline void WatchCreateRequest::set_fragment(bool value) {
  _internal_set_fragment(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCreateRequest.fragment)
}
inline bool WatchCreateRequest::_internal_fragment() const {
  return _impl_.fragment_;
}
inline void WatchCreateRequest::_internal_set_fragment(bool value) {
  ;
  _impl_.fragment_ = value;
}

// -------------------------------------------------------------------

// WatchCancelRequest

// int64 watch_id = 1;
inline void WatchCancelRequest::clear_watch_id() {
  _impl_.watch_id_ = ::int64_t{0};
}
inline ::int64_t WatchCancelRequest::watch_id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchCancelRequest.watch_id)
  return _internal_watch_id();
}
inline void WatchCancelRequest::set_watch_id(::int64_t value) {
  _internal_set_watch_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchCancelRequest.watch_id)
}
inline ::int64_t WatchCancelRequest::_internal_watch_id() const {
  return _impl_.watch_id_;
}
inline void WatchCancelRequest::_internal_set_watch_id(::int64_t value) {
  ;
  _impl_.watch_id_ = value;
}

// -------------------------------------------------------------------

// WatchProgressRequest

// -------------------------------------------------------------------

// WatchResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool WatchResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void WatchResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& WatchResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& WatchResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.header)
  return _internal_header();
}
inline void WatchResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.WatchResponse.header)
}
inline ::etcdserverpb::ResponseHeader* WatchResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* WatchResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* WatchResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* WatchResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchResponse.header)
  return _msg;
}
inline void WatchResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchResponse.header)
}

// int64 watch_id = 2;
inline void WatchResponse::clear_watch_id() {
  _impl_.watch_id_ = ::int64_t{0};
}
inline ::int64_t WatchResponse::watch_id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.watch_id)
  return _internal_watch_id();
}
inline void WatchResponse::set_watch_id(::int64_t value) {
  _internal_set_watch_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.watch_id)
}
inline ::int64_t WatchResponse::_internal_watch_id() const {
  return _impl_.watch_id_;
}
inline void WatchResponse::_internal_set_watch_id(::int64_t value) {
  ;
  _impl_.watch_id_ = value;
}

// bool created = 3;
inline void WatchResponse::clear_created() {
  _impl_.created_ = false;
}
inline bool WatchResponse::created() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.created)
  return _internal_created();
}
inline void WatchResponse::set_created(bool value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.created)
}
inline bool WatchResponse::_internal_created() const {
  return _impl_.created_;
}
inline void WatchResponse::_internal_set_created(bool value) {
  ;
  _impl_.created_ = value;
}

// bool canceled = 4;
inline void WatchResponse::clear_canceled() {
  _impl_.canceled_ = false;
}
inline bool WatchResponse::canceled() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.canceled)
  return _internal_canceled();
}
inline void WatchResponse::set_canceled(bool value) {
  _internal_set_canceled(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.canceled)
}
inline bool WatchResponse::_internal_canceled() const {
  return _impl_.canceled_;
}
inline void WatchResponse::_internal_set_canceled(bool value) {
  ;
  _impl_.canceled_ = value;
}

// int64 compact_revision = 5;
inline void WatchResponse::clear_compact_revision() {
  _impl_.compact_revision_ = ::int64_t{0};
}
inline ::int64_t WatchResponse::compact_revision() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.compact_revision)
  return _internal_compact_revision();
}
inline void WatchResponse::set_compact_revision(::int64_t value) {
  _internal_set_compact_revision(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.compact_revision)
}
inline ::int64_t WatchResponse::_internal_compact_revision() const {
  return _impl_.compact_revision_;
}
inline void WatchResponse::_internal_set_compact_revision(::int64_t value) {
  ;
  _impl_.compact_revision_ = value;
}

// string cancel_reason = 6;
inline void WatchResponse::clear_cancel_reason() {
  _impl_.cancel_reason_.ClearToEmpty();
}
inline const std::string& WatchResponse::cancel_reason() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.cancel_reason)
  return _internal_cancel_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WatchResponse::set_cancel_reason(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cancel_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.cancel_reason)
}
inline std::string* WatchResponse::mutable_cancel_reason() {
  std::string* _s = _internal_mutable_cancel_reason();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchResponse.cancel_reason)
  return _s;
}
inline const std::string& WatchResponse::_internal_cancel_reason() const {
  return _impl_.cancel_reason_.Get();
}
inline void WatchResponse::_internal_set_cancel_reason(const std::string& value) {
  ;


  _impl_.cancel_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* WatchResponse::_internal_mutable_cancel_reason() {
  ;
  return _impl_.cancel_reason_.Mutable( GetArenaForAllocation());
}
inline std::string* WatchResponse::release_cancel_reason() {
  // @@protoc_insertion_point(field_release:etcdserverpb.WatchResponse.cancel_reason)
  return _impl_.cancel_reason_.Release();
}
inline void WatchResponse::set_allocated_cancel_reason(std::string* value) {
  _impl_.cancel_reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cancel_reason_.IsDefault()) {
          _impl_.cancel_reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchResponse.cancel_reason)
}

// bool fragment = 7;
inline void WatchResponse::clear_fragment() {
  _impl_.fragment_ = false;
}
inline bool WatchResponse::fragment() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.fragment)
  return _internal_fragment();
}
inline void WatchResponse::set_fragment(bool value) {
  _internal_set_fragment(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.WatchResponse.fragment)
}
inline bool WatchResponse::_internal_fragment() const {
  return _impl_.fragment_;
}
inline void WatchResponse::_internal_set_fragment(bool value) {
  ;
  _impl_.fragment_ = value;
}

// repeated .mvccpb.Event events = 11;
inline int WatchResponse::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int WatchResponse::events_size() const {
  return _internal_events_size();
}
inline ::mvccpb::Event* WatchResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.WatchResponse.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::Event >*
WatchResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.WatchResponse.events)
  return _internal_mutable_events();
}
inline const ::mvccpb::Event& WatchResponse::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::mvccpb::Event& WatchResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.WatchResponse.events)
  return _internal_events(index);
}
inline ::mvccpb::Event* WatchResponse::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::mvccpb::Event* WatchResponse::add_events() {
  ::mvccpb::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:etcdserverpb.WatchResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mvccpb::Event >&
WatchResponse::events() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.WatchResponse.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::Event>&
WatchResponse::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mvccpb::Event>*
WatchResponse::_internal_mutable_events() {
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// LeaseGrantRequest

// int64 TTL = 1;
inline void LeaseGrantRequest::clear_ttl() {
  _impl_.ttl_ = ::int64_t{0};
}
inline ::int64_t LeaseGrantRequest::ttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantRequest.TTL)
  return _internal_ttl();
}
inline void LeaseGrantRequest::set_ttl(::int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseGrantRequest.TTL)
}
inline ::int64_t LeaseGrantRequest::_internal_ttl() const {
  return _impl_.ttl_;
}
inline void LeaseGrantRequest::_internal_set_ttl(::int64_t value) {
  ;
  _impl_.ttl_ = value;
}

// int64 ID = 2;
inline void LeaseGrantRequest::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseGrantRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantRequest.ID)
  return _internal_id();
}
inline void LeaseGrantRequest::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseGrantRequest.ID)
}
inline ::int64_t LeaseGrantRequest::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseGrantRequest::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// LeaseGrantResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseGrantResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseGrantResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseGrantResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseGrantResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantResponse.header)
  return _internal_header();
}
inline void LeaseGrantResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseGrantResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseGrantResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseGrantResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseGrantResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseGrantResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseGrantResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseGrantResponse.header)
  return _msg;
}
inline void LeaseGrantResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseGrantResponse.header)
}

// int64 ID = 2;
inline void LeaseGrantResponse::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseGrantResponse::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantResponse.ID)
  return _internal_id();
}
inline void LeaseGrantResponse::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseGrantResponse.ID)
}
inline ::int64_t LeaseGrantResponse::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseGrantResponse::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// int64 TTL = 3;
inline void LeaseGrantResponse::clear_ttl() {
  _impl_.ttl_ = ::int64_t{0};
}
inline ::int64_t LeaseGrantResponse::ttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantResponse.TTL)
  return _internal_ttl();
}
inline void LeaseGrantResponse::set_ttl(::int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseGrantResponse.TTL)
}
inline ::int64_t LeaseGrantResponse::_internal_ttl() const {
  return _impl_.ttl_;
}
inline void LeaseGrantResponse::_internal_set_ttl(::int64_t value) {
  ;
  _impl_.ttl_ = value;
}

// string error = 4;
inline void LeaseGrantResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& LeaseGrantResponse::error() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseGrantResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LeaseGrantResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseGrantResponse.error)
}
inline std::string* LeaseGrantResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseGrantResponse.error)
  return _s;
}
inline const std::string& LeaseGrantResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void LeaseGrantResponse::_internal_set_error(const std::string& value) {
  ;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaseGrantResponse::_internal_mutable_error() {
  ;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* LeaseGrantResponse::release_error() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseGrantResponse.error)
  return _impl_.error_.Release();
}
inline void LeaseGrantResponse::set_allocated_error(std::string* value) {
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseGrantResponse.error)
}

// -------------------------------------------------------------------

// LeaseRevokeRequest

// int64 ID = 1;
inline void LeaseRevokeRequest::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseRevokeRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseRevokeRequest.ID)
  return _internal_id();
}
inline void LeaseRevokeRequest::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseRevokeRequest.ID)
}
inline ::int64_t LeaseRevokeRequest::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseRevokeRequest::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// LeaseRevokeResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseRevokeResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseRevokeResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseRevokeResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseRevokeResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseRevokeResponse.header)
  return _internal_header();
}
inline void LeaseRevokeResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseRevokeResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseRevokeResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseRevokeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseRevokeResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseRevokeResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseRevokeResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseRevokeResponse.header)
  return _msg;
}
inline void LeaseRevokeResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseRevokeResponse.header)
}

// -------------------------------------------------------------------

// LeaseCheckpoint

// int64 ID = 1;
inline void LeaseCheckpoint::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseCheckpoint::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseCheckpoint.ID)
  return _internal_id();
}
inline void LeaseCheckpoint::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseCheckpoint.ID)
}
inline ::int64_t LeaseCheckpoint::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseCheckpoint::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// int64 remaining_TTL = 2;
inline void LeaseCheckpoint::clear_remaining_ttl() {
  _impl_.remaining_ttl_ = ::int64_t{0};
}
inline ::int64_t LeaseCheckpoint::remaining_ttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseCheckpoint.remaining_TTL)
  return _internal_remaining_ttl();
}
inline void LeaseCheckpoint::set_remaining_ttl(::int64_t value) {
  _internal_set_remaining_ttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseCheckpoint.remaining_TTL)
}
inline ::int64_t LeaseCheckpoint::_internal_remaining_ttl() const {
  return _impl_.remaining_ttl_;
}
inline void LeaseCheckpoint::_internal_set_remaining_ttl(::int64_t value) {
  ;
  _impl_.remaining_ttl_ = value;
}

// -------------------------------------------------------------------

// LeaseCheckpointRequest

// repeated .etcdserverpb.LeaseCheckpoint checkpoints = 1;
inline int LeaseCheckpointRequest::_internal_checkpoints_size() const {
  return _impl_.checkpoints_.size();
}
inline int LeaseCheckpointRequest::checkpoints_size() const {
  return _internal_checkpoints_size();
}
inline void LeaseCheckpointRequest::clear_checkpoints() {
  _internal_mutable_checkpoints()->Clear();
}
inline ::etcdserverpb::LeaseCheckpoint* LeaseCheckpointRequest::mutable_checkpoints(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseCheckpointRequest.checkpoints)
  return _internal_mutable_checkpoints()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseCheckpoint >*
LeaseCheckpointRequest::mutable_checkpoints() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.LeaseCheckpointRequest.checkpoints)
  return _internal_mutable_checkpoints();
}
inline const ::etcdserverpb::LeaseCheckpoint& LeaseCheckpointRequest::_internal_checkpoints(int index) const {
  return _internal_checkpoints().Get(index);
}
inline const ::etcdserverpb::LeaseCheckpoint& LeaseCheckpointRequest::checkpoints(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseCheckpointRequest.checkpoints)
  return _internal_checkpoints(index);
}
inline ::etcdserverpb::LeaseCheckpoint* LeaseCheckpointRequest::_internal_add_checkpoints() {
  return _internal_mutable_checkpoints()->Add();
}
inline ::etcdserverpb::LeaseCheckpoint* LeaseCheckpointRequest::add_checkpoints() {
  ::etcdserverpb::LeaseCheckpoint* _add = _internal_add_checkpoints();
  // @@protoc_insertion_point(field_add:etcdserverpb.LeaseCheckpointRequest.checkpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseCheckpoint >&
LeaseCheckpointRequest::checkpoints() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.LeaseCheckpointRequest.checkpoints)
  return _internal_checkpoints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseCheckpoint>&
LeaseCheckpointRequest::_internal_checkpoints() const {
  return _impl_.checkpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseCheckpoint>*
LeaseCheckpointRequest::_internal_mutable_checkpoints() {
  return &_impl_.checkpoints_;
}

// -------------------------------------------------------------------

// LeaseCheckpointResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseCheckpointResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseCheckpointResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseCheckpointResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseCheckpointResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseCheckpointResponse.header)
  return _internal_header();
}
inline void LeaseCheckpointResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseCheckpointResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseCheckpointResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseCheckpointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseCheckpointResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseCheckpointResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseCheckpointResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseCheckpointResponse.header)
  return _msg;
}
inline void LeaseCheckpointResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseCheckpointResponse.header)
}

// -------------------------------------------------------------------

// LeaseKeepAliveRequest

// int64 ID = 1;
inline void LeaseKeepAliveRequest::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseKeepAliveRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseKeepAliveRequest.ID)
  return _internal_id();
}
inline void LeaseKeepAliveRequest::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseKeepAliveRequest.ID)
}
inline ::int64_t LeaseKeepAliveRequest::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseKeepAliveRequest::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// LeaseKeepAliveResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseKeepAliveResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseKeepAliveResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseKeepAliveResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseKeepAliveResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseKeepAliveResponse.header)
  return _internal_header();
}
inline void LeaseKeepAliveResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseKeepAliveResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseKeepAliveResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseKeepAliveResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseKeepAliveResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseKeepAliveResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseKeepAliveResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseKeepAliveResponse.header)
  return _msg;
}
inline void LeaseKeepAliveResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseKeepAliveResponse.header)
}

// int64 ID = 2;
inline void LeaseKeepAliveResponse::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseKeepAliveResponse::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseKeepAliveResponse.ID)
  return _internal_id();
}
inline void LeaseKeepAliveResponse::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseKeepAliveResponse.ID)
}
inline ::int64_t LeaseKeepAliveResponse::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseKeepAliveResponse::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// int64 TTL = 3;
inline void LeaseKeepAliveResponse::clear_ttl() {
  _impl_.ttl_ = ::int64_t{0};
}
inline ::int64_t LeaseKeepAliveResponse::ttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseKeepAliveResponse.TTL)
  return _internal_ttl();
}
inline void LeaseKeepAliveResponse::set_ttl(::int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseKeepAliveResponse.TTL)
}
inline ::int64_t LeaseKeepAliveResponse::_internal_ttl() const {
  return _impl_.ttl_;
}
inline void LeaseKeepAliveResponse::_internal_set_ttl(::int64_t value) {
  ;
  _impl_.ttl_ = value;
}

// -------------------------------------------------------------------

// LeaseTimeToLiveRequest

// int64 ID = 1;
inline void LeaseTimeToLiveRequest::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseTimeToLiveRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveRequest.ID)
  return _internal_id();
}
inline void LeaseTimeToLiveRequest::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveRequest.ID)
}
inline ::int64_t LeaseTimeToLiveRequest::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseTimeToLiveRequest::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// bool keys = 2;
inline void LeaseTimeToLiveRequest::clear_keys() {
  _impl_.keys_ = false;
}
inline bool LeaseTimeToLiveRequest::keys() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveRequest.keys)
  return _internal_keys();
}
inline void LeaseTimeToLiveRequest::set_keys(bool value) {
  _internal_set_keys(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveRequest.keys)
}
inline bool LeaseTimeToLiveRequest::_internal_keys() const {
  return _impl_.keys_;
}
inline void LeaseTimeToLiveRequest::_internal_set_keys(bool value) {
  ;
  _impl_.keys_ = value;
}

// -------------------------------------------------------------------

// LeaseTimeToLiveResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseTimeToLiveResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseTimeToLiveResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseTimeToLiveResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseTimeToLiveResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveResponse.header)
  return _internal_header();
}
inline void LeaseTimeToLiveResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseTimeToLiveResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseTimeToLiveResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseTimeToLiveResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseTimeToLiveResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseTimeToLiveResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseTimeToLiveResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseTimeToLiveResponse.header)
  return _msg;
}
inline void LeaseTimeToLiveResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseTimeToLiveResponse.header)
}

// int64 ID = 2;
inline void LeaseTimeToLiveResponse::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseTimeToLiveResponse::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveResponse.ID)
  return _internal_id();
}
inline void LeaseTimeToLiveResponse::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveResponse.ID)
}
inline ::int64_t LeaseTimeToLiveResponse::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseTimeToLiveResponse::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// int64 TTL = 3;
inline void LeaseTimeToLiveResponse::clear_ttl() {
  _impl_.ttl_ = ::int64_t{0};
}
inline ::int64_t LeaseTimeToLiveResponse::ttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveResponse.TTL)
  return _internal_ttl();
}
inline void LeaseTimeToLiveResponse::set_ttl(::int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveResponse.TTL)
}
inline ::int64_t LeaseTimeToLiveResponse::_internal_ttl() const {
  return _impl_.ttl_;
}
inline void LeaseTimeToLiveResponse::_internal_set_ttl(::int64_t value) {
  ;
  _impl_.ttl_ = value;
}

// int64 grantedTTL = 4;
inline void LeaseTimeToLiveResponse::clear_grantedttl() {
  _impl_.grantedttl_ = ::int64_t{0};
}
inline ::int64_t LeaseTimeToLiveResponse::grantedttl() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveResponse.grantedTTL)
  return _internal_grantedttl();
}
inline void LeaseTimeToLiveResponse::set_grantedttl(::int64_t value) {
  _internal_set_grantedttl(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveResponse.grantedTTL)
}
inline ::int64_t LeaseTimeToLiveResponse::_internal_grantedttl() const {
  return _impl_.grantedttl_;
}
inline void LeaseTimeToLiveResponse::_internal_set_grantedttl(::int64_t value) {
  ;
  _impl_.grantedttl_ = value;
}

// repeated bytes keys = 5;
inline int LeaseTimeToLiveResponse::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int LeaseTimeToLiveResponse::keys_size() const {
  return _internal_keys_size();
}
inline void LeaseTimeToLiveResponse::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline std::string* LeaseTimeToLiveResponse::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.LeaseTimeToLiveResponse.keys)
  return _s;
}
inline const std::string& LeaseTimeToLiveResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseTimeToLiveResponse.keys)
  return _internal_keys(index);
}
inline std::string* LeaseTimeToLiveResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseTimeToLiveResponse.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline void LeaseTimeToLiveResponse::set_keys(int index, const std::string& value) {
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::set_keys(int index, std::string&& value) {
  _internal_mutable_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::set_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::set_keys(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::set_keys(int index, absl::string_view value) {
  _internal_mutable_keys()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::add_keys(const std::string& value) {
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::add_keys(std::string&& value) {
  _internal_mutable_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::add_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::add_keys(const void* value, std::size_t size) {
  _internal_mutable_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline void LeaseTimeToLiveResponse::add_keys(absl::string_view value) {
  _internal_mutable_keys()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.LeaseTimeToLiveResponse.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeaseTimeToLiveResponse::keys() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.LeaseTimeToLiveResponse.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* LeaseTimeToLiveResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.LeaseTimeToLiveResponse.keys)
  return _internal_mutable_keys();
}
inline const std::string& LeaseTimeToLiveResponse::_internal_keys(int index) const {
  return _internal_keys().Get(index);
}
inline std::string* LeaseTimeToLiveResponse::_internal_add_keys() {
  return _internal_mutable_keys()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeaseTimeToLiveResponse::_internal_keys() const {
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LeaseTimeToLiveResponse::_internal_mutable_keys() {
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// LeaseLeasesRequest

// -------------------------------------------------------------------

// LeaseStatus

// int64 ID = 1;
inline void LeaseStatus::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t LeaseStatus::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseStatus.ID)
  return _internal_id();
}
inline void LeaseStatus::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.LeaseStatus.ID)
}
inline ::int64_t LeaseStatus::_internal_id() const {
  return _impl_.id_;
}
inline void LeaseStatus::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// LeaseLeasesResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool LeaseLeasesResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LeaseLeasesResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& LeaseLeasesResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& LeaseLeasesResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseLeasesResponse.header)
  return _internal_header();
}
inline void LeaseLeasesResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.LeaseLeasesResponse.header)
}
inline ::etcdserverpb::ResponseHeader* LeaseLeasesResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseLeasesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.LeaseLeasesResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* LeaseLeasesResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* LeaseLeasesResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseLeasesResponse.header)
  return _msg;
}
inline void LeaseLeasesResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.LeaseLeasesResponse.header)
}

// repeated .etcdserverpb.LeaseStatus leases = 2;
inline int LeaseLeasesResponse::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int LeaseLeasesResponse::leases_size() const {
  return _internal_leases_size();
}
inline void LeaseLeasesResponse::clear_leases() {
  _internal_mutable_leases()->Clear();
}
inline ::etcdserverpb::LeaseStatus* LeaseLeasesResponse::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.LeaseLeasesResponse.leases)
  return _internal_mutable_leases()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseStatus >*
LeaseLeasesResponse::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.LeaseLeasesResponse.leases)
  return _internal_mutable_leases();
}
inline const ::etcdserverpb::LeaseStatus& LeaseLeasesResponse::_internal_leases(int index) const {
  return _internal_leases().Get(index);
}
inline const ::etcdserverpb::LeaseStatus& LeaseLeasesResponse::leases(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.LeaseLeasesResponse.leases)
  return _internal_leases(index);
}
inline ::etcdserverpb::LeaseStatus* LeaseLeasesResponse::_internal_add_leases() {
  return _internal_mutable_leases()->Add();
}
inline ::etcdserverpb::LeaseStatus* LeaseLeasesResponse::add_leases() {
  ::etcdserverpb::LeaseStatus* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:etcdserverpb.LeaseLeasesResponse.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::LeaseStatus >&
LeaseLeasesResponse::leases() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.LeaseLeasesResponse.leases)
  return _internal_leases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseStatus>&
LeaseLeasesResponse::_internal_leases() const {
  return _impl_.leases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::LeaseStatus>*
LeaseLeasesResponse::_internal_mutable_leases() {
  return &_impl_.leases_;
}

// -------------------------------------------------------------------

// Member

// uint64 ID = 1;
inline void Member::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Member::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Member.ID)
  return _internal_id();
}
inline void Member::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.ID)
}
inline ::uint64_t Member::_internal_id() const {
  return _impl_.id_;
}
inline void Member::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void Member::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Member::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Member.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Member::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.name)
}
inline std::string* Member::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Member.name)
  return _s;
}
inline const std::string& Member::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Member::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Member::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Member::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.Member.name)
  return _impl_.name_.Release();
}
inline void Member::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.Member.name)
}

// repeated string peerURLs = 3;
inline int Member::_internal_peerurls_size() const {
  return _impl_.peerurls_.size();
}
inline int Member::peerurls_size() const {
  return _internal_peerurls_size();
}
inline void Member::clear_peerurls() {
  _internal_mutable_peerurls()->Clear();
}
inline std::string* Member::add_peerurls() {
  std::string* _s = _internal_add_peerurls();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.Member.peerURLs)
  return _s;
}
inline const std::string& Member::peerurls(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Member.peerURLs)
  return _internal_peerurls(index);
}
inline std::string* Member::mutable_peerurls(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Member.peerURLs)
  return _internal_mutable_peerurls()->Mutable(index);
}
inline void Member::set_peerurls(int index, const std::string& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.peerURLs)
}
inline void Member::set_peerurls(int index, std::string&& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.peerURLs)
}
inline void Member::set_peerurls(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.Member.peerURLs)
}
inline void Member::set_peerurls(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_peerurls()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.Member.peerURLs)
}
inline void Member::set_peerurls(int index, absl::string_view value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.Member.peerURLs)
}
inline void Member::add_peerurls(const std::string& value) {
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.Member.peerURLs)
}
inline void Member::add_peerurls(std::string&& value) {
  _internal_mutable_peerurls()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.Member.peerURLs)
}
inline void Member::add_peerurls(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.Member.peerURLs)
}
inline void Member::add_peerurls(const char* value, std::size_t size) {
  _internal_mutable_peerurls()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.Member.peerURLs)
}
inline void Member::add_peerurls(absl::string_view value) {
  _internal_mutable_peerurls()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.Member.peerURLs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::peerurls() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.Member.peerURLs)
  return _internal_peerurls();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Member::mutable_peerurls() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.Member.peerURLs)
  return _internal_mutable_peerurls();
}
inline const std::string& Member::_internal_peerurls(int index) const {
  return _internal_peerurls().Get(index);
}
inline std::string* Member::_internal_add_peerurls() {
  return _internal_mutable_peerurls()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::_internal_peerurls() const {
  return _impl_.peerurls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Member::_internal_mutable_peerurls() {
  return &_impl_.peerurls_;
}

// repeated string clientURLs = 4;
inline int Member::_internal_clienturls_size() const {
  return _impl_.clienturls_.size();
}
inline int Member::clienturls_size() const {
  return _internal_clienturls_size();
}
inline void Member::clear_clienturls() {
  _internal_mutable_clienturls()->Clear();
}
inline std::string* Member::add_clienturls() {
  std::string* _s = _internal_add_clienturls();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.Member.clientURLs)
  return _s;
}
inline const std::string& Member::clienturls(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Member.clientURLs)
  return _internal_clienturls(index);
}
inline std::string* Member::mutable_clienturls(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.Member.clientURLs)
  return _internal_mutable_clienturls()->Mutable(index);
}
inline void Member::set_clienturls(int index, const std::string& value) {
  _internal_mutable_clienturls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.clientURLs)
}
inline void Member::set_clienturls(int index, std::string&& value) {
  _internal_mutable_clienturls()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.clientURLs)
}
inline void Member::set_clienturls(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_clienturls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.Member.clientURLs)
}
inline void Member::set_clienturls(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_clienturls()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.Member.clientURLs)
}
inline void Member::set_clienturls(int index, absl::string_view value) {
  _internal_mutable_clienturls()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.Member.clientURLs)
}
inline void Member::add_clienturls(const std::string& value) {
  _internal_mutable_clienturls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.Member.clientURLs)
}
inline void Member::add_clienturls(std::string&& value) {
  _internal_mutable_clienturls()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.Member.clientURLs)
}
inline void Member::add_clienturls(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_clienturls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.Member.clientURLs)
}
inline void Member::add_clienturls(const char* value, std::size_t size) {
  _internal_mutable_clienturls()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.Member.clientURLs)
}
inline void Member::add_clienturls(absl::string_view value) {
  _internal_mutable_clienturls()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.Member.clientURLs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::clienturls() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.Member.clientURLs)
  return _internal_clienturls();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Member::mutable_clienturls() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.Member.clientURLs)
  return _internal_mutable_clienturls();
}
inline const std::string& Member::_internal_clienturls(int index) const {
  return _internal_clienturls().Get(index);
}
inline std::string* Member::_internal_add_clienturls() {
  return _internal_mutable_clienturls()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::_internal_clienturls() const {
  return _impl_.clienturls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Member::_internal_mutable_clienturls() {
  return &_impl_.clienturls_;
}

// bool isLearner = 5;
inline void Member::clear_islearner() {
  _impl_.islearner_ = false;
}
inline bool Member::islearner() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.Member.isLearner)
  return _internal_islearner();
}
inline void Member::set_islearner(bool value) {
  _internal_set_islearner(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.Member.isLearner)
}
inline bool Member::_internal_islearner() const {
  return _impl_.islearner_;
}
inline void Member::_internal_set_islearner(bool value) {
  ;
  _impl_.islearner_ = value;
}

// -------------------------------------------------------------------

// MemberAddRequest

// repeated string peerURLs = 1;
inline int MemberAddRequest::_internal_peerurls_size() const {
  return _impl_.peerurls_.size();
}
inline int MemberAddRequest::peerurls_size() const {
  return _internal_peerurls_size();
}
inline void MemberAddRequest::clear_peerurls() {
  _internal_mutable_peerurls()->Clear();
}
inline std::string* MemberAddRequest::add_peerurls() {
  std::string* _s = _internal_add_peerurls();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.MemberAddRequest.peerURLs)
  return _s;
}
inline const std::string& MemberAddRequest::peerurls(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberAddRequest.peerURLs)
  return _internal_peerurls(index);
}
inline std::string* MemberAddRequest::mutable_peerurls(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberAddRequest.peerURLs)
  return _internal_mutable_peerurls()->Mutable(index);
}
inline void MemberAddRequest::set_peerurls(int index, const std::string& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::set_peerurls(int index, std::string&& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::set_peerurls(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::set_peerurls(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_peerurls()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::set_peerurls(int index, absl::string_view value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::add_peerurls(const std::string& value) {
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::add_peerurls(std::string&& value) {
  _internal_mutable_peerurls()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::add_peerurls(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::add_peerurls(const char* value, std::size_t size) {
  _internal_mutable_peerurls()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.MemberAddRequest.peerURLs)
}
inline void MemberAddRequest::add_peerurls(absl::string_view value) {
  _internal_mutable_peerurls()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.MemberAddRequest.peerURLs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MemberAddRequest::peerurls() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberAddRequest.peerURLs)
  return _internal_peerurls();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MemberAddRequest::mutable_peerurls() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberAddRequest.peerURLs)
  return _internal_mutable_peerurls();
}
inline const std::string& MemberAddRequest::_internal_peerurls(int index) const {
  return _internal_peerurls().Get(index);
}
inline std::string* MemberAddRequest::_internal_add_peerurls() {
  return _internal_mutable_peerurls()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MemberAddRequest::_internal_peerurls() const {
  return _impl_.peerurls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MemberAddRequest::_internal_mutable_peerurls() {
  return &_impl_.peerurls_;
}

// bool isLearner = 2;
inline void MemberAddRequest::clear_islearner() {
  _impl_.islearner_ = false;
}
inline bool MemberAddRequest::islearner() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberAddRequest.isLearner)
  return _internal_islearner();
}
inline void MemberAddRequest::set_islearner(bool value) {
  _internal_set_islearner(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberAddRequest.isLearner)
}
inline bool MemberAddRequest::_internal_islearner() const {
  return _impl_.islearner_;
}
inline void MemberAddRequest::_internal_set_islearner(bool value) {
  ;
  _impl_.islearner_ = value;
}

// -------------------------------------------------------------------

// MemberAddResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MemberAddResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MemberAddResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MemberAddResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MemberAddResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberAddResponse.header)
  return _internal_header();
}
inline void MemberAddResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberAddResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MemberAddResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberAddResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberAddResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberAddResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MemberAddResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberAddResponse.header)
  return _msg;
}
inline void MemberAddResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberAddResponse.header)
}

// .etcdserverpb.Member member = 2;
inline bool MemberAddResponse::has_member() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.member_ != nullptr);
  return value;
}
inline void MemberAddResponse::clear_member() {
  if (_impl_.member_ != nullptr) _impl_.member_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::etcdserverpb::Member& MemberAddResponse::_internal_member() const {
  const ::etcdserverpb::Member* p = _impl_.member_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::Member&>(
      ::etcdserverpb::_Member_default_instance_);
}
inline const ::etcdserverpb::Member& MemberAddResponse::member() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberAddResponse.member)
  return _internal_member();
}
inline void MemberAddResponse::unsafe_arena_set_allocated_member(
    ::etcdserverpb::Member* member) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.member_);
  }
  _impl_.member_ = member;
  if (member) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberAddResponse.member)
}
inline ::etcdserverpb::Member* MemberAddResponse::release_member() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::etcdserverpb::Member* temp = _impl_.member_;
  _impl_.member_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::Member* MemberAddResponse::unsafe_arena_release_member() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberAddResponse.member)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::etcdserverpb::Member* temp = _impl_.member_;
  _impl_.member_ = nullptr;
  return temp;
}
inline ::etcdserverpb::Member* MemberAddResponse::_internal_mutable_member() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.member_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::Member>(GetArenaForAllocation());
    _impl_.member_ = p;
  }
  return _impl_.member_;
}
inline ::etcdserverpb::Member* MemberAddResponse::mutable_member() {
  ::etcdserverpb::Member* _msg = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberAddResponse.member)
  return _msg;
}
inline void MemberAddResponse::set_allocated_member(::etcdserverpb::Member* member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.member_;
  }
  if (member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(member);
    if (message_arena != submessage_arena) {
      member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, member, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.member_ = member;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberAddResponse.member)
}

// repeated .etcdserverpb.Member members = 3;
inline int MemberAddResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int MemberAddResponse::members_size() const {
  return _internal_members_size();
}
inline void MemberAddResponse::clear_members() {
  _internal_mutable_members()->Clear();
}
inline ::etcdserverpb::Member* MemberAddResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberAddResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
MemberAddResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberAddResponse.members)
  return _internal_mutable_members();
}
inline const ::etcdserverpb::Member& MemberAddResponse::_internal_members(int index) const {
  return _internal_members().Get(index);
}
inline const ::etcdserverpb::Member& MemberAddResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberAddResponse.members)
  return _internal_members(index);
}
inline ::etcdserverpb::Member* MemberAddResponse::_internal_add_members() {
  return _internal_mutable_members()->Add();
}
inline ::etcdserverpb::Member* MemberAddResponse::add_members() {
  ::etcdserverpb::Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberAddResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
MemberAddResponse::members() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberAddResponse.members)
  return _internal_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>&
MemberAddResponse::_internal_members() const {
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>*
MemberAddResponse::_internal_mutable_members() {
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// MemberRemoveRequest

// uint64 ID = 1;
inline void MemberRemoveRequest::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MemberRemoveRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberRemoveRequest.ID)
  return _internal_id();
}
inline void MemberRemoveRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberRemoveRequest.ID)
}
inline ::uint64_t MemberRemoveRequest::_internal_id() const {
  return _impl_.id_;
}
inline void MemberRemoveRequest::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// MemberRemoveResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MemberRemoveResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MemberRemoveResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MemberRemoveResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MemberRemoveResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberRemoveResponse.header)
  return _internal_header();
}
inline void MemberRemoveResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberRemoveResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MemberRemoveResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberRemoveResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberRemoveResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberRemoveResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MemberRemoveResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberRemoveResponse.header)
  return _msg;
}
inline void MemberRemoveResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberRemoveResponse.header)
}

// repeated .etcdserverpb.Member members = 2;
inline int MemberRemoveResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int MemberRemoveResponse::members_size() const {
  return _internal_members_size();
}
inline void MemberRemoveResponse::clear_members() {
  _internal_mutable_members()->Clear();
}
inline ::etcdserverpb::Member* MemberRemoveResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberRemoveResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
MemberRemoveResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberRemoveResponse.members)
  return _internal_mutable_members();
}
inline const ::etcdserverpb::Member& MemberRemoveResponse::_internal_members(int index) const {
  return _internal_members().Get(index);
}
inline const ::etcdserverpb::Member& MemberRemoveResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberRemoveResponse.members)
  return _internal_members(index);
}
inline ::etcdserverpb::Member* MemberRemoveResponse::_internal_add_members() {
  return _internal_mutable_members()->Add();
}
inline ::etcdserverpb::Member* MemberRemoveResponse::add_members() {
  ::etcdserverpb::Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberRemoveResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
MemberRemoveResponse::members() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberRemoveResponse.members)
  return _internal_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>&
MemberRemoveResponse::_internal_members() const {
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>*
MemberRemoveResponse::_internal_mutable_members() {
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// MemberUpdateRequest

// uint64 ID = 1;
inline void MemberUpdateRequest::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MemberUpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberUpdateRequest.ID)
  return _internal_id();
}
inline void MemberUpdateRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberUpdateRequest.ID)
}
inline ::uint64_t MemberUpdateRequest::_internal_id() const {
  return _impl_.id_;
}
inline void MemberUpdateRequest::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// repeated string peerURLs = 2;
inline int MemberUpdateRequest::_internal_peerurls_size() const {
  return _impl_.peerurls_.size();
}
inline int MemberUpdateRequest::peerurls_size() const {
  return _internal_peerurls_size();
}
inline void MemberUpdateRequest::clear_peerurls() {
  _internal_mutable_peerurls()->Clear();
}
inline std::string* MemberUpdateRequest::add_peerurls() {
  std::string* _s = _internal_add_peerurls();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.MemberUpdateRequest.peerURLs)
  return _s;
}
inline const std::string& MemberUpdateRequest::peerurls(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberUpdateRequest.peerURLs)
  return _internal_peerurls(index);
}
inline std::string* MemberUpdateRequest::mutable_peerurls(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberUpdateRequest.peerURLs)
  return _internal_mutable_peerurls()->Mutable(index);
}
inline void MemberUpdateRequest::set_peerurls(int index, const std::string& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::set_peerurls(int index, std::string&& value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::set_peerurls(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::set_peerurls(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_peerurls()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::set_peerurls(int index, absl::string_view value) {
  _internal_mutable_peerurls()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::add_peerurls(const std::string& value) {
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::add_peerurls(std::string&& value) {
  _internal_mutable_peerurls()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::add_peerurls(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_peerurls()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::add_peerurls(const char* value, std::size_t size) {
  _internal_mutable_peerurls()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline void MemberUpdateRequest::add_peerurls(absl::string_view value) {
  _internal_mutable_peerurls()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.MemberUpdateRequest.peerURLs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MemberUpdateRequest::peerurls() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberUpdateRequest.peerURLs)
  return _internal_peerurls();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MemberUpdateRequest::mutable_peerurls() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberUpdateRequest.peerURLs)
  return _internal_mutable_peerurls();
}
inline const std::string& MemberUpdateRequest::_internal_peerurls(int index) const {
  return _internal_peerurls().Get(index);
}
inline std::string* MemberUpdateRequest::_internal_add_peerurls() {
  return _internal_mutable_peerurls()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MemberUpdateRequest::_internal_peerurls() const {
  return _impl_.peerurls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MemberUpdateRequest::_internal_mutable_peerurls() {
  return &_impl_.peerurls_;
}

// -------------------------------------------------------------------

// MemberUpdateResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MemberUpdateResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MemberUpdateResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MemberUpdateResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MemberUpdateResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberUpdateResponse.header)
  return _internal_header();
}
inline void MemberUpdateResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberUpdateResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MemberUpdateResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberUpdateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberUpdateResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberUpdateResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MemberUpdateResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberUpdateResponse.header)
  return _msg;
}
inline void MemberUpdateResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberUpdateResponse.header)
}

// repeated .etcdserverpb.Member members = 2;
inline int MemberUpdateResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int MemberUpdateResponse::members_size() const {
  return _internal_members_size();
}
inline void MemberUpdateResponse::clear_members() {
  _internal_mutable_members()->Clear();
}
inline ::etcdserverpb::Member* MemberUpdateResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberUpdateResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
MemberUpdateResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberUpdateResponse.members)
  return _internal_mutable_members();
}
inline const ::etcdserverpb::Member& MemberUpdateResponse::_internal_members(int index) const {
  return _internal_members().Get(index);
}
inline const ::etcdserverpb::Member& MemberUpdateResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberUpdateResponse.members)
  return _internal_members(index);
}
inline ::etcdserverpb::Member* MemberUpdateResponse::_internal_add_members() {
  return _internal_mutable_members()->Add();
}
inline ::etcdserverpb::Member* MemberUpdateResponse::add_members() {
  ::etcdserverpb::Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberUpdateResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
MemberUpdateResponse::members() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberUpdateResponse.members)
  return _internal_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>&
MemberUpdateResponse::_internal_members() const {
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>*
MemberUpdateResponse::_internal_mutable_members() {
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// MemberListRequest

// -------------------------------------------------------------------

// MemberListResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MemberListResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MemberListResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MemberListResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MemberListResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberListResponse.header)
  return _internal_header();
}
inline void MemberListResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberListResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MemberListResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberListResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberListResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberListResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MemberListResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberListResponse.header)
  return _msg;
}
inline void MemberListResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberListResponse.header)
}

// repeated .etcdserverpb.Member members = 2;
inline int MemberListResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int MemberListResponse::members_size() const {
  return _internal_members_size();
}
inline void MemberListResponse::clear_members() {
  _internal_mutable_members()->Clear();
}
inline ::etcdserverpb::Member* MemberListResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberListResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
MemberListResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberListResponse.members)
  return _internal_mutable_members();
}
inline const ::etcdserverpb::Member& MemberListResponse::_internal_members(int index) const {
  return _internal_members().Get(index);
}
inline const ::etcdserverpb::Member& MemberListResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberListResponse.members)
  return _internal_members(index);
}
inline ::etcdserverpb::Member* MemberListResponse::_internal_add_members() {
  return _internal_mutable_members()->Add();
}
inline ::etcdserverpb::Member* MemberListResponse::add_members() {
  ::etcdserverpb::Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberListResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
MemberListResponse::members() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberListResponse.members)
  return _internal_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>&
MemberListResponse::_internal_members() const {
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>*
MemberListResponse::_internal_mutable_members() {
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// MemberPromoteRequest

// uint64 ID = 1;
inline void MemberPromoteRequest::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MemberPromoteRequest::id() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberPromoteRequest.ID)
  return _internal_id();
}
inline void MemberPromoteRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MemberPromoteRequest.ID)
}
inline ::uint64_t MemberPromoteRequest::_internal_id() const {
  return _impl_.id_;
}
inline void MemberPromoteRequest::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// MemberPromoteResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MemberPromoteResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MemberPromoteResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MemberPromoteResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MemberPromoteResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberPromoteResponse.header)
  return _internal_header();
}
inline void MemberPromoteResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MemberPromoteResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MemberPromoteResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberPromoteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MemberPromoteResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MemberPromoteResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MemberPromoteResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberPromoteResponse.header)
  return _msg;
}
inline void MemberPromoteResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MemberPromoteResponse.header)
}

// repeated .etcdserverpb.Member members = 2;
inline int MemberPromoteResponse::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int MemberPromoteResponse::members_size() const {
  return _internal_members_size();
}
inline void MemberPromoteResponse::clear_members() {
  _internal_mutable_members()->Clear();
}
inline ::etcdserverpb::Member* MemberPromoteResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MemberPromoteResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >*
MemberPromoteResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.MemberPromoteResponse.members)
  return _internal_mutable_members();
}
inline const ::etcdserverpb::Member& MemberPromoteResponse::_internal_members(int index) const {
  return _internal_members().Get(index);
}
inline const ::etcdserverpb::Member& MemberPromoteResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MemberPromoteResponse.members)
  return _internal_members(index);
}
inline ::etcdserverpb::Member* MemberPromoteResponse::_internal_add_members() {
  return _internal_mutable_members()->Add();
}
inline ::etcdserverpb::Member* MemberPromoteResponse::add_members() {
  ::etcdserverpb::Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:etcdserverpb.MemberPromoteResponse.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::Member >&
MemberPromoteResponse::members() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.MemberPromoteResponse.members)
  return _internal_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>&
MemberPromoteResponse::_internal_members() const {
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::Member>*
MemberPromoteResponse::_internal_mutable_members() {
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// DefragmentRequest

// -------------------------------------------------------------------

// DefragmentResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool DefragmentResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void DefragmentResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& DefragmentResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& DefragmentResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.DefragmentResponse.header)
  return _internal_header();
}
inline void DefragmentResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.DefragmentResponse.header)
}
inline ::etcdserverpb::ResponseHeader* DefragmentResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* DefragmentResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.DefragmentResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* DefragmentResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* DefragmentResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.DefragmentResponse.header)
  return _msg;
}
inline void DefragmentResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.DefragmentResponse.header)
}

// -------------------------------------------------------------------

// MoveLeaderRequest

// uint64 targetID = 1;
inline void MoveLeaderRequest::clear_targetid() {
  _impl_.targetid_ = ::uint64_t{0u};
}
inline ::uint64_t MoveLeaderRequest::targetid() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MoveLeaderRequest.targetID)
  return _internal_targetid();
}
inline void MoveLeaderRequest::set_targetid(::uint64_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.MoveLeaderRequest.targetID)
}
inline ::uint64_t MoveLeaderRequest::_internal_targetid() const {
  return _impl_.targetid_;
}
inline void MoveLeaderRequest::_internal_set_targetid(::uint64_t value) {
  ;
  _impl_.targetid_ = value;
}

// -------------------------------------------------------------------

// MoveLeaderResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool MoveLeaderResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MoveLeaderResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& MoveLeaderResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& MoveLeaderResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.MoveLeaderResponse.header)
  return _internal_header();
}
inline void MoveLeaderResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.MoveLeaderResponse.header)
}
inline ::etcdserverpb::ResponseHeader* MoveLeaderResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MoveLeaderResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.MoveLeaderResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* MoveLeaderResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* MoveLeaderResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.MoveLeaderResponse.header)
  return _msg;
}
inline void MoveLeaderResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.MoveLeaderResponse.header)
}

// -------------------------------------------------------------------

// AlarmRequest

// .etcdserverpb.AlarmRequest.AlarmAction action = 1;
inline void AlarmRequest::clear_action() {
  _impl_.action_ = 0;
}
inline ::etcdserverpb::AlarmRequest_AlarmAction AlarmRequest::action() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmRequest.action)
  return _internal_action();
}
inline void AlarmRequest::set_action(::etcdserverpb::AlarmRequest_AlarmAction value) {
   _internal_set_action(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AlarmRequest.action)
}
inline ::etcdserverpb::AlarmRequest_AlarmAction AlarmRequest::_internal_action() const {
  return static_cast<::etcdserverpb::AlarmRequest_AlarmAction>(_impl_.action_);
}
inline void AlarmRequest::_internal_set_action(::etcdserverpb::AlarmRequest_AlarmAction value) {
  ;
  _impl_.action_ = value;
}

// uint64 memberID = 2;
inline void AlarmRequest::clear_memberid() {
  _impl_.memberid_ = ::uint64_t{0u};
}
inline ::uint64_t AlarmRequest::memberid() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmRequest.memberID)
  return _internal_memberid();
}
inline void AlarmRequest::set_memberid(::uint64_t value) {
  _internal_set_memberid(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AlarmRequest.memberID)
}
inline ::uint64_t AlarmRequest::_internal_memberid() const {
  return _impl_.memberid_;
}
inline void AlarmRequest::_internal_set_memberid(::uint64_t value) {
  ;
  _impl_.memberid_ = value;
}

// .etcdserverpb.AlarmType alarm = 3;
inline void AlarmRequest::clear_alarm() {
  _impl_.alarm_ = 0;
}
inline ::etcdserverpb::AlarmType AlarmRequest::alarm() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmRequest.alarm)
  return _internal_alarm();
}
inline void AlarmRequest::set_alarm(::etcdserverpb::AlarmType value) {
   _internal_set_alarm(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AlarmRequest.alarm)
}
inline ::etcdserverpb::AlarmType AlarmRequest::_internal_alarm() const {
  return static_cast<::etcdserverpb::AlarmType>(_impl_.alarm_);
}
inline void AlarmRequest::_internal_set_alarm(::etcdserverpb::AlarmType value) {
  ;
  _impl_.alarm_ = value;
}

// -------------------------------------------------------------------

// AlarmMember

// uint64 memberID = 1;
inline void AlarmMember::clear_memberid() {
  _impl_.memberid_ = ::uint64_t{0u};
}
inline ::uint64_t AlarmMember::memberid() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmMember.memberID)
  return _internal_memberid();
}
inline void AlarmMember::set_memberid(::uint64_t value) {
  _internal_set_memberid(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AlarmMember.memberID)
}
inline ::uint64_t AlarmMember::_internal_memberid() const {
  return _impl_.memberid_;
}
inline void AlarmMember::_internal_set_memberid(::uint64_t value) {
  ;
  _impl_.memberid_ = value;
}

// .etcdserverpb.AlarmType alarm = 2;
inline void AlarmMember::clear_alarm() {
  _impl_.alarm_ = 0;
}
inline ::etcdserverpb::AlarmType AlarmMember::alarm() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmMember.alarm)
  return _internal_alarm();
}
inline void AlarmMember::set_alarm(::etcdserverpb::AlarmType value) {
   _internal_set_alarm(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AlarmMember.alarm)
}
inline ::etcdserverpb::AlarmType AlarmMember::_internal_alarm() const {
  return static_cast<::etcdserverpb::AlarmType>(_impl_.alarm_);
}
inline void AlarmMember::_internal_set_alarm(::etcdserverpb::AlarmType value) {
  ;
  _impl_.alarm_ = value;
}

// -------------------------------------------------------------------

// AlarmResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AlarmResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AlarmResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AlarmResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AlarmResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmResponse.header)
  return _internal_header();
}
inline void AlarmResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AlarmResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AlarmResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AlarmResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AlarmResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AlarmResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AlarmResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AlarmResponse.header)
  return _msg;
}
inline void AlarmResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AlarmResponse.header)
}

// repeated .etcdserverpb.AlarmMember alarms = 2;
inline int AlarmResponse::_internal_alarms_size() const {
  return _impl_.alarms_.size();
}
inline int AlarmResponse::alarms_size() const {
  return _internal_alarms_size();
}
inline void AlarmResponse::clear_alarms() {
  _internal_mutable_alarms()->Clear();
}
inline ::etcdserverpb::AlarmMember* AlarmResponse::mutable_alarms(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AlarmResponse.alarms)
  return _internal_mutable_alarms()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::AlarmMember >*
AlarmResponse::mutable_alarms() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.AlarmResponse.alarms)
  return _internal_mutable_alarms();
}
inline const ::etcdserverpb::AlarmMember& AlarmResponse::_internal_alarms(int index) const {
  return _internal_alarms().Get(index);
}
inline const ::etcdserverpb::AlarmMember& AlarmResponse::alarms(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AlarmResponse.alarms)
  return _internal_alarms(index);
}
inline ::etcdserverpb::AlarmMember* AlarmResponse::_internal_add_alarms() {
  return _internal_mutable_alarms()->Add();
}
inline ::etcdserverpb::AlarmMember* AlarmResponse::add_alarms() {
  ::etcdserverpb::AlarmMember* _add = _internal_add_alarms();
  // @@protoc_insertion_point(field_add:etcdserverpb.AlarmResponse.alarms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::etcdserverpb::AlarmMember >&
AlarmResponse::alarms() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.AlarmResponse.alarms)
  return _internal_alarms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::AlarmMember>&
AlarmResponse::_internal_alarms() const {
  return _impl_.alarms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::etcdserverpb::AlarmMember>*
AlarmResponse::_internal_mutable_alarms() {
  return &_impl_.alarms_;
}

// -------------------------------------------------------------------

// StatusRequest

// -------------------------------------------------------------------

// StatusResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool StatusResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void StatusResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& StatusResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& StatusResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.header)
  return _internal_header();
}
inline void StatusResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.StatusResponse.header)
}
inline ::etcdserverpb::ResponseHeader* StatusResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* StatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.StatusResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* StatusResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* StatusResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.StatusResponse.header)
  return _msg;
}
inline void StatusResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.StatusResponse.header)
}

// string version = 2;
inline void StatusResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& StatusResponse::version() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.version)
}
inline std::string* StatusResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.StatusResponse.version)
  return _s;
}
inline const std::string& StatusResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void StatusResponse::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusResponse::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* StatusResponse::release_version() {
  // @@protoc_insertion_point(field_release:etcdserverpb.StatusResponse.version)
  return _impl_.version_.Release();
}
inline void StatusResponse::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.StatusResponse.version)
}

// int64 dbSize = 3;
inline void StatusResponse::clear_dbsize() {
  _impl_.dbsize_ = ::int64_t{0};
}
inline ::int64_t StatusResponse::dbsize() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.dbSize)
  return _internal_dbsize();
}
inline void StatusResponse::set_dbsize(::int64_t value) {
  _internal_set_dbsize(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.dbSize)
}
inline ::int64_t StatusResponse::_internal_dbsize() const {
  return _impl_.dbsize_;
}
inline void StatusResponse::_internal_set_dbsize(::int64_t value) {
  ;
  _impl_.dbsize_ = value;
}

// uint64 leader = 4;
inline void StatusResponse::clear_leader() {
  _impl_.leader_ = ::uint64_t{0u};
}
inline ::uint64_t StatusResponse::leader() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.leader)
  return _internal_leader();
}
inline void StatusResponse::set_leader(::uint64_t value) {
  _internal_set_leader(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.leader)
}
inline ::uint64_t StatusResponse::_internal_leader() const {
  return _impl_.leader_;
}
inline void StatusResponse::_internal_set_leader(::uint64_t value) {
  ;
  _impl_.leader_ = value;
}

// uint64 raftIndex = 5;
inline void StatusResponse::clear_raftindex() {
  _impl_.raftindex_ = ::uint64_t{0u};
}
inline ::uint64_t StatusResponse::raftindex() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.raftIndex)
  return _internal_raftindex();
}
inline void StatusResponse::set_raftindex(::uint64_t value) {
  _internal_set_raftindex(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.raftIndex)
}
inline ::uint64_t StatusResponse::_internal_raftindex() const {
  return _impl_.raftindex_;
}
inline void StatusResponse::_internal_set_raftindex(::uint64_t value) {
  ;
  _impl_.raftindex_ = value;
}

// uint64 raftTerm = 6;
inline void StatusResponse::clear_raftterm() {
  _impl_.raftterm_ = ::uint64_t{0u};
}
inline ::uint64_t StatusResponse::raftterm() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.raftTerm)
  return _internal_raftterm();
}
inline void StatusResponse::set_raftterm(::uint64_t value) {
  _internal_set_raftterm(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.raftTerm)
}
inline ::uint64_t StatusResponse::_internal_raftterm() const {
  return _impl_.raftterm_;
}
inline void StatusResponse::_internal_set_raftterm(::uint64_t value) {
  ;
  _impl_.raftterm_ = value;
}

// uint64 raftAppliedIndex = 7;
inline void StatusResponse::clear_raftappliedindex() {
  _impl_.raftappliedindex_ = ::uint64_t{0u};
}
inline ::uint64_t StatusResponse::raftappliedindex() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.raftAppliedIndex)
  return _internal_raftappliedindex();
}
inline void StatusResponse::set_raftappliedindex(::uint64_t value) {
  _internal_set_raftappliedindex(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.raftAppliedIndex)
}
inline ::uint64_t StatusResponse::_internal_raftappliedindex() const {
  return _impl_.raftappliedindex_;
}
inline void StatusResponse::_internal_set_raftappliedindex(::uint64_t value) {
  ;
  _impl_.raftappliedindex_ = value;
}

// repeated string errors = 8;
inline int StatusResponse::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int StatusResponse::errors_size() const {
  return _internal_errors_size();
}
inline void StatusResponse::clear_errors() {
  _internal_mutable_errors()->Clear();
}
inline std::string* StatusResponse::add_errors() {
  std::string* _s = _internal_add_errors();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.StatusResponse.errors)
  return _s;
}
inline const std::string& StatusResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.errors)
  return _internal_errors(index);
}
inline std::string* StatusResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.StatusResponse.errors)
  return _internal_mutable_errors()->Mutable(index);
}
inline void StatusResponse::set_errors(int index, const std::string& value) {
  _internal_mutable_errors()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::set_errors(int index, std::string&& value) {
  _internal_mutable_errors()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::set_errors(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_errors()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::set_errors(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_errors()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::set_errors(int index, absl::string_view value) {
  _internal_mutable_errors()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::add_errors(const std::string& value) {
  _internal_mutable_errors()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::add_errors(std::string&& value) {
  _internal_mutable_errors()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::add_errors(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_errors()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::add_errors(const char* value, std::size_t size) {
  _internal_mutable_errors()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.StatusResponse.errors)
}
inline void StatusResponse::add_errors(absl::string_view value) {
  _internal_mutable_errors()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.StatusResponse.errors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusResponse::errors() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.StatusResponse.errors)
  return _internal_errors();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StatusResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.StatusResponse.errors)
  return _internal_mutable_errors();
}
inline const std::string& StatusResponse::_internal_errors(int index) const {
  return _internal_errors().Get(index);
}
inline std::string* StatusResponse::_internal_add_errors() {
  return _internal_mutable_errors()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusResponse::_internal_errors() const {
  return _impl_.errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatusResponse::_internal_mutable_errors() {
  return &_impl_.errors_;
}

// int64 dbSizeInUse = 9;
inline void StatusResponse::clear_dbsizeinuse() {
  _impl_.dbsizeinuse_ = ::int64_t{0};
}
inline ::int64_t StatusResponse::dbsizeinuse() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.dbSizeInUse)
  return _internal_dbsizeinuse();
}
inline void StatusResponse::set_dbsizeinuse(::int64_t value) {
  _internal_set_dbsizeinuse(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.dbSizeInUse)
}
inline ::int64_t StatusResponse::_internal_dbsizeinuse() const {
  return _impl_.dbsizeinuse_;
}
inline void StatusResponse::_internal_set_dbsizeinuse(::int64_t value) {
  ;
  _impl_.dbsizeinuse_ = value;
}

// bool isLearner = 10;
inline void StatusResponse::clear_islearner() {
  _impl_.islearner_ = false;
}
inline bool StatusResponse::islearner() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.StatusResponse.isLearner)
  return _internal_islearner();
}
inline void StatusResponse::set_islearner(bool value) {
  _internal_set_islearner(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.StatusResponse.isLearner)
}
inline bool StatusResponse::_internal_islearner() const {
  return _impl_.islearner_;
}
inline void StatusResponse::_internal_set_islearner(bool value) {
  ;
  _impl_.islearner_ = value;
}

// -------------------------------------------------------------------

// AuthEnableRequest

// -------------------------------------------------------------------

// AuthDisableRequest

// -------------------------------------------------------------------

// AuthenticateRequest

// string name = 1;
inline void AuthenticateRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthenticateRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthenticateRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthenticateRequest.name)
}
inline std::string* AuthenticateRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthenticateRequest.name)
  return _s;
}
inline const std::string& AuthenticateRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthenticateRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthenticateRequest.name)
  return _impl_.name_.Release();
}
inline void AuthenticateRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthenticateRequest.name)
}

// string password = 2;
inline void AuthenticateRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthenticateRequest::password() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthenticateRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthenticateRequest.password)
}
inline std::string* AuthenticateRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthenticateRequest.password)
  return _s;
}
inline const std::string& AuthenticateRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthenticateRequest::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthenticateRequest::release_password() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthenticateRequest.password)
  return _impl_.password_.Release();
}
inline void AuthenticateRequest::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthenticateRequest.password)
}

// -------------------------------------------------------------------

// AuthUserAddRequest

// string name = 1;
inline void AuthUserAddRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthUserAddRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserAddRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserAddRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserAddRequest.name)
}
inline std::string* AuthUserAddRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserAddRequest.name)
  return _s;
}
inline const std::string& AuthUserAddRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthUserAddRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserAddRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserAddRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserAddRequest.name)
  return _impl_.name_.Release();
}
inline void AuthUserAddRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserAddRequest.name)
}

// string password = 2;
inline void AuthUserAddRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthUserAddRequest::password() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserAddRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserAddRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserAddRequest.password)
}
inline std::string* AuthUserAddRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserAddRequest.password)
  return _s;
}
inline const std::string& AuthUserAddRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthUserAddRequest::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserAddRequest::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserAddRequest::release_password() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserAddRequest.password)
  return _impl_.password_.Release();
}
inline void AuthUserAddRequest::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserAddRequest.password)
}

// .authpb.UserAddOptions options = 3;
inline bool AuthUserAddRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline const ::authpb::UserAddOptions& AuthUserAddRequest::_internal_options() const {
  const ::authpb::UserAddOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::authpb::UserAddOptions&>(
      ::authpb::_UserAddOptions_default_instance_);
}
inline const ::authpb::UserAddOptions& AuthUserAddRequest::options() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserAddRequest.options)
  return _internal_options();
}
inline void AuthUserAddRequest::unsafe_arena_set_allocated_options(
    ::authpb::UserAddOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserAddRequest.options)
}
inline ::authpb::UserAddOptions* AuthUserAddRequest::release_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::authpb::UserAddOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authpb::UserAddOptions* AuthUserAddRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserAddRequest.options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::authpb::UserAddOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::authpb::UserAddOptions* AuthUserAddRequest::_internal_mutable_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::authpb::UserAddOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::authpb::UserAddOptions* AuthUserAddRequest::mutable_options() {
  ::authpb::UserAddOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserAddRequest.options)
  return _msg;
}
inline void AuthUserAddRequest::set_allocated_options(::authpb::UserAddOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserAddRequest.options)
}

// -------------------------------------------------------------------

// AuthUserGetRequest

// string name = 1;
inline void AuthUserGetRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthUserGetRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGetRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserGetRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserGetRequest.name)
}
inline std::string* AuthUserGetRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGetRequest.name)
  return _s;
}
inline const std::string& AuthUserGetRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthUserGetRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserGetRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserGetRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserGetRequest.name)
  return _impl_.name_.Release();
}
inline void AuthUserGetRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserGetRequest.name)
}

// -------------------------------------------------------------------

// AuthUserDeleteRequest

// string name = 1;
inline void AuthUserDeleteRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthUserDeleteRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserDeleteRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserDeleteRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserDeleteRequest.name)
}
inline std::string* AuthUserDeleteRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserDeleteRequest.name)
  return _s;
}
inline const std::string& AuthUserDeleteRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthUserDeleteRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserDeleteRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserDeleteRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserDeleteRequest.name)
  return _impl_.name_.Release();
}
inline void AuthUserDeleteRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserDeleteRequest.name)
}

// -------------------------------------------------------------------

// AuthUserChangePasswordRequest

// string name = 1;
inline void AuthUserChangePasswordRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthUserChangePasswordRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserChangePasswordRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserChangePasswordRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserChangePasswordRequest.name)
}
inline std::string* AuthUserChangePasswordRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserChangePasswordRequest.name)
  return _s;
}
inline const std::string& AuthUserChangePasswordRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthUserChangePasswordRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserChangePasswordRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserChangePasswordRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserChangePasswordRequest.name)
  return _impl_.name_.Release();
}
inline void AuthUserChangePasswordRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserChangePasswordRequest.name)
}

// string password = 2;
inline void AuthUserChangePasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthUserChangePasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserChangePasswordRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserChangePasswordRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserChangePasswordRequest.password)
}
inline std::string* AuthUserChangePasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserChangePasswordRequest.password)
  return _s;
}
inline const std::string& AuthUserChangePasswordRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AuthUserChangePasswordRequest::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserChangePasswordRequest::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserChangePasswordRequest::release_password() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserChangePasswordRequest.password)
  return _impl_.password_.Release();
}
inline void AuthUserChangePasswordRequest::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserChangePasswordRequest.password)
}

// -------------------------------------------------------------------

// AuthUserGrantRoleRequest

// string user = 1;
inline void AuthUserGrantRoleRequest::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& AuthUserGrantRoleRequest::user() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGrantRoleRequest.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserGrantRoleRequest::set_user(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserGrantRoleRequest.user)
}
inline std::string* AuthUserGrantRoleRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGrantRoleRequest.user)
  return _s;
}
inline const std::string& AuthUserGrantRoleRequest::_internal_user() const {
  return _impl_.user_.Get();
}
inline void AuthUserGrantRoleRequest::_internal_set_user(const std::string& value) {
  ;


  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserGrantRoleRequest::_internal_mutable_user() {
  ;
  return _impl_.user_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserGrantRoleRequest::release_user() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserGrantRoleRequest.user)
  return _impl_.user_.Release();
}
inline void AuthUserGrantRoleRequest::set_allocated_user(std::string* value) {
  _impl_.user_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserGrantRoleRequest.user)
}

// string role = 2;
inline void AuthUserGrantRoleRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& AuthUserGrantRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGrantRoleRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserGrantRoleRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserGrantRoleRequest.role)
}
inline std::string* AuthUserGrantRoleRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGrantRoleRequest.role)
  return _s;
}
inline const std::string& AuthUserGrantRoleRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void AuthUserGrantRoleRequest::_internal_set_role(const std::string& value) {
  ;


  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserGrantRoleRequest::_internal_mutable_role() {
  ;
  return _impl_.role_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserGrantRoleRequest::release_role() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserGrantRoleRequest.role)
  return _impl_.role_.Release();
}
inline void AuthUserGrantRoleRequest::set_allocated_role(std::string* value) {
  _impl_.role_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserGrantRoleRequest.role)
}

// -------------------------------------------------------------------

// AuthUserRevokeRoleRequest

// string name = 1;
inline void AuthUserRevokeRoleRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthUserRevokeRoleRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserRevokeRoleRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserRevokeRoleRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserRevokeRoleRequest.name)
}
inline std::string* AuthUserRevokeRoleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserRevokeRoleRequest.name)
  return _s;
}
inline const std::string& AuthUserRevokeRoleRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthUserRevokeRoleRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserRevokeRoleRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserRevokeRoleRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserRevokeRoleRequest.name)
  return _impl_.name_.Release();
}
inline void AuthUserRevokeRoleRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserRevokeRoleRequest.name)
}

// string role = 2;
inline void AuthUserRevokeRoleRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& AuthUserRevokeRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserRevokeRoleRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthUserRevokeRoleRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserRevokeRoleRequest.role)
}
inline std::string* AuthUserRevokeRoleRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserRevokeRoleRequest.role)
  return _s;
}
inline const std::string& AuthUserRevokeRoleRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void AuthUserRevokeRoleRequest::_internal_set_role(const std::string& value) {
  ;


  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthUserRevokeRoleRequest::_internal_mutable_role() {
  ;
  return _impl_.role_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthUserRevokeRoleRequest::release_role() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserRevokeRoleRequest.role)
  return _impl_.role_.Release();
}
inline void AuthUserRevokeRoleRequest::set_allocated_role(std::string* value) {
  _impl_.role_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserRevokeRoleRequest.role)
}

// -------------------------------------------------------------------

// AuthRoleAddRequest

// string name = 1;
inline void AuthRoleAddRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthRoleAddRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleAddRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleAddRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleAddRequest.name)
}
inline std::string* AuthRoleAddRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleAddRequest.name)
  return _s;
}
inline const std::string& AuthRoleAddRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthRoleAddRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleAddRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleAddRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleAddRequest.name)
  return _impl_.name_.Release();
}
inline void AuthRoleAddRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleAddRequest.name)
}

// -------------------------------------------------------------------

// AuthRoleGetRequest

// string role = 1;
inline void AuthRoleGetRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& AuthRoleGetRequest::role() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGetRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleGetRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleGetRequest.role)
}
inline std::string* AuthRoleGetRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGetRequest.role)
  return _s;
}
inline const std::string& AuthRoleGetRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void AuthRoleGetRequest::_internal_set_role(const std::string& value) {
  ;


  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleGetRequest::_internal_mutable_role() {
  ;
  return _impl_.role_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleGetRequest::release_role() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleGetRequest.role)
  return _impl_.role_.Release();
}
inline void AuthRoleGetRequest::set_allocated_role(std::string* value) {
  _impl_.role_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleGetRequest.role)
}

// -------------------------------------------------------------------

// AuthUserListRequest

// -------------------------------------------------------------------

// AuthRoleListRequest

// -------------------------------------------------------------------

// AuthRoleDeleteRequest

// string role = 1;
inline void AuthRoleDeleteRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& AuthRoleDeleteRequest::role() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleDeleteRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleDeleteRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleDeleteRequest.role)
}
inline std::string* AuthRoleDeleteRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleDeleteRequest.role)
  return _s;
}
inline const std::string& AuthRoleDeleteRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void AuthRoleDeleteRequest::_internal_set_role(const std::string& value) {
  ;


  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleDeleteRequest::_internal_mutable_role() {
  ;
  return _impl_.role_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleDeleteRequest::release_role() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleDeleteRequest.role)
  return _impl_.role_.Release();
}
inline void AuthRoleDeleteRequest::set_allocated_role(std::string* value) {
  _impl_.role_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleDeleteRequest.role)
}

// -------------------------------------------------------------------

// AuthRoleGrantPermissionRequest

// string name = 1;
inline void AuthRoleGrantPermissionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AuthRoleGrantPermissionRequest::name() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGrantPermissionRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleGrantPermissionRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleGrantPermissionRequest.name)
}
inline std::string* AuthRoleGrantPermissionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGrantPermissionRequest.name)
  return _s;
}
inline const std::string& AuthRoleGrantPermissionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AuthRoleGrantPermissionRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleGrantPermissionRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleGrantPermissionRequest::release_name() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleGrantPermissionRequest.name)
  return _impl_.name_.Release();
}
inline void AuthRoleGrantPermissionRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleGrantPermissionRequest.name)
}

// .authpb.Permission perm = 2;
inline bool AuthRoleGrantPermissionRequest::has_perm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.perm_ != nullptr);
  return value;
}
inline const ::authpb::Permission& AuthRoleGrantPermissionRequest::_internal_perm() const {
  const ::authpb::Permission* p = _impl_.perm_;
  return p != nullptr ? *p : reinterpret_cast<const ::authpb::Permission&>(
      ::authpb::_Permission_default_instance_);
}
inline const ::authpb::Permission& AuthRoleGrantPermissionRequest::perm() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGrantPermissionRequest.perm)
  return _internal_perm();
}
inline void AuthRoleGrantPermissionRequest::unsafe_arena_set_allocated_perm(
    ::authpb::Permission* perm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perm_);
  }
  _impl_.perm_ = perm;
  if (perm) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleGrantPermissionRequest.perm)
}
inline ::authpb::Permission* AuthRoleGrantPermissionRequest::release_perm() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::authpb::Permission* temp = _impl_.perm_;
  _impl_.perm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authpb::Permission* AuthRoleGrantPermissionRequest::unsafe_arena_release_perm() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleGrantPermissionRequest.perm)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::authpb::Permission* temp = _impl_.perm_;
  _impl_.perm_ = nullptr;
  return temp;
}
inline ::authpb::Permission* AuthRoleGrantPermissionRequest::_internal_mutable_perm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.perm_ == nullptr) {
    auto* p = CreateMaybeMessage<::authpb::Permission>(GetArenaForAllocation());
    _impl_.perm_ = p;
  }
  return _impl_.perm_;
}
inline ::authpb::Permission* AuthRoleGrantPermissionRequest::mutable_perm() {
  ::authpb::Permission* _msg = _internal_mutable_perm();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGrantPermissionRequest.perm)
  return _msg;
}
inline void AuthRoleGrantPermissionRequest::set_allocated_perm(::authpb::Permission* perm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perm_);
  }
  if (perm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(perm));
    if (message_arena != submessage_arena) {
      perm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, perm, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.perm_ = perm;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleGrantPermissionRequest.perm)
}

// -------------------------------------------------------------------

// AuthRoleRevokePermissionRequest

// string role = 1;
inline void AuthRoleRevokePermissionRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& AuthRoleRevokePermissionRequest::role() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleRevokePermissionRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleRevokePermissionRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleRevokePermissionRequest.role)
}
inline std::string* AuthRoleRevokePermissionRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleRevokePermissionRequest.role)
  return _s;
}
inline const std::string& AuthRoleRevokePermissionRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void AuthRoleRevokePermissionRequest::_internal_set_role(const std::string& value) {
  ;


  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::_internal_mutable_role() {
  ;
  return _impl_.role_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::release_role() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleRevokePermissionRequest.role)
  return _impl_.role_.Release();
}
inline void AuthRoleRevokePermissionRequest::set_allocated_role(std::string* value) {
  _impl_.role_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleRevokePermissionRequest.role)
}

// bytes key = 2;
inline void AuthRoleRevokePermissionRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& AuthRoleRevokePermissionRequest::key() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleRevokePermissionRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleRevokePermissionRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleRevokePermissionRequest.key)
}
inline std::string* AuthRoleRevokePermissionRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleRevokePermissionRequest.key)
  return _s;
}
inline const std::string& AuthRoleRevokePermissionRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void AuthRoleRevokePermissionRequest::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::release_key() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleRevokePermissionRequest.key)
  return _impl_.key_.Release();
}
inline void AuthRoleRevokePermissionRequest::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleRevokePermissionRequest.key)
}

// bytes range_end = 3;
inline void AuthRoleRevokePermissionRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& AuthRoleRevokePermissionRequest::range_end() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleRevokePermissionRequest.range_end)
  return _internal_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRoleRevokePermissionRequest::set_range_end(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.range_end_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleRevokePermissionRequest.range_end)
}
inline std::string* AuthRoleRevokePermissionRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleRevokePermissionRequest.range_end)
  return _s;
}
inline const std::string& AuthRoleRevokePermissionRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void AuthRoleRevokePermissionRequest::_internal_set_range_end(const std::string& value) {
  ;


  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::_internal_mutable_range_end() {
  ;
  return _impl_.range_end_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthRoleRevokePermissionRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleRevokePermissionRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void AuthRoleRevokePermissionRequest::set_allocated_range_end(std::string* value) {
  _impl_.range_end_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_end_.IsDefault()) {
          _impl_.range_end_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleRevokePermissionRequest.range_end)
}

// -------------------------------------------------------------------

// AuthEnableResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthEnableResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthEnableResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthEnableResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthEnableResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthEnableResponse.header)
  return _internal_header();
}
inline void AuthEnableResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthEnableResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthEnableResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthEnableResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthEnableResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthEnableResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthEnableResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthEnableResponse.header)
  return _msg;
}
inline void AuthEnableResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthEnableResponse.header)
}

// -------------------------------------------------------------------

// AuthDisableResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthDisableResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthDisableResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthDisableResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthDisableResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthDisableResponse.header)
  return _internal_header();
}
inline void AuthDisableResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthDisableResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthDisableResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthDisableResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthDisableResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthDisableResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthDisableResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthDisableResponse.header)
  return _msg;
}
inline void AuthDisableResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthDisableResponse.header)
}

// -------------------------------------------------------------------

// AuthenticateResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthenticateResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthenticateResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthenticateResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthenticateResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthenticateResponse.header)
  return _internal_header();
}
inline void AuthenticateResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthenticateResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthenticateResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthenticateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthenticateResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthenticateResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthenticateResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthenticateResponse.header)
  return _msg;
}
inline void AuthenticateResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthenticateResponse.header)
}

// string token = 2;
inline void AuthenticateResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthenticateResponse::token() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthenticateResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticateResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthenticateResponse.token)
}
inline std::string* AuthenticateResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthenticateResponse.token)
  return _s;
}
inline const std::string& AuthenticateResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void AuthenticateResponse::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthenticateResponse::release_token() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthenticateResponse.token)
  return _impl_.token_.Release();
}
inline void AuthenticateResponse::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthenticateResponse.token)
}

// -------------------------------------------------------------------

// AuthUserAddResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserAddResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserAddResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserAddResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserAddResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserAddResponse.header)
  return _internal_header();
}
inline void AuthUserAddResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserAddResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserAddResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserAddResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserAddResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserAddResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserAddResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserAddResponse.header)
  return _msg;
}
inline void AuthUserAddResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserAddResponse.header)
}

// -------------------------------------------------------------------

// AuthUserGetResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserGetResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserGetResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserGetResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserGetResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGetResponse.header)
  return _internal_header();
}
inline void AuthUserGetResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserGetResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserGetResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGetResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserGetResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGetResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGetResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGetResponse.header)
  return _msg;
}
inline void AuthUserGetResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserGetResponse.header)
}

// repeated string roles = 2;
inline int AuthUserGetResponse::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int AuthUserGetResponse::roles_size() const {
  return _internal_roles_size();
}
inline void AuthUserGetResponse::clear_roles() {
  _internal_mutable_roles()->Clear();
}
inline std::string* AuthUserGetResponse::add_roles() {
  std::string* _s = _internal_add_roles();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.AuthUserGetResponse.roles)
  return _s;
}
inline const std::string& AuthUserGetResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGetResponse.roles)
  return _internal_roles(index);
}
inline std::string* AuthUserGetResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGetResponse.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline void AuthUserGetResponse::set_roles(int index, const std::string& value) {
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::set_roles(int index, std::string&& value) {
  _internal_mutable_roles()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::set_roles(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::set_roles(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_roles()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::set_roles(int index, absl::string_view value) {
  _internal_mutable_roles()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::add_roles(const std::string& value) {
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::add_roles(std::string&& value) {
  _internal_mutable_roles()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::add_roles(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::add_roles(const char* value, std::size_t size) {
  _internal_mutable_roles()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.AuthUserGetResponse.roles)
}
inline void AuthUserGetResponse::add_roles(absl::string_view value) {
  _internal_mutable_roles()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.AuthUserGetResponse.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthUserGetResponse::roles() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.AuthUserGetResponse.roles)
  return _internal_roles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AuthUserGetResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.AuthUserGetResponse.roles)
  return _internal_mutable_roles();
}
inline const std::string& AuthUserGetResponse::_internal_roles(int index) const {
  return _internal_roles().Get(index);
}
inline std::string* AuthUserGetResponse::_internal_add_roles() {
  return _internal_mutable_roles()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthUserGetResponse::_internal_roles() const {
  return _impl_.roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthUserGetResponse::_internal_mutable_roles() {
  return &_impl_.roles_;
}

// -------------------------------------------------------------------

// AuthUserDeleteResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserDeleteResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserDeleteResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserDeleteResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserDeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserDeleteResponse.header)
  return _internal_header();
}
inline void AuthUserDeleteResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserDeleteResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserDeleteResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserDeleteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserDeleteResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserDeleteResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserDeleteResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserDeleteResponse.header)
  return _msg;
}
inline void AuthUserDeleteResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserDeleteResponse.header)
}

// -------------------------------------------------------------------

// AuthUserChangePasswordResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserChangePasswordResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserChangePasswordResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserChangePasswordResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserChangePasswordResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserChangePasswordResponse.header)
  return _internal_header();
}
inline void AuthUserChangePasswordResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserChangePasswordResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserChangePasswordResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserChangePasswordResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserChangePasswordResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserChangePasswordResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserChangePasswordResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserChangePasswordResponse.header)
  return _msg;
}
inline void AuthUserChangePasswordResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserChangePasswordResponse.header)
}

// -------------------------------------------------------------------

// AuthUserGrantRoleResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserGrantRoleResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserGrantRoleResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserGrantRoleResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserGrantRoleResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserGrantRoleResponse.header)
  return _internal_header();
}
inline void AuthUserGrantRoleResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserGrantRoleResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserGrantRoleResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGrantRoleResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserGrantRoleResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGrantRoleResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserGrantRoleResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserGrantRoleResponse.header)
  return _msg;
}
inline void AuthUserGrantRoleResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserGrantRoleResponse.header)
}

// -------------------------------------------------------------------

// AuthUserRevokeRoleResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserRevokeRoleResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserRevokeRoleResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserRevokeRoleResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserRevokeRoleResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserRevokeRoleResponse.header)
  return _internal_header();
}
inline void AuthUserRevokeRoleResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserRevokeRoleResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserRevokeRoleResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserRevokeRoleResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserRevokeRoleResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserRevokeRoleResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserRevokeRoleResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserRevokeRoleResponse.header)
  return _msg;
}
inline void AuthUserRevokeRoleResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserRevokeRoleResponse.header)
}

// -------------------------------------------------------------------

// AuthRoleAddResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleAddResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleAddResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleAddResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleAddResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleAddResponse.header)
  return _internal_header();
}
inline void AuthRoleAddResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleAddResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleAddResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleAddResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleAddResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleAddResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleAddResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleAddResponse.header)
  return _msg;
}
inline void AuthRoleAddResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleAddResponse.header)
}

// -------------------------------------------------------------------

// AuthRoleGetResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleGetResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleGetResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleGetResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleGetResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGetResponse.header)
  return _internal_header();
}
inline void AuthRoleGetResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleGetResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGetResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGetResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleGetResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGetResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGetResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGetResponse.header)
  return _msg;
}
inline void AuthRoleGetResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleGetResponse.header)
}

// repeated .authpb.Permission perm = 2;
inline int AuthRoleGetResponse::_internal_perm_size() const {
  return _impl_.perm_.size();
}
inline int AuthRoleGetResponse::perm_size() const {
  return _internal_perm_size();
}
inline ::authpb::Permission* AuthRoleGetResponse::mutable_perm(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGetResponse.perm)
  return _internal_mutable_perm()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authpb::Permission >*
AuthRoleGetResponse::mutable_perm() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.AuthRoleGetResponse.perm)
  return _internal_mutable_perm();
}
inline const ::authpb::Permission& AuthRoleGetResponse::_internal_perm(int index) const {
  return _internal_perm().Get(index);
}
inline const ::authpb::Permission& AuthRoleGetResponse::perm(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGetResponse.perm)
  return _internal_perm(index);
}
inline ::authpb::Permission* AuthRoleGetResponse::_internal_add_perm() {
  return _internal_mutable_perm()->Add();
}
inline ::authpb::Permission* AuthRoleGetResponse::add_perm() {
  ::authpb::Permission* _add = _internal_add_perm();
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthRoleGetResponse.perm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authpb::Permission >&
AuthRoleGetResponse::perm() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.AuthRoleGetResponse.perm)
  return _internal_perm();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::authpb::Permission>&
AuthRoleGetResponse::_internal_perm() const {
  return _impl_.perm_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::authpb::Permission>*
AuthRoleGetResponse::_internal_mutable_perm() {
  return &_impl_.perm_;
}

// -------------------------------------------------------------------

// AuthRoleListResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleListResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleListResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleListResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleListResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleListResponse.header)
  return _internal_header();
}
inline void AuthRoleListResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleListResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleListResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleListResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleListResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleListResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleListResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleListResponse.header)
  return _msg;
}
inline void AuthRoleListResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleListResponse.header)
}

// repeated string roles = 2;
inline int AuthRoleListResponse::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int AuthRoleListResponse::roles_size() const {
  return _internal_roles_size();
}
inline void AuthRoleListResponse::clear_roles() {
  _internal_mutable_roles()->Clear();
}
inline std::string* AuthRoleListResponse::add_roles() {
  std::string* _s = _internal_add_roles();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.AuthRoleListResponse.roles)
  return _s;
}
inline const std::string& AuthRoleListResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleListResponse.roles)
  return _internal_roles(index);
}
inline std::string* AuthRoleListResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleListResponse.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline void AuthRoleListResponse::set_roles(int index, const std::string& value) {
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::set_roles(int index, std::string&& value) {
  _internal_mutable_roles()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::set_roles(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::set_roles(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_roles()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::set_roles(int index, absl::string_view value) {
  _internal_mutable_roles()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::add_roles(const std::string& value) {
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::add_roles(std::string&& value) {
  _internal_mutable_roles()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::add_roles(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::add_roles(const char* value, std::size_t size) {
  _internal_mutable_roles()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.AuthRoleListResponse.roles)
}
inline void AuthRoleListResponse::add_roles(absl::string_view value) {
  _internal_mutable_roles()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.AuthRoleListResponse.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthRoleListResponse::roles() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.AuthRoleListResponse.roles)
  return _internal_roles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AuthRoleListResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.AuthRoleListResponse.roles)
  return _internal_mutable_roles();
}
inline const std::string& AuthRoleListResponse::_internal_roles(int index) const {
  return _internal_roles().Get(index);
}
inline std::string* AuthRoleListResponse::_internal_add_roles() {
  return _internal_mutable_roles()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthRoleListResponse::_internal_roles() const {
  return _impl_.roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthRoleListResponse::_internal_mutable_roles() {
  return &_impl_.roles_;
}

// -------------------------------------------------------------------

// AuthUserListResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthUserListResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthUserListResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthUserListResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthUserListResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserListResponse.header)
  return _internal_header();
}
inline void AuthUserListResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthUserListResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthUserListResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserListResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthUserListResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthUserListResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthUserListResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserListResponse.header)
  return _msg;
}
inline void AuthUserListResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthUserListResponse.header)
}

// repeated string users = 2;
inline int AuthUserListResponse::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int AuthUserListResponse::users_size() const {
  return _internal_users_size();
}
inline void AuthUserListResponse::clear_users() {
  _internal_mutable_users()->Clear();
}
inline std::string* AuthUserListResponse::add_users() {
  std::string* _s = _internal_add_users();
  // @@protoc_insertion_point(field_add_mutable:etcdserverpb.AuthUserListResponse.users)
  return _s;
}
inline const std::string& AuthUserListResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthUserListResponse.users)
  return _internal_users(index);
}
inline std::string* AuthUserListResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthUserListResponse.users)
  return _internal_mutable_users()->Mutable(index);
}
inline void AuthUserListResponse::set_users(int index, const std::string& value) {
  _internal_mutable_users()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::set_users(int index, std::string&& value) {
  _internal_mutable_users()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::set_users(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_users()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::set_users(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_users()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::set_users(int index, absl::string_view value) {
  _internal_mutable_users()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::add_users(const std::string& value) {
  _internal_mutable_users()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::add_users(std::string&& value) {
  _internal_mutable_users()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::add_users(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_users()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::add_users(const char* value, std::size_t size) {
  _internal_mutable_users()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:etcdserverpb.AuthUserListResponse.users)
}
inline void AuthUserListResponse::add_users(absl::string_view value) {
  _internal_mutable_users()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:etcdserverpb.AuthUserListResponse.users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthUserListResponse::users() const {
  // @@protoc_insertion_point(field_list:etcdserverpb.AuthUserListResponse.users)
  return _internal_users();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AuthUserListResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:etcdserverpb.AuthUserListResponse.users)
  return _internal_mutable_users();
}
inline const std::string& AuthUserListResponse::_internal_users(int index) const {
  return _internal_users().Get(index);
}
inline std::string* AuthUserListResponse::_internal_add_users() {
  return _internal_mutable_users()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AuthUserListResponse::_internal_users() const {
  return _impl_.users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AuthUserListResponse::_internal_mutable_users() {
  return &_impl_.users_;
}

// -------------------------------------------------------------------

// AuthRoleDeleteResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleDeleteResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleDeleteResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleDeleteResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleDeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleDeleteResponse.header)
  return _internal_header();
}
inline void AuthRoleDeleteResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleDeleteResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleDeleteResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleDeleteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleDeleteResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleDeleteResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleDeleteResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleDeleteResponse.header)
  return _msg;
}
inline void AuthRoleDeleteResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleDeleteResponse.header)
}

// -------------------------------------------------------------------

// AuthRoleGrantPermissionResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleGrantPermissionResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleGrantPermissionResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleGrantPermissionResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleGrantPermissionResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleGrantPermissionResponse.header)
  return _internal_header();
}
inline void AuthRoleGrantPermissionResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleGrantPermissionResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGrantPermissionResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGrantPermissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleGrantPermissionResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGrantPermissionResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleGrantPermissionResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleGrantPermissionResponse.header)
  return _msg;
}
inline void AuthRoleGrantPermissionResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleGrantPermissionResponse.header)
}

// -------------------------------------------------------------------

// AuthRoleRevokePermissionResponse

// .etcdserverpb.ResponseHeader header = 1;
inline bool AuthRoleRevokePermissionResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void AuthRoleRevokePermissionResponse::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleRevokePermissionResponse::_internal_header() const {
  const ::etcdserverpb::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::etcdserverpb::ResponseHeader&>(
      ::etcdserverpb::_ResponseHeader_default_instance_);
}
inline const ::etcdserverpb::ResponseHeader& AuthRoleRevokePermissionResponse::header() const {
  // @@protoc_insertion_point(field_get:etcdserverpb.AuthRoleRevokePermissionResponse.header)
  return _internal_header();
}
inline void AuthRoleRevokePermissionResponse::unsafe_arena_set_allocated_header(
    ::etcdserverpb::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:etcdserverpb.AuthRoleRevokePermissionResponse.header)
}
inline ::etcdserverpb::ResponseHeader* AuthRoleRevokePermissionResponse::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleRevokePermissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:etcdserverpb.AuthRoleRevokePermissionResponse.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::etcdserverpb::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleRevokePermissionResponse::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::etcdserverpb::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::etcdserverpb::ResponseHeader* AuthRoleRevokePermissionResponse::mutable_header() {
  ::etcdserverpb::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:etcdserverpb.AuthRoleRevokePermissionResponse.header)
  return _msg;
}
inline void AuthRoleRevokePermissionResponse::set_allocated_header(::etcdserverpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.AuthRoleRevokePermissionResponse.header)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace etcdserverpb


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::etcdserverpb::RangeRequest_SortOrder> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::RangeRequest_SortOrder>() {
  return ::etcdserverpb::RangeRequest_SortOrder_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::RangeRequest_SortTarget> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::RangeRequest_SortTarget>() {
  return ::etcdserverpb::RangeRequest_SortTarget_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::Compare_CompareResult> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::Compare_CompareResult>() {
  return ::etcdserverpb::Compare_CompareResult_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::Compare_CompareTarget> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::Compare_CompareTarget>() {
  return ::etcdserverpb::Compare_CompareTarget_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::WatchCreateRequest_FilterType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::WatchCreateRequest_FilterType>() {
  return ::etcdserverpb::WatchCreateRequest_FilterType_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::AlarmRequest_AlarmAction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::AlarmRequest_AlarmAction>() {
  return ::etcdserverpb::AlarmRequest_AlarmAction_descriptor();
}
template <>
struct is_proto_enum<::etcdserverpb::AlarmType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::etcdserverpb::AlarmType>() {
  return ::etcdserverpb::AlarmType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_rpc_2eproto_2epb_2eh
