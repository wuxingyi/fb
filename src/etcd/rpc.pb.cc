// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#include "rpc.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace etcdserverpb {
template <typename>
PROTOBUF_CONSTEXPR ResponseHeader::ResponseHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cluster_id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.member_id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.raft_term_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseHeaderDefaultTypeInternal() {}
  union {
    ResponseHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RangeRequest::RangeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.range_end_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.limit_)*/ ::int64_t{0}

  , /*decltype(_impl_.revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.sort_order_)*/ 0

  , /*decltype(_impl_.sort_target_)*/ 0

  , /*decltype(_impl_.min_mod_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.max_mod_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.min_create_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.max_create_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.serializable_)*/ false

  , /*decltype(_impl_.keys_only_)*/ false

  , /*decltype(_impl_.count_only_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RangeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeRequestDefaultTypeInternal() {}
  union {
    RangeRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RangeResponse::RangeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.count_)*/ ::int64_t{0}

  , /*decltype(_impl_.more_)*/ false
} {}
struct RangeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeResponseDefaultTypeInternal() {}
  union {
    RangeResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PutRequest::PutRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.lease_)*/ ::int64_t{0}

  , /*decltype(_impl_.prev_kv_)*/ false

  , /*decltype(_impl_.ignore_value_)*/ false

  , /*decltype(_impl_.ignore_lease_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PutRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PutRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PutRequestDefaultTypeInternal() {}
  union {
    PutRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PutRequestDefaultTypeInternal _PutRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PutResponse::PutResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/nullptr} {}
struct PutResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PutResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PutResponseDefaultTypeInternal() {}
  union {
    PutResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PutResponseDefaultTypeInternal _PutResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeleteRangeRequest::DeleteRangeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.range_end_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.prev_kv_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteRangeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteRangeRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteRangeRequestDefaultTypeInternal() {}
  union {
    DeleteRangeRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeleteRangeResponse::DeleteRangeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prev_kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.deleted_)*/ ::int64_t{0}
} {}
struct DeleteRangeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteRangeResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteRangeResponseDefaultTypeInternal() {}
  union {
    DeleteRangeResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RequestOp::RequestOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestOpDefaultTypeInternal() {}
  union {
    RequestOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestOpDefaultTypeInternal _RequestOp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ResponseOp::ResponseOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseOpDefaultTypeInternal() {}
  union {
    ResponseOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseOpDefaultTypeInternal _ResponseOp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Compare::Compare(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.range_end_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.result_)*/ 0

  , /*decltype(_impl_.target_)*/ 0

  , /*decltype(_impl_.target_union_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CompareDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompareDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompareDefaultTypeInternal() {}
  union {
    Compare _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompareDefaultTypeInternal _Compare_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TxnRequest::TxnRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.compare_)*/{}
  , /*decltype(_impl_.success_)*/{}
  , /*decltype(_impl_.failure_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TxnRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TxnRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TxnRequestDefaultTypeInternal() {}
  union {
    TxnRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TxnRequestDefaultTypeInternal _TxnRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TxnResponse::TxnResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.succeeded_)*/ false
} {}
struct TxnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TxnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TxnResponseDefaultTypeInternal() {}
  union {
    TxnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TxnResponseDefaultTypeInternal _TxnResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompactionRequest::CompactionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.physical_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompactionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompactionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompactionRequestDefaultTypeInternal() {}
  union {
    CompactionRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompactionRequestDefaultTypeInternal _CompactionRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompactionResponse::CompactionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct CompactionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompactionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompactionResponseDefaultTypeInternal() {}
  union {
    CompactionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompactionResponseDefaultTypeInternal _CompactionResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HashRequest::HashRequest(
    ::_pbi::ConstantInitialized) {}
struct HashRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashRequestDefaultTypeInternal() {}
  union {
    HashRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashRequestDefaultTypeInternal _HashRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HashKVRequest::HashKVRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.revision_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HashKVRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashKVRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashKVRequestDefaultTypeInternal() {}
  union {
    HashKVRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashKVRequestDefaultTypeInternal _HashKVRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HashKVResponse::HashKVResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.compact_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.hash_)*/ 0u
} {}
struct HashKVResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashKVResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashKVResponseDefaultTypeInternal() {}
  union {
    HashKVResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashKVResponseDefaultTypeInternal _HashKVResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HashResponse::HashResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.hash_)*/ 0u
} {}
struct HashResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashResponseDefaultTypeInternal() {}
  union {
    HashResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashResponseDefaultTypeInternal _HashResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SnapshotRequest::SnapshotRequest(
    ::_pbi::ConstantInitialized) {}
struct SnapshotRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotRequestDefaultTypeInternal() {}
  union {
    SnapshotRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SnapshotResponse::SnapshotResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blob_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.remaining_bytes_)*/ ::uint64_t{0u}
} {}
struct SnapshotResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotResponseDefaultTypeInternal() {}
  union {
    SnapshotResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotResponseDefaultTypeInternal _SnapshotResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WatchRequest::WatchRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_union_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct WatchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WatchRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WatchRequestDefaultTypeInternal() {}
  union {
    WatchRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WatchRequestDefaultTypeInternal _WatchRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WatchCreateRequest::WatchCreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filters_)*/ {}
  , /*decltype(_impl_._filters_cached_byte_size_)*/ { 0 }

  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.range_end_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.watch_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.progress_notify_)*/ false

  , /*decltype(_impl_.prev_kv_)*/ false

  , /*decltype(_impl_.fragment_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WatchCreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WatchCreateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WatchCreateRequestDefaultTypeInternal() {}
  union {
    WatchCreateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WatchCreateRequestDefaultTypeInternal _WatchCreateRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WatchCancelRequest::WatchCancelRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.watch_id_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WatchCancelRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WatchCancelRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WatchCancelRequestDefaultTypeInternal() {}
  union {
    WatchCancelRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WatchCancelRequestDefaultTypeInternal _WatchCancelRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WatchProgressRequest::WatchProgressRequest(
    ::_pbi::ConstantInitialized) {}
struct WatchProgressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WatchProgressRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WatchProgressRequestDefaultTypeInternal() {}
  union {
    WatchProgressRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WatchProgressRequestDefaultTypeInternal _WatchProgressRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR WatchResponse::WatchResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.events_)*/{}
  , /*decltype(_impl_.cancel_reason_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.watch_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.compact_revision_)*/ ::int64_t{0}

  , /*decltype(_impl_.created_)*/ false

  , /*decltype(_impl_.canceled_)*/ false

  , /*decltype(_impl_.fragment_)*/ false
} {}
struct WatchResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WatchResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WatchResponseDefaultTypeInternal() {}
  union {
    WatchResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WatchResponseDefaultTypeInternal _WatchResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseGrantRequest::LeaseGrantRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ttl_)*/ ::int64_t{0}

  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseGrantRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseGrantRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseGrantRequestDefaultTypeInternal() {}
  union {
    LeaseGrantRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseGrantRequestDefaultTypeInternal _LeaseGrantRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseGrantResponse::LeaseGrantResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.ttl_)*/ ::int64_t{0}
} {}
struct LeaseGrantResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseGrantResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseGrantResponseDefaultTypeInternal() {}
  union {
    LeaseGrantResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseGrantResponseDefaultTypeInternal _LeaseGrantResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseRevokeRequest::LeaseRevokeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseRevokeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseRevokeRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseRevokeRequestDefaultTypeInternal() {}
  union {
    LeaseRevokeRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseRevokeRequestDefaultTypeInternal _LeaseRevokeRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseRevokeResponse::LeaseRevokeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct LeaseRevokeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseRevokeResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseRevokeResponseDefaultTypeInternal() {}
  union {
    LeaseRevokeResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseRevokeResponseDefaultTypeInternal _LeaseRevokeResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseCheckpoint::LeaseCheckpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.remaining_ttl_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseCheckpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseCheckpointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseCheckpointDefaultTypeInternal() {}
  union {
    LeaseCheckpoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseCheckpointDefaultTypeInternal _LeaseCheckpoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseCheckpointRequest::LeaseCheckpointRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.checkpoints_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseCheckpointRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseCheckpointRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseCheckpointRequestDefaultTypeInternal() {}
  union {
    LeaseCheckpointRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseCheckpointRequestDefaultTypeInternal _LeaseCheckpointRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseCheckpointResponse::LeaseCheckpointResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct LeaseCheckpointResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseCheckpointResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseCheckpointResponseDefaultTypeInternal() {}
  union {
    LeaseCheckpointResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseCheckpointResponseDefaultTypeInternal _LeaseCheckpointResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseKeepAliveRequest::LeaseKeepAliveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseKeepAliveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseKeepAliveRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseKeepAliveRequestDefaultTypeInternal() {}
  union {
    LeaseKeepAliveRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseKeepAliveRequestDefaultTypeInternal _LeaseKeepAliveRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseKeepAliveResponse::LeaseKeepAliveResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.ttl_)*/ ::int64_t{0}
} {}
struct LeaseKeepAliveResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseKeepAliveResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseKeepAliveResponseDefaultTypeInternal() {}
  union {
    LeaseKeepAliveResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseKeepAliveResponseDefaultTypeInternal _LeaseKeepAliveResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseTimeToLiveRequest::LeaseTimeToLiveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.keys_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseTimeToLiveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseTimeToLiveRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseTimeToLiveRequestDefaultTypeInternal() {}
  union {
    LeaseTimeToLiveRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseTimeToLiveRequestDefaultTypeInternal _LeaseTimeToLiveRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseTimeToLiveResponse::LeaseTimeToLiveResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.ttl_)*/ ::int64_t{0}

  , /*decltype(_impl_.grantedttl_)*/ ::int64_t{0}
} {}
struct LeaseTimeToLiveResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseTimeToLiveResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseTimeToLiveResponseDefaultTypeInternal() {}
  union {
    LeaseTimeToLiveResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseTimeToLiveResponseDefaultTypeInternal _LeaseTimeToLiveResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseLeasesRequest::LeaseLeasesRequest(
    ::_pbi::ConstantInitialized) {}
struct LeaseLeasesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseLeasesRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseLeasesRequestDefaultTypeInternal() {}
  union {
    LeaseLeasesRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseLeasesRequestDefaultTypeInternal _LeaseLeasesRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseStatus::LeaseStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseStatusDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseStatusDefaultTypeInternal() {}
  union {
    LeaseStatus _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseStatusDefaultTypeInternal _LeaseStatus_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeaseLeasesResponse::LeaseLeasesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.leases_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct LeaseLeasesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseLeasesResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseLeasesResponseDefaultTypeInternal() {}
  union {
    LeaseLeasesResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseLeasesResponseDefaultTypeInternal _LeaseLeasesResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Member::Member(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peerurls_)*/{}
  , /*decltype(_impl_.clienturls_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.islearner_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberDefaultTypeInternal() {}
  union {
    Member _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberDefaultTypeInternal _Member_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberAddRequest::MemberAddRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peerurls_)*/{}
  , /*decltype(_impl_.islearner_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemberAddRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberAddRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberAddRequestDefaultTypeInternal() {}
  union {
    MemberAddRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberAddRequestDefaultTypeInternal _MemberAddRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberAddResponse::MemberAddResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.member_)*/nullptr} {}
struct MemberAddResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberAddResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberAddResponseDefaultTypeInternal() {}
  union {
    MemberAddResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberAddResponseDefaultTypeInternal _MemberAddResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberRemoveRequest::MemberRemoveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemberRemoveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberRemoveRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberRemoveRequestDefaultTypeInternal() {}
  union {
    MemberRemoveRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberRemoveRequestDefaultTypeInternal _MemberRemoveRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberRemoveResponse::MemberRemoveResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct MemberRemoveResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberRemoveResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberRemoveResponseDefaultTypeInternal() {}
  union {
    MemberRemoveResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberRemoveResponseDefaultTypeInternal _MemberRemoveResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberUpdateRequest::MemberUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peerurls_)*/{}
  , /*decltype(_impl_.id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemberUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberUpdateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberUpdateRequestDefaultTypeInternal() {}
  union {
    MemberUpdateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberUpdateRequestDefaultTypeInternal _MemberUpdateRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberUpdateResponse::MemberUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct MemberUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberUpdateResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberUpdateResponseDefaultTypeInternal() {}
  union {
    MemberUpdateResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberUpdateResponseDefaultTypeInternal _MemberUpdateResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberListRequest::MemberListRequest(
    ::_pbi::ConstantInitialized) {}
struct MemberListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberListRequestDefaultTypeInternal() {}
  union {
    MemberListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberListRequestDefaultTypeInternal _MemberListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberListResponse::MemberListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct MemberListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberListResponseDefaultTypeInternal() {}
  union {
    MemberListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberListResponseDefaultTypeInternal _MemberListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberPromoteRequest::MemberPromoteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemberPromoteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberPromoteRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberPromoteRequestDefaultTypeInternal() {}
  union {
    MemberPromoteRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberPromoteRequestDefaultTypeInternal _MemberPromoteRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MemberPromoteResponse::MemberPromoteResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct MemberPromoteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemberPromoteResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemberPromoteResponseDefaultTypeInternal() {}
  union {
    MemberPromoteResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemberPromoteResponseDefaultTypeInternal _MemberPromoteResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DefragmentRequest::DefragmentRequest(
    ::_pbi::ConstantInitialized) {}
struct DefragmentRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefragmentRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefragmentRequestDefaultTypeInternal() {}
  union {
    DefragmentRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefragmentRequestDefaultTypeInternal _DefragmentRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DefragmentResponse::DefragmentResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct DefragmentResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefragmentResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefragmentResponseDefaultTypeInternal() {}
  union {
    DefragmentResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefragmentResponseDefaultTypeInternal _DefragmentResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MoveLeaderRequest::MoveLeaderRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.targetid_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveLeaderRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveLeaderRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveLeaderRequestDefaultTypeInternal() {}
  union {
    MoveLeaderRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveLeaderRequestDefaultTypeInternal _MoveLeaderRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MoveLeaderResponse::MoveLeaderResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct MoveLeaderResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveLeaderResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveLeaderResponseDefaultTypeInternal() {}
  union {
    MoveLeaderResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveLeaderResponseDefaultTypeInternal _MoveLeaderResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AlarmRequest::AlarmRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.memberid_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.action_)*/ 0

  , /*decltype(_impl_.alarm_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AlarmRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlarmRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlarmRequestDefaultTypeInternal() {}
  union {
    AlarmRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlarmRequestDefaultTypeInternal _AlarmRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AlarmMember::AlarmMember(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.memberid_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.alarm_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AlarmMemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlarmMemberDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlarmMemberDefaultTypeInternal() {}
  union {
    AlarmMember _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlarmMemberDefaultTypeInternal _AlarmMember_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AlarmResponse::AlarmResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alarms_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AlarmResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlarmResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlarmResponseDefaultTypeInternal() {}
  union {
    AlarmResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlarmResponseDefaultTypeInternal _AlarmResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatusRequest::StatusRequest(
    ::_pbi::ConstantInitialized) {}
struct StatusRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusRequestDefaultTypeInternal() {}
  union {
    StatusRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StatusResponse::StatusResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.errors_)*/{}
  , /*decltype(_impl_.version_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.dbsize_)*/ ::int64_t{0}

  , /*decltype(_impl_.leader_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.raftindex_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.raftterm_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.raftappliedindex_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.dbsizeinuse_)*/ ::int64_t{0}

  , /*decltype(_impl_.islearner_)*/ false
} {}
struct StatusResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusResponseDefaultTypeInternal() {}
  union {
    StatusResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthEnableRequest::AuthEnableRequest(
    ::_pbi::ConstantInitialized) {}
struct AuthEnableRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthEnableRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthEnableRequestDefaultTypeInternal() {}
  union {
    AuthEnableRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthEnableRequestDefaultTypeInternal _AuthEnableRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthDisableRequest::AuthDisableRequest(
    ::_pbi::ConstantInitialized) {}
struct AuthDisableRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthDisableRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthDisableRequestDefaultTypeInternal() {}
  union {
    AuthDisableRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthDisableRequestDefaultTypeInternal _AuthDisableRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthenticateRequest::AuthenticateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.password_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthenticateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticateRequestDefaultTypeInternal() {}
  union {
    AuthenticateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticateRequestDefaultTypeInternal _AuthenticateRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserAddRequest::AuthUserAddRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.password_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.options_)*/nullptr} {}
struct AuthUserAddRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserAddRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserAddRequestDefaultTypeInternal() {}
  union {
    AuthUserAddRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserAddRequestDefaultTypeInternal _AuthUserAddRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserGetRequest::AuthUserGetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthUserGetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserGetRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserGetRequestDefaultTypeInternal() {}
  union {
    AuthUserGetRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserGetRequestDefaultTypeInternal _AuthUserGetRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserDeleteRequest::AuthUserDeleteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthUserDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserDeleteRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserDeleteRequestDefaultTypeInternal() {}
  union {
    AuthUserDeleteRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserDeleteRequestDefaultTypeInternal _AuthUserDeleteRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserChangePasswordRequest::AuthUserChangePasswordRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.password_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthUserChangePasswordRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserChangePasswordRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserChangePasswordRequestDefaultTypeInternal() {}
  union {
    AuthUserChangePasswordRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserChangePasswordRequestDefaultTypeInternal _AuthUserChangePasswordRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserGrantRoleRequest::AuthUserGrantRoleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.role_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthUserGrantRoleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserGrantRoleRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserGrantRoleRequestDefaultTypeInternal() {}
  union {
    AuthUserGrantRoleRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserGrantRoleRequestDefaultTypeInternal _AuthUserGrantRoleRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserRevokeRoleRequest::AuthUserRevokeRoleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.role_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthUserRevokeRoleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserRevokeRoleRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserRevokeRoleRequestDefaultTypeInternal() {}
  union {
    AuthUserRevokeRoleRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserRevokeRoleRequestDefaultTypeInternal _AuthUserRevokeRoleRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleAddRequest::AuthRoleAddRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthRoleAddRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleAddRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleAddRequestDefaultTypeInternal() {}
  union {
    AuthRoleAddRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleAddRequestDefaultTypeInternal _AuthRoleAddRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleGetRequest::AuthRoleGetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.role_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthRoleGetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleGetRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleGetRequestDefaultTypeInternal() {}
  union {
    AuthRoleGetRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleGetRequestDefaultTypeInternal _AuthRoleGetRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserListRequest::AuthUserListRequest(
    ::_pbi::ConstantInitialized) {}
struct AuthUserListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserListRequestDefaultTypeInternal() {}
  union {
    AuthUserListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserListRequestDefaultTypeInternal _AuthUserListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleListRequest::AuthRoleListRequest(
    ::_pbi::ConstantInitialized) {}
struct AuthRoleListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleListRequestDefaultTypeInternal() {}
  union {
    AuthRoleListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleListRequestDefaultTypeInternal _AuthRoleListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleDeleteRequest::AuthRoleDeleteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.role_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthRoleDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleDeleteRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleDeleteRequestDefaultTypeInternal() {}
  union {
    AuthRoleDeleteRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleDeleteRequestDefaultTypeInternal _AuthRoleDeleteRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleGrantPermissionRequest::AuthRoleGrantPermissionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.perm_)*/nullptr} {}
struct AuthRoleGrantPermissionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleGrantPermissionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleGrantPermissionRequestDefaultTypeInternal() {}
  union {
    AuthRoleGrantPermissionRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleGrantPermissionRequestDefaultTypeInternal _AuthRoleGrantPermissionRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleRevokePermissionRequest::AuthRoleRevokePermissionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.role_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.range_end_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthRoleRevokePermissionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleRevokePermissionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleRevokePermissionRequestDefaultTypeInternal() {}
  union {
    AuthRoleRevokePermissionRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleRevokePermissionRequestDefaultTypeInternal _AuthRoleRevokePermissionRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthEnableResponse::AuthEnableResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthEnableResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthEnableResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthEnableResponseDefaultTypeInternal() {}
  union {
    AuthEnableResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthEnableResponseDefaultTypeInternal _AuthEnableResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthDisableResponse::AuthDisableResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthDisableResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthDisableResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthDisableResponseDefaultTypeInternal() {}
  union {
    AuthDisableResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthDisableResponseDefaultTypeInternal _AuthDisableResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthenticateResponse::AuthenticateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthenticateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticateResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticateResponseDefaultTypeInternal() {}
  union {
    AuthenticateResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticateResponseDefaultTypeInternal _AuthenticateResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserAddResponse::AuthUserAddResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserAddResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserAddResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserAddResponseDefaultTypeInternal() {}
  union {
    AuthUserAddResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserAddResponseDefaultTypeInternal _AuthUserAddResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserGetResponse::AuthUserGetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roles_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserGetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserGetResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserGetResponseDefaultTypeInternal() {}
  union {
    AuthUserGetResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserGetResponseDefaultTypeInternal _AuthUserGetResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserDeleteResponse::AuthUserDeleteResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserDeleteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserDeleteResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserDeleteResponseDefaultTypeInternal() {}
  union {
    AuthUserDeleteResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserDeleteResponseDefaultTypeInternal _AuthUserDeleteResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserChangePasswordResponse::AuthUserChangePasswordResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserChangePasswordResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserChangePasswordResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserChangePasswordResponseDefaultTypeInternal() {}
  union {
    AuthUserChangePasswordResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserChangePasswordResponseDefaultTypeInternal _AuthUserChangePasswordResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserGrantRoleResponse::AuthUserGrantRoleResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserGrantRoleResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserGrantRoleResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserGrantRoleResponseDefaultTypeInternal() {}
  union {
    AuthUserGrantRoleResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserGrantRoleResponseDefaultTypeInternal _AuthUserGrantRoleResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserRevokeRoleResponse::AuthUserRevokeRoleResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserRevokeRoleResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserRevokeRoleResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserRevokeRoleResponseDefaultTypeInternal() {}
  union {
    AuthUserRevokeRoleResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserRevokeRoleResponseDefaultTypeInternal _AuthUserRevokeRoleResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleAddResponse::AuthRoleAddResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleAddResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleAddResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleAddResponseDefaultTypeInternal() {}
  union {
    AuthRoleAddResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleAddResponseDefaultTypeInternal _AuthRoleAddResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleGetResponse::AuthRoleGetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.perm_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleGetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleGetResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleGetResponseDefaultTypeInternal() {}
  union {
    AuthRoleGetResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleGetResponseDefaultTypeInternal _AuthRoleGetResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleListResponse::AuthRoleListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roles_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleListResponseDefaultTypeInternal() {}
  union {
    AuthRoleListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleListResponseDefaultTypeInternal _AuthRoleListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthUserListResponse::AuthUserListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.users_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthUserListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthUserListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthUserListResponseDefaultTypeInternal() {}
  union {
    AuthUserListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthUserListResponseDefaultTypeInternal _AuthUserListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleDeleteResponse::AuthRoleDeleteResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleDeleteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleDeleteResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleDeleteResponseDefaultTypeInternal() {}
  union {
    AuthRoleDeleteResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleDeleteResponseDefaultTypeInternal _AuthRoleDeleteResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleGrantPermissionResponse::AuthRoleGrantPermissionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleGrantPermissionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleGrantPermissionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleGrantPermissionResponseDefaultTypeInternal() {}
  union {
    AuthRoleGrantPermissionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleGrantPermissionResponseDefaultTypeInternal _AuthRoleGrantPermissionResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthRoleRevokePermissionResponse::AuthRoleRevokePermissionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct AuthRoleRevokePermissionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthRoleRevokePermissionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthRoleRevokePermissionResponseDefaultTypeInternal() {}
  union {
    AuthRoleRevokePermissionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthRoleRevokePermissionResponseDefaultTypeInternal _AuthRoleRevokePermissionResponse_default_instance_;
}  // namespace etcdserverpb
static ::_pb::Metadata file_level_metadata_rpc_2eproto[91];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_rpc_2eproto[7];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_rpc_2eproto = nullptr;
const ::uint32_t TableStruct_rpc_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseHeader, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseHeader, _impl_.cluster_id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseHeader, _impl_.member_id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseHeader, _impl_.revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseHeader, _impl_.raft_term_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.sort_order_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.sort_target_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.serializable_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.keys_only_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.count_only_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.min_mod_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.max_mod_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.min_create_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeRequest, _impl_.max_create_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _impl_.kvs_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _impl_.more_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RangeResponse, _impl_.count_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.lease_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.prev_kv_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.ignore_value_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutRequest, _impl_.ignore_lease_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::PutResponse, _impl_.prev_kv_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeRequest, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeRequest, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeRequest, _impl_.prev_kv_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeResponse, _impl_.deleted_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DeleteRangeResponse, _impl_.prev_kvs_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RequestOp, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RequestOp, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RequestOp, _impl_.request_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseOp, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseOp, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseOp, _impl_.response_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_.result_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_.target_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_.key_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_.target_union_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnRequest, _impl_.compare_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnRequest, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnRequest, _impl_.failure_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnResponse, _impl_.succeeded_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::TxnResponse, _impl_.responses_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionRequest, _impl_.revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionRequest, _impl_.physical_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::CompactionResponse, _impl_.header_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVRequest, _impl_.revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVResponse, _impl_.hash_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashKVResponse, _impl_.compact_revision_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::HashResponse, _impl_.hash_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotResponse, _impl_.remaining_bytes_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::SnapshotResponse, _impl_.blob_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchRequest, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchRequest, _impl_.request_union_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.start_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.progress_notify_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.filters_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.prev_kv_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.watch_id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCreateRequest, _impl_.fragment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCancelRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchCancelRequest, _impl_.watch_id_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchProgressRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.watch_id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.created_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.canceled_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.compact_revision_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.cancel_reason_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.fragment_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchResponse, _impl_.events_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantRequest, _impl_.ttl_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _impl_.ttl_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseGrantResponse, _impl_.error_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseRevokeRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseRevokeRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseRevokeResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseRevokeResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseRevokeResponse, _impl_.header_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpoint, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpoint, _impl_.remaining_ttl_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpointRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpointRequest, _impl_.checkpoints_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpointResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpointResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseCheckpointResponse, _impl_.header_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveResponse, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseKeepAliveResponse, _impl_.ttl_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveRequest, _impl_.keys_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_.ttl_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_.grantedttl_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseTimeToLiveResponse, _impl_.keys_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseLeasesRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseStatus, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseStatus, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseLeasesResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseLeasesResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseLeasesResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::LeaseLeasesResponse, _impl_.leases_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _impl_.peerurls_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _impl_.clienturls_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Member, _impl_.islearner_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddRequest, _impl_.peerurls_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddRequest, _impl_.islearner_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddResponse, _impl_.member_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberAddResponse, _impl_.members_),
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberRemoveResponse, _impl_.members_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateRequest, _impl_.peerurls_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberUpdateResponse, _impl_.members_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberListResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberListResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberListResponse, _impl_.members_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MemberPromoteResponse, _impl_.members_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DefragmentRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DefragmentResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DefragmentResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::DefragmentResponse, _impl_.header_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MoveLeaderRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MoveLeaderRequest, _impl_.targetid_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MoveLeaderResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MoveLeaderResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::MoveLeaderResponse, _impl_.header_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmRequest, _impl_.action_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmRequest, _impl_.memberid_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmRequest, _impl_.alarm_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmMember, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmMember, _impl_.memberid_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmMember, _impl_.alarm_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AlarmResponse, _impl_.alarms_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.version_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.dbsize_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.leader_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.raftindex_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.raftterm_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.raftappliedindex_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.errors_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.dbsizeinuse_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::StatusResponse, _impl_.islearner_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthEnableRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthDisableRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateRequest, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateRequest, _impl_.password_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddRequest, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddRequest, _impl_.password_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddRequest, _impl_.options_),
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetRequest, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserDeleteRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserDeleteRequest, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordRequest, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordRequest, _impl_.password_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleRequest, _impl_.user_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleRequest, _impl_.role_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleRequest, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleRequest, _impl_.role_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleAddRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleAddRequest, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetRequest, _impl_.role_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleDeleteRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleDeleteRequest, _impl_.role_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionRequest, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionRequest, _impl_.perm_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionRequest, _impl_.role_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionRequest, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionRequest, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthEnableResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthEnableResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthEnableResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthDisableResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthDisableResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthDisableResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthenticateResponse, _impl_.token_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserAddResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGetResponse, _impl_.roles_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserDeleteResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserDeleteResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserDeleteResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserChangePasswordResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserGrantRoleResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserRevokeRoleResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleAddResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleAddResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleAddResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGetResponse, _impl_.perm_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleListResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleListResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleListResponse, _impl_.roles_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserListResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserListResponse, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthUserListResponse, _impl_.users_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleDeleteResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleDeleteResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleDeleteResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleGrantPermissionResponse, _impl_.header_),
    0,
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::AuthRoleRevokePermissionResponse, _impl_.header_),
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::etcdserverpb::ResponseHeader)},
        { 12, -1, -1, sizeof(::etcdserverpb::RangeRequest)},
        { 33, 45, -1, sizeof(::etcdserverpb::RangeResponse)},
        { 49, -1, -1, sizeof(::etcdserverpb::PutRequest)},
        { 63, 73, -1, sizeof(::etcdserverpb::PutResponse)},
        { 75, -1, -1, sizeof(::etcdserverpb::DeleteRangeRequest)},
        { 86, 97, -1, sizeof(::etcdserverpb::DeleteRangeResponse)},
        { 100, -1, -1, sizeof(::etcdserverpb::RequestOp)},
        { 113, -1, -1, sizeof(::etcdserverpb::ResponseOp)},
        { 126, -1, -1, sizeof(::etcdserverpb::Compare)},
        { 144, -1, -1, sizeof(::etcdserverpb::TxnRequest)},
        { 155, 166, -1, sizeof(::etcdserverpb::TxnResponse)},
        { 169, -1, -1, sizeof(::etcdserverpb::CompactionRequest)},
        { 179, 188, -1, sizeof(::etcdserverpb::CompactionResponse)},
        { 189, -1, -1, sizeof(::etcdserverpb::HashRequest)},
        { 197, -1, -1, sizeof(::etcdserverpb::HashKVRequest)},
        { 206, 217, -1, sizeof(::etcdserverpb::HashKVResponse)},
        { 220, 230, -1, sizeof(::etcdserverpb::HashResponse)},
        { 232, -1, -1, sizeof(::etcdserverpb::SnapshotRequest)},
        { 240, 251, -1, sizeof(::etcdserverpb::SnapshotResponse)},
        { 254, -1, -1, sizeof(::etcdserverpb::WatchRequest)},
        { 266, -1, -1, sizeof(::etcdserverpb::WatchCreateRequest)},
        { 282, -1, -1, sizeof(::etcdserverpb::WatchCancelRequest)},
        { 291, -1, -1, sizeof(::etcdserverpb::WatchProgressRequest)},
        { 299, 315, -1, sizeof(::etcdserverpb::WatchResponse)},
        { 323, -1, -1, sizeof(::etcdserverpb::LeaseGrantRequest)},
        { 333, 345, -1, sizeof(::etcdserverpb::LeaseGrantResponse)},
        { 349, -1, -1, sizeof(::etcdserverpb::LeaseRevokeRequest)},
        { 358, 367, -1, sizeof(::etcdserverpb::LeaseRevokeResponse)},
        { 368, -1, -1, sizeof(::etcdserverpb::LeaseCheckpoint)},
        { 378, -1, -1, sizeof(::etcdserverpb::LeaseCheckpointRequest)},
        { 387, 396, -1, sizeof(::etcdserverpb::LeaseCheckpointResponse)},
        { 397, -1, -1, sizeof(::etcdserverpb::LeaseKeepAliveRequest)},
        { 406, 417, -1, sizeof(::etcdserverpb::LeaseKeepAliveResponse)},
        { 420, -1, -1, sizeof(::etcdserverpb::LeaseTimeToLiveRequest)},
        { 430, 443, -1, sizeof(::etcdserverpb::LeaseTimeToLiveResponse)},
        { 448, -1, -1, sizeof(::etcdserverpb::LeaseLeasesRequest)},
        { 456, -1, -1, sizeof(::etcdserverpb::LeaseStatus)},
        { 465, 475, -1, sizeof(::etcdserverpb::LeaseLeasesResponse)},
        { 477, -1, -1, sizeof(::etcdserverpb::Member)},
        { 490, -1, -1, sizeof(::etcdserverpb::MemberAddRequest)},
        { 500, 511, -1, sizeof(::etcdserverpb::MemberAddResponse)},
        { 514, -1, -1, sizeof(::etcdserverpb::MemberRemoveRequest)},
        { 523, 533, -1, sizeof(::etcdserverpb::MemberRemoveResponse)},
        { 535, -1, -1, sizeof(::etcdserverpb::MemberUpdateRequest)},
        { 545, 555, -1, sizeof(::etcdserverpb::MemberUpdateResponse)},
        { 557, -1, -1, sizeof(::etcdserverpb::MemberListRequest)},
        { 565, 575, -1, sizeof(::etcdserverpb::MemberListResponse)},
        { 577, -1, -1, sizeof(::etcdserverpb::MemberPromoteRequest)},
        { 586, 596, -1, sizeof(::etcdserverpb::MemberPromoteResponse)},
        { 598, -1, -1, sizeof(::etcdserverpb::DefragmentRequest)},
        { 606, 615, -1, sizeof(::etcdserverpb::DefragmentResponse)},
        { 616, -1, -1, sizeof(::etcdserverpb::MoveLeaderRequest)},
        { 625, 634, -1, sizeof(::etcdserverpb::MoveLeaderResponse)},
        { 635, -1, -1, sizeof(::etcdserverpb::AlarmRequest)},
        { 646, -1, -1, sizeof(::etcdserverpb::AlarmMember)},
        { 656, 666, -1, sizeof(::etcdserverpb::AlarmResponse)},
        { 668, -1, -1, sizeof(::etcdserverpb::StatusRequest)},
        { 676, 694, -1, sizeof(::etcdserverpb::StatusResponse)},
        { 704, -1, -1, sizeof(::etcdserverpb::AuthEnableRequest)},
        { 712, -1, -1, sizeof(::etcdserverpb::AuthDisableRequest)},
        { 720, -1, -1, sizeof(::etcdserverpb::AuthenticateRequest)},
        { 730, 741, -1, sizeof(::etcdserverpb::AuthUserAddRequest)},
        { 744, -1, -1, sizeof(::etcdserverpb::AuthUserGetRequest)},
        { 753, -1, -1, sizeof(::etcdserverpb::AuthUserDeleteRequest)},
        { 762, -1, -1, sizeof(::etcdserverpb::AuthUserChangePasswordRequest)},
        { 772, -1, -1, sizeof(::etcdserverpb::AuthUserGrantRoleRequest)},
        { 782, -1, -1, sizeof(::etcdserverpb::AuthUserRevokeRoleRequest)},
        { 792, -1, -1, sizeof(::etcdserverpb::AuthRoleAddRequest)},
        { 801, -1, -1, sizeof(::etcdserverpb::AuthRoleGetRequest)},
        { 810, -1, -1, sizeof(::etcdserverpb::AuthUserListRequest)},
        { 818, -1, -1, sizeof(::etcdserverpb::AuthRoleListRequest)},
        { 826, -1, -1, sizeof(::etcdserverpb::AuthRoleDeleteRequest)},
        { 835, 845, -1, sizeof(::etcdserverpb::AuthRoleGrantPermissionRequest)},
        { 847, -1, -1, sizeof(::etcdserverpb::AuthRoleRevokePermissionRequest)},
        { 858, 867, -1, sizeof(::etcdserverpb::AuthEnableResponse)},
        { 868, 877, -1, sizeof(::etcdserverpb::AuthDisableResponse)},
        { 878, 888, -1, sizeof(::etcdserverpb::AuthenticateResponse)},
        { 890, 899, -1, sizeof(::etcdserverpb::AuthUserAddResponse)},
        { 900, 910, -1, sizeof(::etcdserverpb::AuthUserGetResponse)},
        { 912, 921, -1, sizeof(::etcdserverpb::AuthUserDeleteResponse)},
        { 922, 931, -1, sizeof(::etcdserverpb::AuthUserChangePasswordResponse)},
        { 932, 941, -1, sizeof(::etcdserverpb::AuthUserGrantRoleResponse)},
        { 942, 951, -1, sizeof(::etcdserverpb::AuthUserRevokeRoleResponse)},
        { 952, 961, -1, sizeof(::etcdserverpb::AuthRoleAddResponse)},
        { 962, 972, -1, sizeof(::etcdserverpb::AuthRoleGetResponse)},
        { 974, 984, -1, sizeof(::etcdserverpb::AuthRoleListResponse)},
        { 986, 996, -1, sizeof(::etcdserverpb::AuthUserListResponse)},
        { 998, 1007, -1, sizeof(::etcdserverpb::AuthRoleDeleteResponse)},
        { 1008, 1017, -1, sizeof(::etcdserverpb::AuthRoleGrantPermissionResponse)},
        { 1018, 1027, -1, sizeof(::etcdserverpb::AuthRoleRevokePermissionResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::etcdserverpb::_ResponseHeader_default_instance_._instance,
    &::etcdserverpb::_RangeRequest_default_instance_._instance,
    &::etcdserverpb::_RangeResponse_default_instance_._instance,
    &::etcdserverpb::_PutRequest_default_instance_._instance,
    &::etcdserverpb::_PutResponse_default_instance_._instance,
    &::etcdserverpb::_DeleteRangeRequest_default_instance_._instance,
    &::etcdserverpb::_DeleteRangeResponse_default_instance_._instance,
    &::etcdserverpb::_RequestOp_default_instance_._instance,
    &::etcdserverpb::_ResponseOp_default_instance_._instance,
    &::etcdserverpb::_Compare_default_instance_._instance,
    &::etcdserverpb::_TxnRequest_default_instance_._instance,
    &::etcdserverpb::_TxnResponse_default_instance_._instance,
    &::etcdserverpb::_CompactionRequest_default_instance_._instance,
    &::etcdserverpb::_CompactionResponse_default_instance_._instance,
    &::etcdserverpb::_HashRequest_default_instance_._instance,
    &::etcdserverpb::_HashKVRequest_default_instance_._instance,
    &::etcdserverpb::_HashKVResponse_default_instance_._instance,
    &::etcdserverpb::_HashResponse_default_instance_._instance,
    &::etcdserverpb::_SnapshotRequest_default_instance_._instance,
    &::etcdserverpb::_SnapshotResponse_default_instance_._instance,
    &::etcdserverpb::_WatchRequest_default_instance_._instance,
    &::etcdserverpb::_WatchCreateRequest_default_instance_._instance,
    &::etcdserverpb::_WatchCancelRequest_default_instance_._instance,
    &::etcdserverpb::_WatchProgressRequest_default_instance_._instance,
    &::etcdserverpb::_WatchResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseGrantRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseGrantResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseRevokeRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseRevokeResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseCheckpoint_default_instance_._instance,
    &::etcdserverpb::_LeaseCheckpointRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseCheckpointResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseKeepAliveRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseKeepAliveResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseTimeToLiveRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseTimeToLiveResponse_default_instance_._instance,
    &::etcdserverpb::_LeaseLeasesRequest_default_instance_._instance,
    &::etcdserverpb::_LeaseStatus_default_instance_._instance,
    &::etcdserverpb::_LeaseLeasesResponse_default_instance_._instance,
    &::etcdserverpb::_Member_default_instance_._instance,
    &::etcdserverpb::_MemberAddRequest_default_instance_._instance,
    &::etcdserverpb::_MemberAddResponse_default_instance_._instance,
    &::etcdserverpb::_MemberRemoveRequest_default_instance_._instance,
    &::etcdserverpb::_MemberRemoveResponse_default_instance_._instance,
    &::etcdserverpb::_MemberUpdateRequest_default_instance_._instance,
    &::etcdserverpb::_MemberUpdateResponse_default_instance_._instance,
    &::etcdserverpb::_MemberListRequest_default_instance_._instance,
    &::etcdserverpb::_MemberListResponse_default_instance_._instance,
    &::etcdserverpb::_MemberPromoteRequest_default_instance_._instance,
    &::etcdserverpb::_MemberPromoteResponse_default_instance_._instance,
    &::etcdserverpb::_DefragmentRequest_default_instance_._instance,
    &::etcdserverpb::_DefragmentResponse_default_instance_._instance,
    &::etcdserverpb::_MoveLeaderRequest_default_instance_._instance,
    &::etcdserverpb::_MoveLeaderResponse_default_instance_._instance,
    &::etcdserverpb::_AlarmRequest_default_instance_._instance,
    &::etcdserverpb::_AlarmMember_default_instance_._instance,
    &::etcdserverpb::_AlarmResponse_default_instance_._instance,
    &::etcdserverpb::_StatusRequest_default_instance_._instance,
    &::etcdserverpb::_StatusResponse_default_instance_._instance,
    &::etcdserverpb::_AuthEnableRequest_default_instance_._instance,
    &::etcdserverpb::_AuthDisableRequest_default_instance_._instance,
    &::etcdserverpb::_AuthenticateRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserAddRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserGetRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserDeleteRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserChangePasswordRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserGrantRoleRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserRevokeRoleRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleAddRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleGetRequest_default_instance_._instance,
    &::etcdserverpb::_AuthUserListRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleListRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleDeleteRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleGrantPermissionRequest_default_instance_._instance,
    &::etcdserverpb::_AuthRoleRevokePermissionRequest_default_instance_._instance,
    &::etcdserverpb::_AuthEnableResponse_default_instance_._instance,
    &::etcdserverpb::_AuthDisableResponse_default_instance_._instance,
    &::etcdserverpb::_AuthenticateResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserAddResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserGetResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserDeleteResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserChangePasswordResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserGrantRoleResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserRevokeRoleResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleAddResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleGetResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleListResponse_default_instance_._instance,
    &::etcdserverpb::_AuthUserListResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleDeleteResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleGrantPermissionResponse_default_instance_._instance,
    &::etcdserverpb::_AuthRoleRevokePermissionResponse_default_instance_._instance,
};
const char descriptor_table_protodef_rpc_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\trpc.proto\022\014etcdserverpb\032\010kv.proto\032\naut"
    "h.proto\"\\\n\016ResponseHeader\022\022\n\ncluster_id\030"
    "\001 \001(\004\022\021\n\tmember_id\030\002 \001(\004\022\020\n\010revision\030\003 \001"
    "(\003\022\021\n\traft_term\030\004 \001(\004\"\344\003\n\014RangeRequest\022\013"
    "\n\003key\030\001 \001(\014\022\021\n\trange_end\030\002 \001(\014\022\r\n\005limit\030"
    "\003 \001(\003\022\020\n\010revision\030\004 \001(\003\0228\n\nsort_order\030\005 "
    "\001(\0162$.etcdserverpb.RangeRequest.SortOrde"
    "r\022:\n\013sort_target\030\006 \001(\0162%.etcdserverpb.Ra"
    "ngeRequest.SortTarget\022\024\n\014serializable\030\007 "
    "\001(\010\022\021\n\tkeys_only\030\010 \001(\010\022\022\n\ncount_only\030\t \001"
    "(\010\022\030\n\020min_mod_revision\030\n \001(\003\022\030\n\020max_mod_"
    "revision\030\013 \001(\003\022\033\n\023min_create_revision\030\014 "
    "\001(\003\022\033\n\023max_create_revision\030\r \001(\003\".\n\tSort"
    "Order\022\010\n\004NONE\020\000\022\n\n\006ASCEND\020\001\022\013\n\007DESCEND\020\002"
    "\"B\n\nSortTarget\022\007\n\003KEY\020\000\022\013\n\007VERSION\020\001\022\n\n\006"
    "CREATE\020\002\022\007\n\003MOD\020\003\022\t\n\005VALUE\020\004\"y\n\rRangeRes"
    "ponse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Res"
    "ponseHeader\022\035\n\003kvs\030\002 \003(\0132\020.mvccpb.KeyVal"
    "ue\022\014\n\004more\030\003 \001(\010\022\r\n\005count\030\004 \001(\003\"t\n\nPutRe"
    "quest\022\013\n\003key\030\001 \001(\014\022\r\n\005value\030\002 \001(\014\022\r\n\005lea"
    "se\030\003 \001(\003\022\017\n\007prev_kv\030\004 \001(\010\022\024\n\014ignore_valu"
    "e\030\005 \001(\010\022\024\n\014ignore_lease\030\006 \001(\010\"^\n\013PutResp"
    "onse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Resp"
    "onseHeader\022!\n\007prev_kv\030\002 \001(\0132\020.mvccpb.Key"
    "Value\"E\n\022DeleteRangeRequest\022\013\n\003key\030\001 \001(\014"
    "\022\021\n\trange_end\030\002 \001(\014\022\017\n\007prev_kv\030\003 \001(\010\"x\n\023"
    "DeleteRangeResponse\022,\n\006header\030\001 \001(\0132\034.et"
    "cdserverpb.ResponseHeader\022\017\n\007deleted\030\002 \001"
    "(\003\022\"\n\010prev_kvs\030\003 \003(\0132\020.mvccpb.KeyValue\"\357"
    "\001\n\tRequestOp\0223\n\rrequest_range\030\001 \001(\0132\032.et"
    "cdserverpb.RangeRequestH\000\022/\n\013request_put"
    "\030\002 \001(\0132\030.etcdserverpb.PutRequestH\000\022@\n\024re"
    "quest_delete_range\030\003 \001(\0132 .etcdserverpb."
    "DeleteRangeRequestH\000\022/\n\013request_txn\030\004 \001("
    "\0132\030.etcdserverpb.TxnRequestH\000B\t\n\007request"
    "\"\371\001\n\nResponseOp\0225\n\016response_range\030\001 \001(\0132"
    "\033.etcdserverpb.RangeResponseH\000\0221\n\014respon"
    "se_put\030\002 \001(\0132\031.etcdserverpb.PutResponseH"
    "\000\022B\n\025response_delete_range\030\003 \001(\0132!.etcds"
    "erverpb.DeleteRangeResponseH\000\0221\n\014respons"
    "e_txn\030\004 \001(\0132\031.etcdserverpb.TxnResponseH\000"
    "B\n\n\010response\"\226\003\n\007Compare\0223\n\006result\030\001 \001(\016"
    "2#.etcdserverpb.Compare.CompareResult\0223\n"
    "\006target\030\002 \001(\0162#.etcdserverpb.Compare.Com"
    "pareTarget\022\013\n\003key\030\003 \001(\014\022\021\n\007version\030\004 \001(\003"
    "H\000\022\031\n\017create_revision\030\005 \001(\003H\000\022\026\n\014mod_rev"
    "ision\030\006 \001(\003H\000\022\017\n\005value\030\007 \001(\014H\000\022\017\n\005lease\030"
    "\010 \001(\003H\000\022\021\n\trange_end\030@ \001(\014\"@\n\rCompareRes"
    "ult\022\t\n\005EQUAL\020\000\022\013\n\007GREATER\020\001\022\010\n\004LESS\020\002\022\r\n"
    "\tNOT_EQUAL\020\003\"G\n\rCompareTarget\022\013\n\007VERSION"
    "\020\000\022\n\n\006CREATE\020\001\022\007\n\003MOD\020\002\022\t\n\005VALUE\020\003\022\t\n\005LE"
    "ASE\020\004B\016\n\014target_union\"\210\001\n\nTxnRequest\022&\n\007"
    "compare\030\001 \003(\0132\025.etcdserverpb.Compare\022(\n\007"
    "success\030\002 \003(\0132\027.etcdserverpb.RequestOp\022("
    "\n\007failure\030\003 \003(\0132\027.etcdserverpb.RequestOp"
    "\"{\n\013TxnResponse\022,\n\006header\030\001 \001(\0132\034.etcdse"
    "rverpb.ResponseHeader\022\021\n\tsucceeded\030\002 \001(\010"
    "\022+\n\tresponses\030\003 \003(\0132\030.etcdserverpb.Respo"
    "nseOp\"7\n\021CompactionRequest\022\020\n\010revision\030\001"
    " \001(\003\022\020\n\010physical\030\002 \001(\010\"B\n\022CompactionResp"
    "onse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Resp"
    "onseHeader\"\r\n\013HashRequest\"!\n\rHashKVReque"
    "st\022\020\n\010revision\030\001 \001(\003\"f\n\016HashKVResponse\022,"
    "\n\006header\030\001 \001(\0132\034.etcdserverpb.ResponseHe"
    "ader\022\014\n\004hash\030\002 \001(\r\022\030\n\020compact_revision\030\003"
    " \001(\003\"J\n\014HashResponse\022,\n\006header\030\001 \001(\0132\034.e"
    "tcdserverpb.ResponseHeader\022\014\n\004hash\030\002 \001(\r"
    "\"\021\n\017SnapshotRequest\"g\n\020SnapshotResponse\022"
    ",\n\006header\030\001 \001(\0132\034.etcdserverpb.ResponseH"
    "eader\022\027\n\017remaining_bytes\030\002 \001(\004\022\014\n\004blob\030\003"
    " \001(\014\"\327\001\n\014WatchRequest\022:\n\016create_request\030"
    "\001 \001(\0132 .etcdserverpb.WatchCreateRequestH"
    "\000\022:\n\016cancel_request\030\002 \001(\0132 .etcdserverpb"
    ".WatchCancelRequestH\000\022>\n\020progress_reques"
    "t\030\003 \001(\0132\".etcdserverpb.WatchProgressRequ"
    "estH\000B\017\n\rrequest_union\"\377\001\n\022WatchCreateRe"
    "quest\022\013\n\003key\030\001 \001(\014\022\021\n\trange_end\030\002 \001(\014\022\026\n"
    "\016start_revision\030\003 \001(\003\022\027\n\017progress_notify"
    "\030\004 \001(\010\022<\n\007filters\030\005 \003(\0162+.etcdserverpb.W"
    "atchCreateRequest.FilterType\022\017\n\007prev_kv\030"
    "\006 \001(\010\022\020\n\010watch_id\030\007 \001(\003\022\020\n\010fragment\030\010 \001("
    "\010\"%\n\nFilterType\022\t\n\005NOPUT\020\000\022\014\n\010NODELETE\020\001"
    "\"&\n\022WatchCancelRequest\022\020\n\010watch_id\030\001 \001(\003"
    "\"\026\n\024WatchProgressRequest\"\324\001\n\rWatchRespon"
    "se\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Respon"
    "seHeader\022\020\n\010watch_id\030\002 \001(\003\022\017\n\007created\030\003 "
    "\001(\010\022\020\n\010canceled\030\004 \001(\010\022\030\n\020compact_revisio"
    "n\030\005 \001(\003\022\025\n\rcancel_reason\030\006 \001(\t\022\020\n\010fragme"
    "nt\030\007 \001(\010\022\035\n\006events\030\013 \003(\0132\r.mvccpb.Event\""
    ",\n\021LeaseGrantRequest\022\013\n\003TTL\030\001 \001(\003\022\n\n\002ID\030"
    "\002 \001(\003\"j\n\022LeaseGrantResponse\022,\n\006header\030\001 "
    "\001(\0132\034.etcdserverpb.ResponseHeader\022\n\n\002ID\030"
    "\002 \001(\003\022\013\n\003TTL\030\003 \001(\003\022\r\n\005error\030\004 \001(\t\" \n\022Lea"
    "seRevokeRequest\022\n\n\002ID\030\001 \001(\003\"C\n\023LeaseRevo"
    "keResponse\022,\n\006header\030\001 \001(\0132\034.etcdserverp"
    "b.ResponseHeader\"4\n\017LeaseCheckpoint\022\n\n\002I"
    "D\030\001 \001(\003\022\025\n\rremaining_TTL\030\002 \001(\003\"L\n\026LeaseC"
    "heckpointRequest\0222\n\013checkpoints\030\001 \003(\0132\035."
    "etcdserverpb.LeaseCheckpoint\"G\n\027LeaseChe"
    "ckpointResponse\022,\n\006header\030\001 \001(\0132\034.etcdse"
    "rverpb.ResponseHeader\"#\n\025LeaseKeepAliveR"
    "equest\022\n\n\002ID\030\001 \001(\003\"_\n\026LeaseKeepAliveResp"
    "onse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Resp"
    "onseHeader\022\n\n\002ID\030\002 \001(\003\022\013\n\003TTL\030\003 \001(\003\"2\n\026L"
    "easeTimeToLiveRequest\022\n\n\002ID\030\001 \001(\003\022\014\n\004key"
    "s\030\002 \001(\010\"\202\001\n\027LeaseTimeToLiveResponse\022,\n\006h"
    "eader\030\001 \001(\0132\034.etcdserverpb.ResponseHeade"
    "r\022\n\n\002ID\030\002 \001(\003\022\013\n\003TTL\030\003 \001(\003\022\022\n\ngrantedTTL"
    "\030\004 \001(\003\022\014\n\004keys\030\005 \003(\014\"\024\n\022LeaseLeasesReque"
    "st\"\031\n\013LeaseStatus\022\n\n\002ID\030\001 \001(\003\"n\n\023LeaseLe"
    "asesResponse\022,\n\006header\030\001 \001(\0132\034.etcdserve"
    "rpb.ResponseHeader\022)\n\006leases\030\002 \003(\0132\031.etc"
    "dserverpb.LeaseStatus\"[\n\006Member\022\n\n\002ID\030\001 "
    "\001(\004\022\014\n\004name\030\002 \001(\t\022\020\n\010peerURLs\030\003 \003(\t\022\022\n\nc"
    "lientURLs\030\004 \003(\t\022\021\n\tisLearner\030\005 \001(\010\"7\n\020Me"
    "mberAddRequest\022\020\n\010peerURLs\030\001 \003(\t\022\021\n\tisLe"
    "arner\030\002 \001(\010\"\216\001\n\021MemberAddResponse\022,\n\006hea"
    "der\030\001 \001(\0132\034.etcdserverpb.ResponseHeader\022"
    "$\n\006member\030\002 \001(\0132\024.etcdserverpb.Member\022%\n"
    "\007members\030\003 \003(\0132\024.etcdserverpb.Member\"!\n\023"
    "MemberRemoveRequest\022\n\n\002ID\030\001 \001(\004\"k\n\024Membe"
    "rRemoveResponse\022,\n\006header\030\001 \001(\0132\034.etcdse"
    "rverpb.ResponseHeader\022%\n\007members\030\002 \003(\0132\024"
    ".etcdserverpb.Member\"3\n\023MemberUpdateRequ"
    "est\022\n\n\002ID\030\001 \001(\004\022\020\n\010peerURLs\030\002 \003(\t\"k\n\024Mem"
    "berUpdateResponse\022,\n\006header\030\001 \001(\0132\034.etcd"
    "serverpb.ResponseHeader\022%\n\007members\030\002 \003(\013"
    "2\024.etcdserverpb.Member\"\023\n\021MemberListRequ"
    "est\"i\n\022MemberListResponse\022,\n\006header\030\001 \001("
    "\0132\034.etcdserverpb.ResponseHeader\022%\n\007membe"
    "rs\030\002 \003(\0132\024.etcdserverpb.Member\"\"\n\024Member"
    "PromoteRequest\022\n\n\002ID\030\001 \001(\004\"l\n\025MemberProm"
    "oteResponse\022,\n\006header\030\001 \001(\0132\034.etcdserver"
    "pb.ResponseHeader\022%\n\007members\030\002 \003(\0132\024.etc"
    "dserverpb.Member\"\023\n\021DefragmentRequest\"B\n"
    "\022DefragmentResponse\022,\n\006header\030\001 \001(\0132\034.et"
    "cdserverpb.ResponseHeader\"%\n\021MoveLeaderR"
    "equest\022\020\n\010targetID\030\001 \001(\004\"B\n\022MoveLeaderRe"
    "sponse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Re"
    "sponseHeader\"\266\001\n\014AlarmRequest\0226\n\006action\030"
    "\001 \001(\0162&.etcdserverpb.AlarmRequest.AlarmA"
    "ction\022\020\n\010memberID\030\002 \001(\004\022&\n\005alarm\030\003 \001(\0162\027"
    ".etcdserverpb.AlarmType\"4\n\013AlarmAction\022\007"
    "\n\003GET\020\000\022\014\n\010ACTIVATE\020\001\022\016\n\nDEACTIVATE\020\002\"G\n"
    "\013AlarmMember\022\020\n\010memberID\030\001 \001(\004\022&\n\005alarm\030"
    "\002 \001(\0162\027.etcdserverpb.AlarmType\"h\n\rAlarmR"
    "esponse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.R"
    "esponseHeader\022)\n\006alarms\030\002 \003(\0132\031.etcdserv"
    "erpb.AlarmMember\"\017\n\rStatusRequest\"\346\001\n\016St"
    "atusResponse\022,\n\006header\030\001 \001(\0132\034.etcdserve"
    "rpb.ResponseHeader\022\017\n\007version\030\002 \001(\t\022\016\n\006d"
    "bSize\030\003 \001(\003\022\016\n\006leader\030\004 \001(\004\022\021\n\traftIndex"
    "\030\005 \001(\004\022\020\n\010raftTerm\030\006 \001(\004\022\030\n\020raftAppliedI"
    "ndex\030\007 \001(\004\022\016\n\006errors\030\010 \003(\t\022\023\n\013dbSizeInUs"
    "e\030\t \001(\003\022\021\n\tisLearner\030\n \001(\010\"\023\n\021AuthEnable"
    "Request\"\024\n\022AuthDisableRequest\"5\n\023Authent"
    "icateRequest\022\014\n\004name\030\001 \001(\t\022\020\n\010password\030\002"
    " \001(\t\"]\n\022AuthUserAddRequest\022\014\n\004name\030\001 \001(\t"
    "\022\020\n\010password\030\002 \001(\t\022\'\n\007options\030\003 \001(\0132\026.au"
    "thpb.UserAddOptions\"\"\n\022AuthUserGetReques"
    "t\022\014\n\004name\030\001 \001(\t\"%\n\025AuthUserDeleteRequest"
    "\022\014\n\004name\030\001 \001(\t\"\?\n\035AuthUserChangePassword"
    "Request\022\014\n\004name\030\001 \001(\t\022\020\n\010password\030\002 \001(\t\""
    "6\n\030AuthUserGrantRoleRequest\022\014\n\004user\030\001 \001("
    "\t\022\014\n\004role\030\002 \001(\t\"7\n\031AuthUserRevokeRoleReq"
    "uest\022\014\n\004name\030\001 \001(\t\022\014\n\004role\030\002 \001(\t\"\"\n\022Auth"
    "RoleAddRequest\022\014\n\004name\030\001 \001(\t\"\"\n\022AuthRole"
    "GetRequest\022\014\n\004role\030\001 \001(\t\"\025\n\023AuthUserList"
    "Request\"\025\n\023AuthRoleListRequest\"%\n\025AuthRo"
    "leDeleteRequest\022\014\n\004role\030\001 \001(\t\"P\n\036AuthRol"
    "eGrantPermissionRequest\022\014\n\004name\030\001 \001(\t\022 \n"
    "\004perm\030\002 \001(\0132\022.authpb.Permission\"O\n\037AuthR"
    "oleRevokePermissionRequest\022\014\n\004role\030\001 \001(\t"
    "\022\013\n\003key\030\002 \001(\014\022\021\n\trange_end\030\003 \001(\014\"B\n\022Auth"
    "EnableResponse\022,\n\006header\030\001 \001(\0132\034.etcdser"
    "verpb.ResponseHeader\"C\n\023AuthDisableRespo"
    "nse\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Respo"
    "nseHeader\"S\n\024AuthenticateResponse\022,\n\006hea"
    "der\030\001 \001(\0132\034.etcdserverpb.ResponseHeader\022"
    "\r\n\005token\030\002 \001(\t\"C\n\023AuthUserAddResponse\022,\n"
    "\006header\030\001 \001(\0132\034.etcdserverpb.ResponseHea"
    "der\"R\n\023AuthUserGetResponse\022,\n\006header\030\001 \001"
    "(\0132\034.etcdserverpb.ResponseHeader\022\r\n\005role"
    "s\030\002 \003(\t\"F\n\026AuthUserDeleteResponse\022,\n\006hea"
    "der\030\001 \001(\0132\034.etcdserverpb.ResponseHeader\""
    "N\n\036AuthUserChangePasswordResponse\022,\n\006hea"
    "der\030\001 \001(\0132\034.etcdserverpb.ResponseHeader\""
    "I\n\031AuthUserGrantRoleResponse\022,\n\006header\030\001"
    " \001(\0132\034.etcdserverpb.ResponseHeader\"J\n\032Au"
    "thUserRevokeRoleResponse\022,\n\006header\030\001 \001(\013"
    "2\034.etcdserverpb.ResponseHeader\"C\n\023AuthRo"
    "leAddResponse\022,\n\006header\030\001 \001(\0132\034.etcdserv"
    "erpb.ResponseHeader\"e\n\023AuthRoleGetRespon"
    "se\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Respon"
    "seHeader\022 \n\004perm\030\002 \003(\0132\022.authpb.Permissi"
    "on\"S\n\024AuthRoleListResponse\022,\n\006header\030\001 \001"
    "(\0132\034.etcdserverpb.ResponseHeader\022\r\n\005role"
    "s\030\002 \003(\t\"S\n\024AuthUserListResponse\022,\n\006heade"
    "r\030\001 \001(\0132\034.etcdserverpb.ResponseHeader\022\r\n"
    "\005users\030\002 \003(\t\"F\n\026AuthRoleDeleteResponse\022,"
    "\n\006header\030\001 \001(\0132\034.etcdserverpb.ResponseHe"
    "ader\"O\n\037AuthRoleGrantPermissionResponse\022"
    ",\n\006header\030\001 \001(\0132\034.etcdserverpb.ResponseH"
    "eader\"P\n AuthRoleRevokePermissionRespons"
    "e\022,\n\006header\030\001 \001(\0132\034.etcdserverpb.Respons"
    "eHeader*/\n\tAlarmType\022\010\n\004NONE\020\000\022\013\n\007NOSPAC"
    "E\020\001\022\013\n\007CORRUPT\020\0022\352\002\n\002KV\022B\n\005Range\022\032.etcds"
    "erverpb.RangeRequest\032\033.etcdserverpb.Rang"
    "eResponse\"\000\022<\n\003Put\022\030.etcdserverpb.PutReq"
    "uest\032\031.etcdserverpb.PutResponse\"\000\022T\n\013Del"
    "eteRange\022 .etcdserverpb.DeleteRangeReque"
    "st\032!.etcdserverpb.DeleteRangeResponse\"\000\022"
    "<\n\003Txn\022\030.etcdserverpb.TxnRequest\032\031.etcds"
    "erverpb.TxnResponse\"\000\022N\n\007Compact\022\037.etcds"
    "erverpb.CompactionRequest\032 .etcdserverpb"
    ".CompactionResponse\"\0002O\n\005Watch\022F\n\005Watch\022"
    "\032.etcdserverpb.WatchRequest\032\033.etcdserver"
    "pb.WatchResponse\"\000(\0010\0012\313\003\n\005Lease\022Q\n\nLeas"
    "eGrant\022\037.etcdserverpb.LeaseGrantRequest\032"
    " .etcdserverpb.LeaseGrantResponse\"\000\022T\n\013L"
    "easeRevoke\022 .etcdserverpb.LeaseRevokeReq"
    "uest\032!.etcdserverpb.LeaseRevokeResponse\""
    "\000\022a\n\016LeaseKeepAlive\022#.etcdserverpb.Lease"
    "KeepAliveRequest\032$.etcdserverpb.LeaseKee"
    "pAliveResponse\"\000(\0010\001\022`\n\017LeaseTimeToLive\022"
    "$.etcdserverpb.LeaseTimeToLiveRequest\032%."
    "etcdserverpb.LeaseTimeToLiveResponse\"\000\022T"
    "\n\013LeaseLeases\022 .etcdserverpb.LeaseLeases"
    "Request\032!.etcdserverpb.LeaseLeasesRespon"
    "se\"\0002\272\003\n\007Cluster\022N\n\tMemberAdd\022\036.etcdserv"
    "erpb.MemberAddRequest\032\037.etcdserverpb.Mem"
    "berAddResponse\"\000\022W\n\014MemberRemove\022!.etcds"
    "erverpb.MemberRemoveRequest\032\".etcdserver"
    "pb.MemberRemoveResponse\"\000\022W\n\014MemberUpdat"
    "e\022!.etcdserverpb.MemberUpdateRequest\032\".e"
    "tcdserverpb.MemberUpdateResponse\"\000\022Q\n\nMe"
    "mberList\022\037.etcdserverpb.MemberListReques"
    "t\032 .etcdserverpb.MemberListResponse\"\000\022Z\n"
    "\rMemberPromote\022\".etcdserverpb.MemberProm"
    "oteRequest\032#.etcdserverpb.MemberPromoteR"
    "esponse\"\0002\225\004\n\013Maintenance\022B\n\005Alarm\022\032.etc"
    "dserverpb.AlarmRequest\032\033.etcdserverpb.Al"
    "armResponse\"\000\022E\n\006Status\022\033.etcdserverpb.S"
    "tatusRequest\032\034.etcdserverpb.StatusRespon"
    "se\"\000\022Q\n\nDefragment\022\037.etcdserverpb.Defrag"
    "mentRequest\032 .etcdserverpb.DefragmentRes"
    "ponse\"\000\022\?\n\004Hash\022\031.etcdserverpb.HashReque"
    "st\032\032.etcdserverpb.HashResponse\"\000\022E\n\006Hash"
    "KV\022\033.etcdserverpb.HashKVRequest\032\034.etcdse"
    "rverpb.HashKVResponse\"\000\022M\n\010Snapshot\022\035.et"
    "cdserverpb.SnapshotRequest\032\036.etcdserverp"
    "b.SnapshotResponse\"\0000\001\022Q\n\nMoveLeader\022\037.e"
    "tcdserverpb.MoveLeaderRequest\032 .etcdserv"
    "erpb.MoveLeaderResponse\"\0002\335\013\n\004Auth\022Q\n\nAu"
    "thEnable\022\037.etcdserverpb.AuthEnableReques"
    "t\032 .etcdserverpb.AuthEnableResponse\"\000\022T\n"
    "\013AuthDisable\022 .etcdserverpb.AuthDisableR"
    "equest\032!.etcdserverpb.AuthDisableRespons"
    "e\"\000\022W\n\014Authenticate\022!.etcdserverpb.Authe"
    "nticateRequest\032\".etcdserverpb.Authentica"
    "teResponse\"\000\022P\n\007UserAdd\022 .etcdserverpb.A"
    "uthUserAddRequest\032!.etcdserverpb.AuthUse"
    "rAddResponse\"\000\022P\n\007UserGet\022 .etcdserverpb"
    ".AuthUserGetRequest\032!.etcdserverpb.AuthU"
    "serGetResponse\"\000\022S\n\010UserList\022!.etcdserve"
    "rpb.AuthUserListRequest\032\".etcdserverpb.A"
    "uthUserListResponse\"\000\022Y\n\nUserDelete\022#.et"
    "cdserverpb.AuthUserDeleteRequest\032$.etcds"
    "erverpb.AuthUserDeleteResponse\"\000\022q\n\022User"
    "ChangePassword\022+.etcdserverpb.AuthUserCh"
    "angePasswordRequest\032,.etcdserverpb.AuthU"
    "serChangePasswordResponse\"\000\022b\n\rUserGrant"
    "Role\022&.etcdserverpb.AuthUserGrantRoleReq"
    "uest\032\'.etcdserverpb.AuthUserGrantRoleRes"
    "ponse\"\000\022e\n\016UserRevokeRole\022\'.etcdserverpb"
    ".AuthUserRevokeRoleRequest\032(.etcdserverp"
    "b.AuthUserRevokeRoleResponse\"\000\022P\n\007RoleAd"
    "d\022 .etcdserverpb.AuthRoleAddRequest\032!.et"
    "cdserverpb.AuthRoleAddResponse\"\000\022P\n\007Role"
    "Get\022 .etcdserverpb.AuthRoleGetRequest\032!."
    "etcdserverpb.AuthRoleGetResponse\"\000\022S\n\010Ro"
    "leList\022!.etcdserverpb.AuthRoleListReques"
    "t\032\".etcdserverpb.AuthRoleListResponse\"\000\022"
    "Y\n\nRoleDelete\022#.etcdserverpb.AuthRoleDel"
    "eteRequest\032$.etcdserverpb.AuthRoleDelete"
    "Response\"\000\022t\n\023RoleGrantPermission\022,.etcd"
    "serverpb.AuthRoleGrantPermissionRequest\032"
    "-.etcdserverpb.AuthRoleGrantPermissionRe"
    "sponse\"\000\022w\n\024RoleRevokePermission\022-.etcds"
    "erverpb.AuthRoleRevokePermissionRequest\032"
    "..etcdserverpb.AuthRoleRevokePermissionR"
    "esponse\"\000b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_rpc_2eproto_deps[2] =
    {
        &::descriptor_table_auth_2eproto,
        &::descriptor_table_kv_2eproto,
};
static ::absl::once_flag descriptor_table_rpc_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_rpc_2eproto = {
    false,
    false,
    11657,
    descriptor_table_protodef_rpc_2eproto,
    "rpc.proto",
    &descriptor_table_rpc_2eproto_once,
    descriptor_table_rpc_2eproto_deps,
    2,
    91,
    schemas,
    file_default_instances,
    TableStruct_rpc_2eproto::offsets,
    file_level_metadata_rpc_2eproto,
    file_level_enum_descriptors_rpc_2eproto,
    file_level_service_descriptors_rpc_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_rpc_2eproto_getter() {
  return &descriptor_table_rpc_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_rpc_2eproto(&descriptor_table_rpc_2eproto);
namespace etcdserverpb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RangeRequest_SortOrder_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[0];
}
bool RangeRequest_SortOrder_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr RangeRequest_SortOrder RangeRequest::NONE;
constexpr RangeRequest_SortOrder RangeRequest::ASCEND;
constexpr RangeRequest_SortOrder RangeRequest::DESCEND;
constexpr RangeRequest_SortOrder RangeRequest::SortOrder_MIN;
constexpr RangeRequest_SortOrder RangeRequest::SortOrder_MAX;
constexpr int RangeRequest::SortOrder_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RangeRequest_SortTarget_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[1];
}
bool RangeRequest_SortTarget_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr RangeRequest_SortTarget RangeRequest::KEY;
constexpr RangeRequest_SortTarget RangeRequest::VERSION;
constexpr RangeRequest_SortTarget RangeRequest::CREATE;
constexpr RangeRequest_SortTarget RangeRequest::MOD;
constexpr RangeRequest_SortTarget RangeRequest::VALUE;
constexpr RangeRequest_SortTarget RangeRequest::SortTarget_MIN;
constexpr RangeRequest_SortTarget RangeRequest::SortTarget_MAX;
constexpr int RangeRequest::SortTarget_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Compare_CompareResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[2];
}
bool Compare_CompareResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Compare_CompareResult Compare::EQUAL;
constexpr Compare_CompareResult Compare::GREATER;
constexpr Compare_CompareResult Compare::LESS;
constexpr Compare_CompareResult Compare::NOT_EQUAL;
constexpr Compare_CompareResult Compare::CompareResult_MIN;
constexpr Compare_CompareResult Compare::CompareResult_MAX;
constexpr int Compare::CompareResult_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Compare_CompareTarget_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[3];
}
bool Compare_CompareTarget_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Compare_CompareTarget Compare::VERSION;
constexpr Compare_CompareTarget Compare::CREATE;
constexpr Compare_CompareTarget Compare::MOD;
constexpr Compare_CompareTarget Compare::VALUE;
constexpr Compare_CompareTarget Compare::LEASE;
constexpr Compare_CompareTarget Compare::CompareTarget_MIN;
constexpr Compare_CompareTarget Compare::CompareTarget_MAX;
constexpr int Compare::CompareTarget_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WatchCreateRequest_FilterType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[4];
}
bool WatchCreateRequest_FilterType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr WatchCreateRequest_FilterType WatchCreateRequest::NOPUT;
constexpr WatchCreateRequest_FilterType WatchCreateRequest::NODELETE;
constexpr WatchCreateRequest_FilterType WatchCreateRequest::FilterType_MIN;
constexpr WatchCreateRequest_FilterType WatchCreateRequest::FilterType_MAX;
constexpr int WatchCreateRequest::FilterType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlarmRequest_AlarmAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[5];
}
bool AlarmRequest_AlarmAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr AlarmRequest_AlarmAction AlarmRequest::GET;
constexpr AlarmRequest_AlarmAction AlarmRequest::ACTIVATE;
constexpr AlarmRequest_AlarmAction AlarmRequest::DEACTIVATE;
constexpr AlarmRequest_AlarmAction AlarmRequest::AlarmAction_MIN;
constexpr AlarmRequest_AlarmAction AlarmRequest::AlarmAction_MAX;
constexpr int AlarmRequest::AlarmAction_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlarmType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rpc_2eproto);
  return file_level_enum_descriptors_rpc_2eproto[6];
}
bool AlarmType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class ResponseHeader::_Internal {
 public:
};

ResponseHeader::ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.ResponseHeader)
}
ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.ResponseHeader)
}

inline void ResponseHeader::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cluster_id_) { ::uint64_t{0u} }

    , decltype(_impl_.member_id_) { ::uint64_t{0u} }

    , decltype(_impl_.revision_) { ::int64_t{0} }

    , decltype(_impl_.raft_term_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:etcdserverpb.ResponseHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseHeader::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.ResponseHeader)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.cluster_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.raft_term_) -
      reinterpret_cast<char*>(&_impl_.cluster_id_)) + sizeof(_impl_.raft_term_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 cluster_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.cluster_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 member_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.member_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 raft_term = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.raft_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ResponseHeader::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.ResponseHeader)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 cluster_id = 1;
  if (this->_internal_cluster_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_cluster_id(), target);
  }

  // uint64 member_id = 2;
  if (this->_internal_member_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_member_id(), target);
  }

  // int64 revision = 3;
  if (this->_internal_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_revision(), target);
  }

  // uint64 raft_term = 4;
  if (this->_internal_raft_term() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_raft_term(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.ResponseHeader)
  return target;
}

::size_t ResponseHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.ResponseHeader)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 cluster_id = 1;
  if (this->_internal_cluster_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_cluster_id());
  }

  // uint64 member_id = 2;
  if (this->_internal_member_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_member_id());
  }

  // int64 revision = 3;
  if (this->_internal_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_revision());
  }

  // uint64 raft_term = 4;
  if (this->_internal_raft_term() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_raft_term());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseHeader::GetClassData() const { return &_class_data_; }


void ResponseHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseHeader*>(&to_msg);
  auto& from = static_cast<const ResponseHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.ResponseHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cluster_id() != 0) {
    _this->_internal_set_cluster_id(from._internal_cluster_id());
  }
  if (from._internal_member_id() != 0) {
    _this->_internal_set_member_id(from._internal_member_id());
  }
  if (from._internal_revision() != 0) {
    _this->_internal_set_revision(from._internal_revision());
  }
  if (from._internal_raft_term() != 0) {
    _this->_internal_set_raft_term(from._internal_raft_term());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.ResponseHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {
  return true;
}

void ResponseHeader::InternalSwap(ResponseHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseHeader, _impl_.raft_term_)
      + sizeof(ResponseHeader::_impl_.raft_term_)
      - PROTOBUF_FIELD_OFFSET(ResponseHeader, _impl_.cluster_id_)>(
          reinterpret_cast<char*>(&_impl_.cluster_id_),
          reinterpret_cast<char*>(&other->_impl_.cluster_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[0]);
}
// ===================================================================

class RangeRequest::_Internal {
 public:
};

RangeRequest::RangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.RangeRequest)
}
RangeRequest::RangeRequest(const RangeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.limit_) {}

    , decltype(_impl_.revision_) {}

    , decltype(_impl_.sort_order_) {}

    , decltype(_impl_.sort_target_) {}

    , decltype(_impl_.min_mod_revision_) {}

    , decltype(_impl_.max_mod_revision_) {}

    , decltype(_impl_.min_create_revision_) {}

    , decltype(_impl_.max_create_revision_) {}

    , decltype(_impl_.serializable_) {}

    , decltype(_impl_.keys_only_) {}

    , decltype(_impl_.count_only_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.limit_, &from._impl_.limit_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.count_only_) -
    reinterpret_cast<char*>(&_impl_.limit_)) + sizeof(_impl_.count_only_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.RangeRequest)
}

inline void RangeRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.limit_) { ::int64_t{0} }

    , decltype(_impl_.revision_) { ::int64_t{0} }

    , decltype(_impl_.sort_order_) { 0 }

    , decltype(_impl_.sort_target_) { 0 }

    , decltype(_impl_.min_mod_revision_) { ::int64_t{0} }

    , decltype(_impl_.max_mod_revision_) { ::int64_t{0} }

    , decltype(_impl_.min_create_revision_) { ::int64_t{0} }

    , decltype(_impl_.max_create_revision_) { ::int64_t{0} }

    , decltype(_impl_.serializable_) { false }

    , decltype(_impl_.keys_only_) { false }

    , decltype(_impl_.count_only_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RangeRequest::~RangeRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.RangeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
}

void RangeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.RangeRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  ::memset(&_impl_.limit_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_only_) -
      reinterpret_cast<char*>(&_impl_.limit_)) + sizeof(_impl_.count_only_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes range_end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 limit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 revision = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_sort_order(static_cast<::etcdserverpb::RangeRequest_SortOrder>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_sort_target(static_cast<::etcdserverpb::RangeRequest_SortTarget>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool serializable = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.serializable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keys_only = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.keys_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool count_only = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.count_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 min_mod_revision = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.min_mod_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 max_mod_revision = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.max_mod_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 min_create_revision = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.min_create_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 max_create_revision = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.max_create_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RangeRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.RangeRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    const std::string& _s = this->_internal_range_end();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // int64 limit = 3;
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_limit(), target);
  }

  // int64 revision = 4;
  if (this->_internal_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_revision(), target);
  }

  // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;
  if (this->_internal_sort_order() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_sort_order(), target);
  }

  // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;
  if (this->_internal_sort_target() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_sort_target(), target);
  }

  // bool serializable = 7;
  if (this->_internal_serializable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_serializable(), target);
  }

  // bool keys_only = 8;
  if (this->_internal_keys_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_keys_only(), target);
  }

  // bool count_only = 9;
  if (this->_internal_count_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_count_only(), target);
  }

  // int64 min_mod_revision = 10;
  if (this->_internal_min_mod_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        10, this->_internal_min_mod_revision(), target);
  }

  // int64 max_mod_revision = 11;
  if (this->_internal_max_mod_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        11, this->_internal_max_mod_revision(), target);
  }

  // int64 min_create_revision = 12;
  if (this->_internal_min_create_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        12, this->_internal_min_create_revision(), target);
  }

  // int64 max_create_revision = 13;
  if (this->_internal_max_create_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        13, this->_internal_max_create_revision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.RangeRequest)
  return target;
}

::size_t RangeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.RangeRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_range_end());
  }

  // int64 limit = 3;
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_limit());
  }

  // int64 revision = 4;
  if (this->_internal_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_revision());
  }

  // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;
  if (this->_internal_sort_order() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_sort_order());
  }

  // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;
  if (this->_internal_sort_target() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_sort_target());
  }

  // int64 min_mod_revision = 10;
  if (this->_internal_min_mod_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_min_mod_revision());
  }

  // int64 max_mod_revision = 11;
  if (this->_internal_max_mod_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_max_mod_revision());
  }

  // int64 min_create_revision = 12;
  if (this->_internal_min_create_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_min_create_revision());
  }

  // int64 max_create_revision = 13;
  if (this->_internal_max_create_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_max_create_revision());
  }

  // bool serializable = 7;
  if (this->_internal_serializable() != 0) {
    total_size += 2;
  }

  // bool keys_only = 8;
  if (this->_internal_keys_only() != 0) {
    total_size += 2;
  }

  // bool count_only = 9;
  if (this->_internal_count_only() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeRequest::GetClassData() const { return &_class_data_; }


void RangeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeRequest*>(&to_msg);
  auto& from = static_cast<const RangeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.RangeRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  if (from._internal_revision() != 0) {
    _this->_internal_set_revision(from._internal_revision());
  }
  if (from._internal_sort_order() != 0) {
    _this->_internal_set_sort_order(from._internal_sort_order());
  }
  if (from._internal_sort_target() != 0) {
    _this->_internal_set_sort_target(from._internal_sort_target());
  }
  if (from._internal_min_mod_revision() != 0) {
    _this->_internal_set_min_mod_revision(from._internal_min_mod_revision());
  }
  if (from._internal_max_mod_revision() != 0) {
    _this->_internal_set_max_mod_revision(from._internal_max_mod_revision());
  }
  if (from._internal_min_create_revision() != 0) {
    _this->_internal_set_min_create_revision(from._internal_min_create_revision());
  }
  if (from._internal_max_create_revision() != 0) {
    _this->_internal_set_max_create_revision(from._internal_max_create_revision());
  }
  if (from._internal_serializable() != 0) {
    _this->_internal_set_serializable(from._internal_serializable());
  }
  if (from._internal_keys_only() != 0) {
    _this->_internal_set_keys_only(from._internal_keys_only());
  }
  if (from._internal_count_only() != 0) {
    _this->_internal_set_count_only(from._internal_count_only());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeRequest::CopyFrom(const RangeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.RangeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeRequest::IsInitialized() const {
  return true;
}

void RangeRequest::InternalSwap(RangeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.range_end_, lhs_arena,
                                       &other->_impl_.range_end_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeRequest, _impl_.count_only_)
      + sizeof(RangeRequest::_impl_.count_only_)
      - PROTOBUF_FIELD_OFFSET(RangeRequest, _impl_.limit_)>(
          reinterpret_cast<char*>(&_impl_.limit_),
          reinterpret_cast<char*>(&other->_impl_.limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[1]);
}
// ===================================================================

class RangeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RangeResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RangeResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const RangeResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
RangeResponse::_Internal::header(const RangeResponse* msg) {
  return *msg->_impl_.header_;
}
void RangeResponse::clear_kvs() {
  _internal_mutable_kvs()->Clear();
}
RangeResponse::RangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.RangeResponse)
}
RangeResponse::RangeResponse(const RangeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kvs_){from._impl_.kvs_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.count_) {}

    , decltype(_impl_.more_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.count_, &from._impl_.count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.more_) -
    reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.more_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.RangeResponse)
}

inline void RangeResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.count_) { ::int64_t{0} }

    , decltype(_impl_.more_) { false }

  };
}

RangeResponse::~RangeResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.RangeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_kvs()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RangeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.RangeResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_kvs()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.more_) -
      reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.more_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .mvccpb.KeyValue kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool more = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.more_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RangeResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.RangeResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .mvccpb.KeyValue kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool more = 3;
  if (this->_internal_more() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_more(), target);
  }

  // int64 count = 4;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.RangeResponse)
  return target;
}

::size_t RangeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.RangeResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mvccpb.KeyValue kvs = 2;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->_internal_kvs()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 count = 4;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_count());
  }

  // bool more = 3;
  if (this->_internal_more() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeResponse::GetClassData() const { return &_class_data_; }


void RangeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeResponse*>(&to_msg);
  auto& from = static_cast<const RangeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.RangeResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_kvs()->MergeFrom(from._internal_kvs());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  if (from._internal_more() != 0) {
    _this->_internal_set_more(from._internal_more());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeResponse::CopyFrom(const RangeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.RangeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeResponse::IsInitialized() const {
  return true;
}

void RangeResponse::InternalSwap(RangeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_kvs()->InternalSwap(other->_internal_mutable_kvs());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeResponse, _impl_.more_)
      + sizeof(RangeResponse::_impl_.more_)
      - PROTOBUF_FIELD_OFFSET(RangeResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[2]);
}
// ===================================================================

class PutRequest::_Internal {
 public:
};

PutRequest::PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.PutRequest)
}
PutRequest::PutRequest(const PutRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PutRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.lease_) {}

    , decltype(_impl_.prev_kv_) {}

    , decltype(_impl_.ignore_value_) {}

    , decltype(_impl_.ignore_lease_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.lease_, &from._impl_.lease_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ignore_lease_) -
    reinterpret_cast<char*>(&_impl_.lease_)) + sizeof(_impl_.ignore_lease_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.PutRequest)
}

inline void PutRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.lease_) { ::int64_t{0} }

    , decltype(_impl_.prev_kv_) { false }

    , decltype(_impl_.ignore_value_) { false }

    , decltype(_impl_.ignore_lease_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PutRequest::~PutRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.PutRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PutRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void PutRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PutRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.PutRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  ::memset(&_impl_.lease_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ignore_lease_) -
      reinterpret_cast<char*>(&_impl_.lease_)) + sizeof(_impl_.ignore_lease_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PutRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 lease = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.lease_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool prev_kv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool ignore_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.ignore_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool ignore_lease = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.ignore_lease_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PutRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.PutRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes value = 2;
  if (!this->_internal_value().empty()) {
    const std::string& _s = this->_internal_value();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // int64 lease = 3;
  if (this->_internal_lease() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_lease(), target);
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_prev_kv(), target);
  }

  // bool ignore_value = 5;
  if (this->_internal_ignore_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_ignore_value(), target);
  }

  // bool ignore_lease = 6;
  if (this->_internal_ignore_lease() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_ignore_lease(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.PutRequest)
  return target;
}

::size_t PutRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.PutRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_value());
  }

  // int64 lease = 3;
  if (this->_internal_lease() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_lease());
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    total_size += 2;
  }

  // bool ignore_value = 5;
  if (this->_internal_ignore_value() != 0) {
    total_size += 2;
  }

  // bool ignore_lease = 6;
  if (this->_internal_ignore_lease() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PutRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PutRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PutRequest::GetClassData() const { return &_class_data_; }


void PutRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PutRequest*>(&to_msg);
  auto& from = static_cast<const PutRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.PutRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_lease() != 0) {
    _this->_internal_set_lease(from._internal_lease());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  if (from._internal_ignore_value() != 0) {
    _this->_internal_set_ignore_value(from._internal_ignore_value());
  }
  if (from._internal_ignore_lease() != 0) {
    _this->_internal_set_ignore_lease(from._internal_ignore_lease());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PutRequest::CopyFrom(const PutRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.PutRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutRequest::IsInitialized() const {
  return true;
}

void PutRequest::InternalSwap(PutRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena,
                                       &other->_impl_.value_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PutRequest, _impl_.ignore_lease_)
      + sizeof(PutRequest::_impl_.ignore_lease_)
      - PROTOBUF_FIELD_OFFSET(PutRequest, _impl_.lease_)>(
          reinterpret_cast<char*>(&_impl_.lease_),
          reinterpret_cast<char*>(&other->_impl_.lease_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PutRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[3]);
}
// ===================================================================

class PutResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PutResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PutResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const PutResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mvccpb::KeyValue& prev_kv(const PutResponse* msg);
  static void set_has_prev_kv(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::etcdserverpb::ResponseHeader&
PutResponse::_Internal::header(const PutResponse* msg) {
  return *msg->_impl_.header_;
}
const ::mvccpb::KeyValue&
PutResponse::_Internal::prev_kv(const PutResponse* msg) {
  return *msg->_impl_.prev_kv_;
}
void PutResponse::clear_prev_kv() {
  if (_impl_.prev_kv_ != nullptr) _impl_.prev_kv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PutResponse::PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.PutResponse)
}
PutResponse::PutResponse(const PutResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PutResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.prev_kv_ = new ::mvccpb::KeyValue(*from._impl_.prev_kv_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.PutResponse)
}

inline void PutResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}
  };
}

PutResponse::~PutResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.PutResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PutResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.prev_kv_;
}

void PutResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PutResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.PutResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.prev_kv_ != nullptr);
      _impl_.prev_kv_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PutResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .mvccpb.KeyValue prev_kv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prev_kv(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PutResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.PutResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .mvccpb.KeyValue prev_kv = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::prev_kv(this),
        _Internal::prev_kv(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.PutResponse)
  return target;
}

::size_t PutResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.PutResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .etcdserverpb.ResponseHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // .mvccpb.KeyValue prev_kv = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prev_kv_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PutResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PutResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PutResponse::GetClassData() const { return &_class_data_; }


void PutResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PutResponse*>(&to_msg);
  auto& from = static_cast<const PutResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.PutResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_prev_kv()->::mvccpb::KeyValue::MergeFrom(
          from._internal_prev_kv());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PutResponse::CopyFrom(const PutResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.PutResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutResponse::IsInitialized() const {
  return true;
}

void PutResponse::InternalSwap(PutResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PutResponse, _impl_.prev_kv_)
      + sizeof(PutResponse::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(PutResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PutResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[4]);
}
// ===================================================================

class DeleteRangeRequest::_Internal {
 public:
};

DeleteRangeRequest::DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.DeleteRangeRequest)
}
DeleteRangeRequest::DeleteRangeRequest(const DeleteRangeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteRangeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.prev_kv_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), _this->GetArenaForAllocation());
  }
  _this->_impl_.prev_kv_ = from._impl_.prev_kv_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.DeleteRangeRequest)
}

inline void DeleteRangeRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.prev_kv_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteRangeRequest::~DeleteRangeRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.DeleteRangeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteRangeRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
}

void DeleteRangeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteRangeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.DeleteRangeRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  _impl_.prev_kv_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteRangeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes range_end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool prev_kv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeleteRangeRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.DeleteRangeRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    const std::string& _s = this->_internal_range_end();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_prev_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.DeleteRangeRequest)
  return target;
}

::size_t DeleteRangeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.DeleteRangeRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_range_end());
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteRangeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteRangeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteRangeRequest::GetClassData() const { return &_class_data_; }


void DeleteRangeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteRangeRequest*>(&to_msg);
  auto& from = static_cast<const DeleteRangeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.DeleteRangeRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteRangeRequest::CopyFrom(const DeleteRangeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.DeleteRangeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeRequest::IsInitialized() const {
  return true;
}

void DeleteRangeRequest::InternalSwap(DeleteRangeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.range_end_, lhs_arena,
                                       &other->_impl_.range_end_, rhs_arena);

  swap(_impl_.prev_kv_, other->_impl_.prev_kv_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteRangeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[5]);
}
// ===================================================================

class DeleteRangeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteRangeResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DeleteRangeResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const DeleteRangeResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
DeleteRangeResponse::_Internal::header(const DeleteRangeResponse* msg) {
  return *msg->_impl_.header_;
}
void DeleteRangeResponse::clear_prev_kvs() {
  _internal_mutable_prev_kvs()->Clear();
}
DeleteRangeResponse::DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.DeleteRangeResponse)
}
DeleteRangeResponse::DeleteRangeResponse(const DeleteRangeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteRangeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_kvs_){from._impl_.prev_kvs_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.deleted_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.deleted_ = from._impl_.deleted_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.DeleteRangeResponse)
}

inline void DeleteRangeResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.deleted_) { ::int64_t{0} }

  };
}

DeleteRangeResponse::~DeleteRangeResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.DeleteRangeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteRangeResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_prev_kvs()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DeleteRangeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteRangeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.DeleteRangeResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_prev_kvs()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.deleted_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteRangeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 deleted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .mvccpb.KeyValue prev_kvs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prev_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeleteRangeResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.DeleteRangeResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 deleted = 2;
  if (this->_internal_deleted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_deleted(), target);
  }

  // repeated .mvccpb.KeyValue prev_kvs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prev_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_prev_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.DeleteRangeResponse)
  return target;
}

::size_t DeleteRangeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.DeleteRangeResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mvccpb.KeyValue prev_kvs = 3;
  total_size += 1UL * this->_internal_prev_kvs_size();
  for (const auto& msg : this->_internal_prev_kvs()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 deleted = 2;
  if (this->_internal_deleted() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_deleted());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteRangeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteRangeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteRangeResponse::GetClassData() const { return &_class_data_; }


void DeleteRangeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteRangeResponse*>(&to_msg);
  auto& from = static_cast<const DeleteRangeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.DeleteRangeResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_prev_kvs()->MergeFrom(from._internal_prev_kvs());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_deleted() != 0) {
    _this->_internal_set_deleted(from._internal_deleted());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteRangeResponse::CopyFrom(const DeleteRangeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.DeleteRangeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeResponse::IsInitialized() const {
  return true;
}

void DeleteRangeResponse::InternalSwap(DeleteRangeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_prev_kvs()->InternalSwap(other->_internal_mutable_prev_kvs());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeleteRangeResponse, _impl_.deleted_)
      + sizeof(DeleteRangeResponse::_impl_.deleted_)
      - PROTOBUF_FIELD_OFFSET(DeleteRangeResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteRangeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[6]);
}
// ===================================================================

class RequestOp::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::RequestOp, _impl_._oneof_case_);
  static const ::etcdserverpb::RangeRequest& request_range(const RequestOp* msg);
  static const ::etcdserverpb::PutRequest& request_put(const RequestOp* msg);
  static const ::etcdserverpb::DeleteRangeRequest& request_delete_range(const RequestOp* msg);
  static const ::etcdserverpb::TxnRequest& request_txn(const RequestOp* msg);
};

const ::etcdserverpb::RangeRequest&
RequestOp::_Internal::request_range(const RequestOp* msg) {
  return *msg->_impl_.request_.request_range_;
}
const ::etcdserverpb::PutRequest&
RequestOp::_Internal::request_put(const RequestOp* msg) {
  return *msg->_impl_.request_.request_put_;
}
const ::etcdserverpb::DeleteRangeRequest&
RequestOp::_Internal::request_delete_range(const RequestOp* msg) {
  return *msg->_impl_.request_.request_delete_range_;
}
const ::etcdserverpb::TxnRequest&
RequestOp::_Internal::request_txn(const RequestOp* msg) {
  return *msg->_impl_.request_.request_txn_;
}
void RequestOp::set_allocated_request_range(::etcdserverpb::RangeRequest* request_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (request_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_range);
    if (message_arena != submessage_arena) {
      request_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_range, submessage_arena);
    }
    set_has_request_range();
    _impl_.request_.request_range_ = request_range;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RequestOp.request_range)
}
void RequestOp::set_allocated_request_put(::etcdserverpb::PutRequest* request_put) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (request_put) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_put);
    if (message_arena != submessage_arena) {
      request_put = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_put, submessage_arena);
    }
    set_has_request_put();
    _impl_.request_.request_put_ = request_put;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RequestOp.request_put)
}
void RequestOp::set_allocated_request_delete_range(::etcdserverpb::DeleteRangeRequest* request_delete_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (request_delete_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_delete_range);
    if (message_arena != submessage_arena) {
      request_delete_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_delete_range, submessage_arena);
    }
    set_has_request_delete_range();
    _impl_.request_.request_delete_range_ = request_delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RequestOp.request_delete_range)
}
void RequestOp::set_allocated_request_txn(::etcdserverpb::TxnRequest* request_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (request_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_txn);
    if (message_arena != submessage_arena) {
      request_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_txn, submessage_arena);
    }
    set_has_request_txn();
    _impl_.request_.request_txn_ = request_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.RequestOp.request_txn)
}
RequestOp::RequestOp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.RequestOp)
}
RequestOp::RequestOp(const RequestOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_request();
  switch (from.request_case()) {
    case kRequestRange: {
      _this->_internal_mutable_request_range()->::etcdserverpb::RangeRequest::MergeFrom(
          from._internal_request_range());
      break;
    }
    case kRequestPut: {
      _this->_internal_mutable_request_put()->::etcdserverpb::PutRequest::MergeFrom(
          from._internal_request_put());
      break;
    }
    case kRequestDeleteRange: {
      _this->_internal_mutable_request_delete_range()->::etcdserverpb::DeleteRangeRequest::MergeFrom(
          from._internal_request_delete_range());
      break;
    }
    case kRequestTxn: {
      _this->_internal_mutable_request_txn()->::etcdserverpb::TxnRequest::MergeFrom(
          from._internal_request_txn());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.RequestOp)
}

inline void RequestOp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.request_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_request();
}

RequestOp::~RequestOp() {
  // @@protoc_insertion_point(destructor:etcdserverpb.RequestOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestOp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_request()) {
    clear_request();
  }
}

void RequestOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestOp::clear_request() {
// @@protoc_insertion_point(one_of_clear_start:etcdserverpb.RequestOp)
  switch (request_case()) {
    case kRequestRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.request_range_;
      }
      break;
    }
    case kRequestPut: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.request_put_;
      }
      break;
    }
    case kRequestDeleteRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.request_delete_range_;
      }
      break;
    }
    case kRequestTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.request_txn_;
      }
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}


void RequestOp::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.RequestOp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_request();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.RangeRequest request_range = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_range(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.PutRequest request_put = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_put(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.DeleteRangeRequest request_delete_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_delete_range(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.TxnRequest request_txn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_txn(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RequestOp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.RequestOp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (request_case()) {
    case kRequestRange: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::request_range(this),
          _Internal::request_range(this).GetCachedSize(), target, stream);
      break;
    }
    case kRequestPut: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::request_put(this),
          _Internal::request_put(this).GetCachedSize(), target, stream);
      break;
    }
    case kRequestDeleteRange: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::request_delete_range(this),
          _Internal::request_delete_range(this).GetCachedSize(), target, stream);
      break;
    }
    case kRequestTxn: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::request_txn(this),
          _Internal::request_txn(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.RequestOp)
  return target;
}

::size_t RequestOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.RequestOp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (request_case()) {
    // .etcdserverpb.RangeRequest request_range = 1;
    case kRequestRange: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.request_range_);
      break;
    }
    // .etcdserverpb.PutRequest request_put = 2;
    case kRequestPut: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.request_put_);
      break;
    }
    // .etcdserverpb.DeleteRangeRequest request_delete_range = 3;
    case kRequestDeleteRange: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.request_delete_range_);
      break;
    }
    // .etcdserverpb.TxnRequest request_txn = 4;
    case kRequestTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.request_txn_);
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestOp::GetClassData() const { return &_class_data_; }


void RequestOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestOp*>(&to_msg);
  auto& from = static_cast<const RequestOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.RequestOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.request_case()) {
    case kRequestRange: {
      _this->_internal_mutable_request_range()->::etcdserverpb::RangeRequest::MergeFrom(
          from._internal_request_range());
      break;
    }
    case kRequestPut: {
      _this->_internal_mutable_request_put()->::etcdserverpb::PutRequest::MergeFrom(
          from._internal_request_put());
      break;
    }
    case kRequestDeleteRange: {
      _this->_internal_mutable_request_delete_range()->::etcdserverpb::DeleteRangeRequest::MergeFrom(
          from._internal_request_delete_range());
      break;
    }
    case kRequestTxn: {
      _this->_internal_mutable_request_txn()->::etcdserverpb::TxnRequest::MergeFrom(
          from._internal_request_txn());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestOp::CopyFrom(const RequestOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.RequestOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestOp::IsInitialized() const {
  return true;
}

void RequestOp::InternalSwap(RequestOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_, other->_impl_.request_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[7]);
}
// ===================================================================

class ResponseOp::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::ResponseOp, _impl_._oneof_case_);
  static const ::etcdserverpb::RangeResponse& response_range(const ResponseOp* msg);
  static const ::etcdserverpb::PutResponse& response_put(const ResponseOp* msg);
  static const ::etcdserverpb::DeleteRangeResponse& response_delete_range(const ResponseOp* msg);
  static const ::etcdserverpb::TxnResponse& response_txn(const ResponseOp* msg);
};

const ::etcdserverpb::RangeResponse&
ResponseOp::_Internal::response_range(const ResponseOp* msg) {
  return *msg->_impl_.response_.response_range_;
}
const ::etcdserverpb::PutResponse&
ResponseOp::_Internal::response_put(const ResponseOp* msg) {
  return *msg->_impl_.response_.response_put_;
}
const ::etcdserverpb::DeleteRangeResponse&
ResponseOp::_Internal::response_delete_range(const ResponseOp* msg) {
  return *msg->_impl_.response_.response_delete_range_;
}
const ::etcdserverpb::TxnResponse&
ResponseOp::_Internal::response_txn(const ResponseOp* msg) {
  return *msg->_impl_.response_.response_txn_;
}
void ResponseOp::set_allocated_response_range(::etcdserverpb::RangeResponse* response_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (response_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_range);
    if (message_arena != submessage_arena) {
      response_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_range, submessage_arena);
    }
    set_has_response_range();
    _impl_.response_.response_range_ = response_range;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.ResponseOp.response_range)
}
void ResponseOp::set_allocated_response_put(::etcdserverpb::PutResponse* response_put) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (response_put) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_put);
    if (message_arena != submessage_arena) {
      response_put = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_put, submessage_arena);
    }
    set_has_response_put();
    _impl_.response_.response_put_ = response_put;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.ResponseOp.response_put)
}
void ResponseOp::set_allocated_response_delete_range(::etcdserverpb::DeleteRangeResponse* response_delete_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (response_delete_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_delete_range);
    if (message_arena != submessage_arena) {
      response_delete_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_delete_range, submessage_arena);
    }
    set_has_response_delete_range();
    _impl_.response_.response_delete_range_ = response_delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.ResponseOp.response_delete_range)
}
void ResponseOp::set_allocated_response_txn(::etcdserverpb::TxnResponse* response_txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (response_txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_txn);
    if (message_arena != submessage_arena) {
      response_txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_txn, submessage_arena);
    }
    set_has_response_txn();
    _impl_.response_.response_txn_ = response_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.ResponseOp.response_txn)
}
ResponseOp::ResponseOp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.ResponseOp)
}
ResponseOp::ResponseOp(const ResponseOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_response();
  switch (from.response_case()) {
    case kResponseRange: {
      _this->_internal_mutable_response_range()->::etcdserverpb::RangeResponse::MergeFrom(
          from._internal_response_range());
      break;
    }
    case kResponsePut: {
      _this->_internal_mutable_response_put()->::etcdserverpb::PutResponse::MergeFrom(
          from._internal_response_put());
      break;
    }
    case kResponseDeleteRange: {
      _this->_internal_mutable_response_delete_range()->::etcdserverpb::DeleteRangeResponse::MergeFrom(
          from._internal_response_delete_range());
      break;
    }
    case kResponseTxn: {
      _this->_internal_mutable_response_txn()->::etcdserverpb::TxnResponse::MergeFrom(
          from._internal_response_txn());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.ResponseOp)
}

inline void ResponseOp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_response();
}

ResponseOp::~ResponseOp() {
  // @@protoc_insertion_point(destructor:etcdserverpb.ResponseOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseOp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_response()) {
    clear_response();
  }
}

void ResponseOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseOp::clear_response() {
// @@protoc_insertion_point(one_of_clear_start:etcdserverpb.ResponseOp)
  switch (response_case()) {
    case kResponseRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.response_range_;
      }
      break;
    }
    case kResponsePut: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.response_put_;
      }
      break;
    }
    case kResponseDeleteRange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.response_delete_range_;
      }
      break;
    }
    case kResponseTxn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.response_txn_;
      }
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}


void ResponseOp::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.ResponseOp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_response();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.RangeResponse response_range = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_range(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.PutResponse response_put = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_put(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.DeleteRangeResponse response_delete_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_delete_range(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.TxnResponse response_txn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_txn(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ResponseOp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.ResponseOp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (response_case()) {
    case kResponseRange: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::response_range(this),
          _Internal::response_range(this).GetCachedSize(), target, stream);
      break;
    }
    case kResponsePut: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::response_put(this),
          _Internal::response_put(this).GetCachedSize(), target, stream);
      break;
    }
    case kResponseDeleteRange: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::response_delete_range(this),
          _Internal::response_delete_range(this).GetCachedSize(), target, stream);
      break;
    }
    case kResponseTxn: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::response_txn(this),
          _Internal::response_txn(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.ResponseOp)
  return target;
}

::size_t ResponseOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.ResponseOp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (response_case()) {
    // .etcdserverpb.RangeResponse response_range = 1;
    case kResponseRange: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.response_range_);
      break;
    }
    // .etcdserverpb.PutResponse response_put = 2;
    case kResponsePut: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.response_put_);
      break;
    }
    // .etcdserverpb.DeleteRangeResponse response_delete_range = 3;
    case kResponseDeleteRange: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.response_delete_range_);
      break;
    }
    // .etcdserverpb.TxnResponse response_txn = 4;
    case kResponseTxn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.response_txn_);
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseOp::GetClassData() const { return &_class_data_; }


void ResponseOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseOp*>(&to_msg);
  auto& from = static_cast<const ResponseOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.ResponseOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.response_case()) {
    case kResponseRange: {
      _this->_internal_mutable_response_range()->::etcdserverpb::RangeResponse::MergeFrom(
          from._internal_response_range());
      break;
    }
    case kResponsePut: {
      _this->_internal_mutable_response_put()->::etcdserverpb::PutResponse::MergeFrom(
          from._internal_response_put());
      break;
    }
    case kResponseDeleteRange: {
      _this->_internal_mutable_response_delete_range()->::etcdserverpb::DeleteRangeResponse::MergeFrom(
          from._internal_response_delete_range());
      break;
    }
    case kResponseTxn: {
      _this->_internal_mutable_response_txn()->::etcdserverpb::TxnResponse::MergeFrom(
          from._internal_response_txn());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseOp::CopyFrom(const ResponseOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.ResponseOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseOp::IsInitialized() const {
  return true;
}

void ResponseOp::InternalSwap(ResponseOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.response_, other->_impl_.response_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[8]);
}
// ===================================================================

class Compare::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::Compare, _impl_._oneof_case_);
};

Compare::Compare(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.Compare)
}
Compare::Compare(const Compare& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Compare* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.result_) {}

    , decltype(_impl_.target_) {}

    , decltype(_impl_.target_union_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.result_, &from._impl_.result_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.target_) -
    reinterpret_cast<char*>(&_impl_.result_)) + sizeof(_impl_.target_));
  clear_has_target_union();
  switch (from.target_union_case()) {
    case kVersion: {
      _this->_internal_set_version(from._internal_version());
      break;
    }
    case kCreateRevision: {
      _this->_internal_set_create_revision(from._internal_create_revision());
      break;
    }
    case kModRevision: {
      _this->_internal_set_mod_revision(from._internal_mod_revision());
      break;
    }
    case kValue: {
      _this->_internal_set_value(from._internal_value());
      break;
    }
    case kLease: {
      _this->_internal_set_lease(from._internal_lease());
      break;
    }
    case TARGET_UNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.Compare)
}

inline void Compare::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.result_) { 0 }

    , decltype(_impl_.target_) { 0 }

    , decltype(_impl_.target_union_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_target_union();
}

Compare::~Compare() {
  // @@protoc_insertion_point(destructor:etcdserverpb.Compare)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Compare::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
  if (has_target_union()) {
    clear_target_union();
  }
}

void Compare::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Compare::clear_target_union() {
// @@protoc_insertion_point(one_of_clear_start:etcdserverpb.Compare)
  switch (target_union_case()) {
    case kVersion: {
      // No need to clear
      break;
    }
    case kCreateRevision: {
      // No need to clear
      break;
    }
    case kModRevision: {
      // No need to clear
      break;
    }
    case kValue: {
      _impl_.target_union_.value_.Destroy();
      break;
    }
    case kLease: {
      // No need to clear
      break;
    }
    case TARGET_UNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TARGET_UNION_NOT_SET;
}


void Compare::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.Compare)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  ::memset(&_impl_.result_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.target_) -
      reinterpret_cast<char*>(&_impl_.result_)) + sizeof(_impl_.target_));
  clear_target_union();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Compare::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.Compare.CompareResult result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_result(static_cast<::etcdserverpb::Compare_CompareResult>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.Compare.CompareTarget target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_target(static_cast<::etcdserverpb::Compare_CompareTarget>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _internal_set_version(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 create_revision = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _internal_set_create_revision(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 mod_revision = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _internal_set_mod_revision(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 lease = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _internal_set_lease(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes range_end = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Compare::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.Compare)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .etcdserverpb.Compare.CompareResult result = 1;
  if (this->_internal_result() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_result(), target);
  }

  // .etcdserverpb.Compare.CompareTarget target = 2;
  if (this->_internal_target() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_target(), target);
  }

  // bytes key = 3;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  switch (target_union_case()) {
    case kVersion: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          4, this->_internal_version(), target);
      break;
    }
    case kCreateRevision: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          5, this->_internal_create_revision(), target);
      break;
    }
    case kModRevision: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          6, this->_internal_mod_revision(), target);
      break;
    }
    case kValue: {
      const std::string& _s = this->_internal_value();
      target = stream->WriteBytesMaybeAliased(7, _s, target);
      break;
    }
    case kLease: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          8, this->_internal_lease(), target);
      break;
    }
    default: ;
  }
  // bytes range_end = 64;
  if (!this->_internal_range_end().empty()) {
    const std::string& _s = this->_internal_range_end();
    target = stream->WriteBytesMaybeAliased(64, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.Compare)
  return target;
}

::size_t Compare::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.Compare)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 3;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes range_end = 64;
  if (!this->_internal_range_end().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_range_end());
  }

  // .etcdserverpb.Compare.CompareResult result = 1;
  if (this->_internal_result() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
  }

  // .etcdserverpb.Compare.CompareTarget target = 2;
  if (this->_internal_target() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_target());
  }

  switch (target_union_case()) {
    // int64 version = 4;
    case kVersion: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_version());
      break;
    }
    // int64 create_revision = 5;
    case kCreateRevision: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_create_revision());
      break;
    }
    // int64 mod_revision = 6;
    case kModRevision: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_mod_revision());
      break;
    }
    // bytes value = 7;
    case kValue: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_value());
      break;
    }
    // int64 lease = 8;
    case kLease: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lease());
      break;
    }
    case TARGET_UNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Compare::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Compare::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Compare::GetClassData() const { return &_class_data_; }


void Compare::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Compare*>(&to_msg);
  auto& from = static_cast<const Compare&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.Compare)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_result() != 0) {
    _this->_internal_set_result(from._internal_result());
  }
  if (from._internal_target() != 0) {
    _this->_internal_set_target(from._internal_target());
  }
  switch (from.target_union_case()) {
    case kVersion: {
      _this->_internal_set_version(from._internal_version());
      break;
    }
    case kCreateRevision: {
      _this->_internal_set_create_revision(from._internal_create_revision());
      break;
    }
    case kModRevision: {
      _this->_internal_set_mod_revision(from._internal_mod_revision());
      break;
    }
    case kValue: {
      _this->_internal_set_value(from._internal_value());
      break;
    }
    case kLease: {
      _this->_internal_set_lease(from._internal_lease());
      break;
    }
    case TARGET_UNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Compare::CopyFrom(const Compare& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.Compare)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Compare::IsInitialized() const {
  return true;
}

void Compare::InternalSwap(Compare* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.range_end_, lhs_arena,
                                       &other->_impl_.range_end_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Compare, _impl_.target_)
      + sizeof(Compare::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(Compare, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
  swap(_impl_.target_union_, other->_impl_.target_union_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Compare::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[9]);
}
// ===================================================================

class TxnRequest::_Internal {
 public:
};

TxnRequest::TxnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.TxnRequest)
}
TxnRequest::TxnRequest(const TxnRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TxnRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.compare_){from._impl_.compare_}
    , decltype(_impl_.success_){from._impl_.success_}
    , decltype(_impl_.failure_){from._impl_.failure_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.TxnRequest)
}

inline void TxnRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.compare_){arena}
    , decltype(_impl_.success_){arena}
    , decltype(_impl_.failure_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TxnRequest::~TxnRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.TxnRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TxnRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_compare()->~RepeatedPtrField();
  _internal_mutable_success()->~RepeatedPtrField();
  _internal_mutable_failure()->~RepeatedPtrField();
}

void TxnRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TxnRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.TxnRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_compare()->Clear();
  _internal_mutable_success()->Clear();
  _internal_mutable_failure()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TxnRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .etcdserverpb.Compare compare = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_compare(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.RequestOp success = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_success(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.RequestOp failure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_failure(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TxnRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.TxnRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .etcdserverpb.Compare compare = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compare_size()); i < n; i++) {
    const auto& repfield = this->_internal_compare(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.RequestOp success = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_success_size()); i < n; i++) {
    const auto& repfield = this->_internal_success(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.RequestOp failure = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_failure_size()); i < n; i++) {
    const auto& repfield = this->_internal_failure(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.TxnRequest)
  return target;
}

::size_t TxnRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.TxnRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Compare compare = 1;
  total_size += 1UL * this->_internal_compare_size();
  for (const auto& msg : this->_internal_compare()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .etcdserverpb.RequestOp success = 2;
  total_size += 1UL * this->_internal_success_size();
  for (const auto& msg : this->_internal_success()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .etcdserverpb.RequestOp failure = 3;
  total_size += 1UL * this->_internal_failure_size();
  for (const auto& msg : this->_internal_failure()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TxnRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TxnRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TxnRequest::GetClassData() const { return &_class_data_; }


void TxnRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TxnRequest*>(&to_msg);
  auto& from = static_cast<const TxnRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.TxnRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_compare()->MergeFrom(from._internal_compare());
  _this->_internal_mutable_success()->MergeFrom(from._internal_success());
  _this->_internal_mutable_failure()->MergeFrom(from._internal_failure());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TxnRequest::CopyFrom(const TxnRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.TxnRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxnRequest::IsInitialized() const {
  return true;
}

void TxnRequest::InternalSwap(TxnRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_compare()->InternalSwap(other->_internal_mutable_compare());
  _internal_mutable_success()->InternalSwap(other->_internal_mutable_success());
  _internal_mutable_failure()->InternalSwap(other->_internal_mutable_failure());
}

::PROTOBUF_NAMESPACE_ID::Metadata TxnRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[10]);
}
// ===================================================================

class TxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TxnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TxnResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const TxnResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
TxnResponse::_Internal::header(const TxnResponse* msg) {
  return *msg->_impl_.header_;
}
TxnResponse::TxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.TxnResponse)
}
TxnResponse::TxnResponse(const TxnResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TxnResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.responses_){from._impl_.responses_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.succeeded_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.succeeded_ = from._impl_.succeeded_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.TxnResponse)
}

inline void TxnResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.responses_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.succeeded_) { false }

  };
}

TxnResponse::~TxnResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.TxnResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TxnResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_responses()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void TxnResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.TxnResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_responses()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.succeeded_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TxnResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool succeeded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.succeeded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.ResponseOp responses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TxnResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.TxnResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bool succeeded = 2;
  if (this->_internal_succeeded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_succeeded(), target);
  }

  // repeated .etcdserverpb.ResponseOp responses = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_responses_size()); i < n; i++) {
    const auto& repfield = this->_internal_responses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.TxnResponse)
  return target;
}

::size_t TxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.TxnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.ResponseOp responses = 3;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->_internal_responses()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool succeeded = 2;
  if (this->_internal_succeeded() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TxnResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TxnResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TxnResponse::GetClassData() const { return &_class_data_; }


void TxnResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TxnResponse*>(&to_msg);
  auto& from = static_cast<const TxnResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.TxnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_responses()->MergeFrom(from._internal_responses());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_succeeded() != 0) {
    _this->_internal_set_succeeded(from._internal_succeeded());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TxnResponse::CopyFrom(const TxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.TxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxnResponse::IsInitialized() const {
  return true;
}

void TxnResponse::InternalSwap(TxnResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_responses()->InternalSwap(other->_internal_mutable_responses());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TxnResponse, _impl_.succeeded_)
      + sizeof(TxnResponse::_impl_.succeeded_)
      - PROTOBUF_FIELD_OFFSET(TxnResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TxnResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[11]);
}
// ===================================================================

class CompactionRequest::_Internal {
 public:
};

CompactionRequest::CompactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.CompactionRequest)
}
CompactionRequest::CompactionRequest(const CompactionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.CompactionRequest)
}

inline void CompactionRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.revision_) { ::int64_t{0} }

    , decltype(_impl_.physical_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CompactionRequest::~CompactionRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.CompactionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompactionRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CompactionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompactionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.CompactionRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.revision_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.physical_) -
      reinterpret_cast<char*>(&_impl_.revision_)) + sizeof(_impl_.physical_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompactionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 revision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool physical = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.physical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompactionRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.CompactionRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 revision = 1;
  if (this->_internal_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_revision(), target);
  }

  // bool physical = 2;
  if (this->_internal_physical() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_physical(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.CompactionRequest)
  return target;
}

::size_t CompactionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.CompactionRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 revision = 1;
  if (this->_internal_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_revision());
  }

  // bool physical = 2;
  if (this->_internal_physical() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompactionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompactionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompactionRequest::GetClassData() const { return &_class_data_; }


void CompactionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompactionRequest*>(&to_msg);
  auto& from = static_cast<const CompactionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.CompactionRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_revision() != 0) {
    _this->_internal_set_revision(from._internal_revision());
  }
  if (from._internal_physical() != 0) {
    _this->_internal_set_physical(from._internal_physical());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompactionRequest::CopyFrom(const CompactionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.CompactionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompactionRequest::IsInitialized() const {
  return true;
}

void CompactionRequest::InternalSwap(CompactionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompactionRequest, _impl_.physical_)
      + sizeof(CompactionRequest::_impl_.physical_)
      - PROTOBUF_FIELD_OFFSET(CompactionRequest, _impl_.revision_)>(
          reinterpret_cast<char*>(&_impl_.revision_),
          reinterpret_cast<char*>(&other->_impl_.revision_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompactionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[12]);
}
// ===================================================================

class CompactionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CompactionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CompactionResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const CompactionResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
CompactionResponse::_Internal::header(const CompactionResponse* msg) {
  return *msg->_impl_.header_;
}
CompactionResponse::CompactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.CompactionResponse)
}
CompactionResponse::CompactionResponse(const CompactionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompactionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.CompactionResponse)
}

inline void CompactionResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

CompactionResponse::~CompactionResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.CompactionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompactionResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CompactionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompactionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.CompactionResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompactionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompactionResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.CompactionResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.CompactionResponse)
  return target;
}

::size_t CompactionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.CompactionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompactionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompactionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompactionResponse::GetClassData() const { return &_class_data_; }


void CompactionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompactionResponse*>(&to_msg);
  auto& from = static_cast<const CompactionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.CompactionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompactionResponse::CopyFrom(const CompactionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.CompactionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompactionResponse::IsInitialized() const {
  return true;
}

void CompactionResponse::InternalSwap(CompactionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompactionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[13]);
}
// ===================================================================

class HashRequest::_Internal {
 public:
};

HashRequest::HashRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.HashRequest)
}
HashRequest::HashRequest(const HashRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HashRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.HashRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HashRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[14]);
}
// ===================================================================

class HashKVRequest::_Internal {
 public:
};

HashKVRequest::HashKVRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.HashKVRequest)
}
HashKVRequest::HashKVRequest(const HashKVRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.HashKVRequest)
}

inline void HashKVRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.revision_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HashKVRequest::~HashKVRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.HashKVRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashKVRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void HashKVRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashKVRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.HashKVRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.revision_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashKVRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 revision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HashKVRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.HashKVRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 revision = 1;
  if (this->_internal_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_revision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.HashKVRequest)
  return target;
}

::size_t HashKVRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.HashKVRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 revision = 1;
  if (this->_internal_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_revision());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashKVRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HashKVRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashKVRequest::GetClassData() const { return &_class_data_; }


void HashKVRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HashKVRequest*>(&to_msg);
  auto& from = static_cast<const HashKVRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.HashKVRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_revision() != 0) {
    _this->_internal_set_revision(from._internal_revision());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashKVRequest::CopyFrom(const HashKVRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.HashKVRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashKVRequest::IsInitialized() const {
  return true;
}

void HashKVRequest::InternalSwap(HashKVRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.revision_, other->_impl_.revision_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HashKVRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[15]);
}
// ===================================================================

class HashKVResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HashKVResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(HashKVResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const HashKVResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
HashKVResponse::_Internal::header(const HashKVResponse* msg) {
  return *msg->_impl_.header_;
}
HashKVResponse::HashKVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.HashKVResponse)
}
HashKVResponse::HashKVResponse(const HashKVResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HashKVResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.compact_revision_) {}

    , decltype(_impl_.hash_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.compact_revision_, &from._impl_.compact_revision_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.hash_) -
    reinterpret_cast<char*>(&_impl_.compact_revision_)) + sizeof(_impl_.hash_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.HashKVResponse)
}

inline void HashKVResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.compact_revision_) { ::int64_t{0} }

    , decltype(_impl_.hash_) { 0u }

  };
}

HashKVResponse::~HashKVResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.HashKVResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashKVResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void HashKVResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashKVResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.HashKVResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.compact_revision_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.hash_) -
      reinterpret_cast<char*>(&_impl_.compact_revision_)) + sizeof(_impl_.hash_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashKVResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 compact_revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.compact_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HashKVResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.HashKVResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint32 hash = 2;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_hash(), target);
  }

  // int64 compact_revision = 3;
  if (this->_internal_compact_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_compact_revision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.HashKVResponse)
  return target;
}

::size_t HashKVResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.HashKVResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 compact_revision = 3;
  if (this->_internal_compact_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_compact_revision());
  }

  // uint32 hash = 2;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashKVResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HashKVResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashKVResponse::GetClassData() const { return &_class_data_; }


void HashKVResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HashKVResponse*>(&to_msg);
  auto& from = static_cast<const HashKVResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.HashKVResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_compact_revision() != 0) {
    _this->_internal_set_compact_revision(from._internal_compact_revision());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashKVResponse::CopyFrom(const HashKVResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.HashKVResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashKVResponse::IsInitialized() const {
  return true;
}

void HashKVResponse::InternalSwap(HashKVResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashKVResponse, _impl_.hash_)
      + sizeof(HashKVResponse::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(HashKVResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HashKVResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[16]);
}
// ===================================================================

class HashResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HashResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(HashResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const HashResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
HashResponse::_Internal::header(const HashResponse* msg) {
  return *msg->_impl_.header_;
}
HashResponse::HashResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.HashResponse)
}
HashResponse::HashResponse(const HashResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HashResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.hash_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.HashResponse)
}

inline void HashResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.hash_) { 0u }

  };
}

HashResponse::~HashResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.HashResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void HashResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.HashResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.hash_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HashResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.HashResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint32 hash = 2;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.HashResponse)
  return target;
}

::size_t HashResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.HashResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint32 hash = 2;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HashResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashResponse::GetClassData() const { return &_class_data_; }


void HashResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HashResponse*>(&to_msg);
  auto& from = static_cast<const HashResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.HashResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashResponse::CopyFrom(const HashResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.HashResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashResponse::IsInitialized() const {
  return true;
}

void HashResponse::InternalSwap(HashResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashResponse, _impl_.hash_)
      + sizeof(HashResponse::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(HashResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HashResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[17]);
}
// ===================================================================

class SnapshotRequest::_Internal {
 public:
};

SnapshotRequest::SnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.SnapshotRequest)
}
SnapshotRequest::SnapshotRequest(const SnapshotRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  SnapshotRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.SnapshotRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SnapshotRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[18]);
}
// ===================================================================

class SnapshotResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SnapshotResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SnapshotResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const SnapshotResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
SnapshotResponse::_Internal::header(const SnapshotResponse* msg) {
  return *msg->_impl_.header_;
}
SnapshotResponse::SnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.SnapshotResponse)
}
SnapshotResponse::SnapshotResponse(const SnapshotResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnapshotResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blob_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.remaining_bytes_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.blob_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_blob().empty()) {
    _this->_impl_.blob_.Set(from._internal_blob(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.remaining_bytes_ = from._impl_.remaining_bytes_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.SnapshotResponse)
}

inline void SnapshotResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blob_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.remaining_bytes_) { ::uint64_t{0u} }

  };
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.blob_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SnapshotResponse::~SnapshotResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.SnapshotResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnapshotResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blob_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void SnapshotResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnapshotResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.SnapshotResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blob_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_.remaining_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 remaining_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.remaining_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes blob = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_blob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SnapshotResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.SnapshotResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint64 remaining_bytes = 2;
  if (this->_internal_remaining_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_remaining_bytes(), target);
  }

  // bytes blob = 3;
  if (!this->_internal_blob().empty()) {
    const std::string& _s = this->_internal_blob();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.SnapshotResponse)
  return target;
}

::size_t SnapshotResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.SnapshotResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes blob = 3;
  if (!this->_internal_blob().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_blob());
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint64 remaining_bytes = 2;
  if (this->_internal_remaining_bytes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_remaining_bytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnapshotResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotResponse::GetClassData() const { return &_class_data_; }


void SnapshotResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnapshotResponse*>(&to_msg);
  auto& from = static_cast<const SnapshotResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.SnapshotResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_blob().empty()) {
    _this->_internal_set_blob(from._internal_blob());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_remaining_bytes() != 0) {
    _this->_internal_set_remaining_bytes(from._internal_remaining_bytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotResponse::CopyFrom(const SnapshotResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.SnapshotResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotResponse::IsInitialized() const {
  return true;
}

void SnapshotResponse::InternalSwap(SnapshotResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.blob_, lhs_arena,
                                       &other->_impl_.blob_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SnapshotResponse, _impl_.remaining_bytes_)
      + sizeof(SnapshotResponse::_impl_.remaining_bytes_)
      - PROTOBUF_FIELD_OFFSET(SnapshotResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[19]);
}
// ===================================================================

class WatchRequest::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::etcdserverpb::WatchRequest, _impl_._oneof_case_);
  static const ::etcdserverpb::WatchCreateRequest& create_request(const WatchRequest* msg);
  static const ::etcdserverpb::WatchCancelRequest& cancel_request(const WatchRequest* msg);
  static const ::etcdserverpb::WatchProgressRequest& progress_request(const WatchRequest* msg);
};

const ::etcdserverpb::WatchCreateRequest&
WatchRequest::_Internal::create_request(const WatchRequest* msg) {
  return *msg->_impl_.request_union_.create_request_;
}
const ::etcdserverpb::WatchCancelRequest&
WatchRequest::_Internal::cancel_request(const WatchRequest* msg) {
  return *msg->_impl_.request_union_.cancel_request_;
}
const ::etcdserverpb::WatchProgressRequest&
WatchRequest::_Internal::progress_request(const WatchRequest* msg) {
  return *msg->_impl_.request_union_.progress_request_;
}
void WatchRequest::set_allocated_create_request(::etcdserverpb::WatchCreateRequest* create_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_union();
  if (create_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_request);
    if (message_arena != submessage_arena) {
      create_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_request, submessage_arena);
    }
    set_has_create_request();
    _impl_.request_union_.create_request_ = create_request;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchRequest.create_request)
}
void WatchRequest::set_allocated_cancel_request(::etcdserverpb::WatchCancelRequest* cancel_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_union();
  if (cancel_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancel_request);
    if (message_arena != submessage_arena) {
      cancel_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_request, submessage_arena);
    }
    set_has_cancel_request();
    _impl_.request_union_.cancel_request_ = cancel_request;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchRequest.cancel_request)
}
void WatchRequest::set_allocated_progress_request(::etcdserverpb::WatchProgressRequest* progress_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_union();
  if (progress_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress_request);
    if (message_arena != submessage_arena) {
      progress_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress_request, submessage_arena);
    }
    set_has_progress_request();
    _impl_.request_union_.progress_request_ = progress_request;
  }
  // @@protoc_insertion_point(field_set_allocated:etcdserverpb.WatchRequest.progress_request)
}
WatchRequest::WatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.WatchRequest)
}
WatchRequest::WatchRequest(const WatchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WatchRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_union_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_request_union();
  switch (from.request_union_case()) {
    case kCreateRequest: {
      _this->_internal_mutable_create_request()->::etcdserverpb::WatchCreateRequest::MergeFrom(
          from._internal_create_request());
      break;
    }
    case kCancelRequest: {
      _this->_internal_mutable_cancel_request()->::etcdserverpb::WatchCancelRequest::MergeFrom(
          from._internal_cancel_request());
      break;
    }
    case kProgressRequest: {
      _this->_internal_mutable_progress_request()->::etcdserverpb::WatchProgressRequest::MergeFrom(
          from._internal_progress_request());
      break;
    }
    case REQUEST_UNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.WatchRequest)
}

inline void WatchRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.request_union_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_request_union();
}

WatchRequest::~WatchRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.WatchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WatchRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_request_union()) {
    clear_request_union();
  }
}

void WatchRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WatchRequest::clear_request_union() {
// @@protoc_insertion_point(one_of_clear_start:etcdserverpb.WatchRequest)
  switch (request_union_case()) {
    case kCreateRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_union_.create_request_;
      }
      break;
    }
    case kCancelRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_union_.cancel_request_;
      }
      break;
    }
    case kProgressRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_union_.progress_request_;
      }
      break;
    }
    case REQUEST_UNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUEST_UNION_NOT_SET;
}


void WatchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.WatchRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_request_union();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WatchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.WatchCreateRequest create_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_request(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.WatchCancelRequest cancel_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cancel_request(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.WatchProgressRequest progress_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_progress_request(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WatchRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.WatchRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (request_union_case()) {
    case kCreateRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::create_request(this),
          _Internal::create_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kCancelRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::cancel_request(this),
          _Internal::cancel_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kProgressRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::progress_request(this),
          _Internal::progress_request(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.WatchRequest)
  return target;
}

::size_t WatchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.WatchRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (request_union_case()) {
    // .etcdserverpb.WatchCreateRequest create_request = 1;
    case kCreateRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_union_.create_request_);
      break;
    }
    // .etcdserverpb.WatchCancelRequest cancel_request = 2;
    case kCancelRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_union_.cancel_request_);
      break;
    }
    // .etcdserverpb.WatchProgressRequest progress_request = 3;
    case kProgressRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_union_.progress_request_);
      break;
    }
    case REQUEST_UNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WatchRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WatchRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WatchRequest::GetClassData() const { return &_class_data_; }


void WatchRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WatchRequest*>(&to_msg);
  auto& from = static_cast<const WatchRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.WatchRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.request_union_case()) {
    case kCreateRequest: {
      _this->_internal_mutable_create_request()->::etcdserverpb::WatchCreateRequest::MergeFrom(
          from._internal_create_request());
      break;
    }
    case kCancelRequest: {
      _this->_internal_mutable_cancel_request()->::etcdserverpb::WatchCancelRequest::MergeFrom(
          from._internal_cancel_request());
      break;
    }
    case kProgressRequest: {
      _this->_internal_mutable_progress_request()->::etcdserverpb::WatchProgressRequest::MergeFrom(
          from._internal_progress_request());
      break;
    }
    case REQUEST_UNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WatchRequest::CopyFrom(const WatchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.WatchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WatchRequest::IsInitialized() const {
  return true;
}

void WatchRequest::InternalSwap(WatchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_union_, other->_impl_.request_union_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata WatchRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[20]);
}
// ===================================================================

class WatchCreateRequest::_Internal {
 public:
};

WatchCreateRequest::WatchCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.WatchCreateRequest)
}
WatchCreateRequest::WatchCreateRequest(const WatchCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WatchCreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filters_) { from._internal_filters() }
    , /*decltype(_impl_._filters_cached_byte_size_)*/ { 0 }

    , decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.start_revision_) {}

    , decltype(_impl_.watch_id_) {}

    , decltype(_impl_.progress_notify_) {}

    , decltype(_impl_.prev_kv_) {}

    , decltype(_impl_.fragment_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_revision_, &from._impl_.start_revision_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fragment_) -
    reinterpret_cast<char*>(&_impl_.start_revision_)) + sizeof(_impl_.fragment_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.WatchCreateRequest)
}

inline void WatchCreateRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.filters_) { arena }
    , /*decltype(_impl_._filters_cached_byte_size_)*/ { 0 }

    , decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , decltype(_impl_.start_revision_) { ::int64_t{0} }

    , decltype(_impl_.watch_id_) { ::int64_t{0} }

    , decltype(_impl_.progress_notify_) { false }

    , decltype(_impl_.prev_kv_) { false }

    , decltype(_impl_.fragment_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WatchCreateRequest::~WatchCreateRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.WatchCreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WatchCreateRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_filters()->~RepeatedField();
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
}

void WatchCreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WatchCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.WatchCreateRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_filters()->Clear();
  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  ::memset(&_impl_.start_revision_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fragment_) -
      reinterpret_cast<char*>(&_impl_.start_revision_)) + sizeof(_impl_.fragment_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WatchCreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes range_end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 start_revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.start_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool progress_notify = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.progress_notify_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_filters(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 40) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_add_filters(static_cast<::etcdserverpb::WatchCreateRequest_FilterType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool prev_kv = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 watch_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.watch_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fragment = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.fragment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WatchCreateRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.WatchCreateRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    const std::string& _s = this->_internal_range_end();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // int64 start_revision = 3;
  if (this->_internal_start_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_start_revision(), target);
  }

  // bool progress_notify = 4;
  if (this->_internal_progress_notify() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_progress_notify(), target);
  }

  // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;
  {
    int byte_size = _impl_._filters_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(5, _internal_filters(),
                                       byte_size, target);
    }
  }

  // bool prev_kv = 6;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_prev_kv(), target);
  }

  // int64 watch_id = 7;
  if (this->_internal_watch_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this->_internal_watch_id(), target);
  }

  // bool fragment = 8;
  if (this->_internal_fragment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_fragment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.WatchCreateRequest)
  return target;
}

::size_t WatchCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.WatchCreateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;
  {
    std::size_t data_size = 0;
    auto count = static_cast<std::size_t>(this->_internal_filters_size());

    for (std::size_t i = 0; i < count; ++i) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
          this->_internal_filters(static_cast<int>(i)));
    }
    total_size += data_size;
    if (data_size > 0) {
      total_size += 1;
      total_size += ::_pbi::WireFormatLite::Int32Size(
          static_cast<int32_t>(data_size));
    }
    _impl_._filters_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
  }

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes range_end = 2;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_range_end());
  }

  // int64 start_revision = 3;
  if (this->_internal_start_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_start_revision());
  }

  // int64 watch_id = 7;
  if (this->_internal_watch_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_watch_id());
  }

  // bool progress_notify = 4;
  if (this->_internal_progress_notify() != 0) {
    total_size += 2;
  }

  // bool prev_kv = 6;
  if (this->_internal_prev_kv() != 0) {
    total_size += 2;
  }

  // bool fragment = 8;
  if (this->_internal_fragment() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WatchCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WatchCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WatchCreateRequest::GetClassData() const { return &_class_data_; }


void WatchCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WatchCreateRequest*>(&to_msg);
  auto& from = static_cast<const WatchCreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.WatchCreateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_filters()->MergeFrom(from._internal_filters());
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_start_revision() != 0) {
    _this->_internal_set_start_revision(from._internal_start_revision());
  }
  if (from._internal_watch_id() != 0) {
    _this->_internal_set_watch_id(from._internal_watch_id());
  }
  if (from._internal_progress_notify() != 0) {
    _this->_internal_set_progress_notify(from._internal_progress_notify());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  if (from._internal_fragment() != 0) {
    _this->_internal_set_fragment(from._internal_fragment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WatchCreateRequest::CopyFrom(const WatchCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.WatchCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WatchCreateRequest::IsInitialized() const {
  return true;
}

void WatchCreateRequest::InternalSwap(WatchCreateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_filters()->InternalSwap(
      other->_internal_mutable_filters());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.range_end_, lhs_arena,
                                       &other->_impl_.range_end_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WatchCreateRequest, _impl_.fragment_)
      + sizeof(WatchCreateRequest::_impl_.fragment_)
      - PROTOBUF_FIELD_OFFSET(WatchCreateRequest, _impl_.start_revision_)>(
          reinterpret_cast<char*>(&_impl_.start_revision_),
          reinterpret_cast<char*>(&other->_impl_.start_revision_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WatchCreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[21]);
}
// ===================================================================

class WatchCancelRequest::_Internal {
 public:
};

WatchCancelRequest::WatchCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.WatchCancelRequest)
}
WatchCancelRequest::WatchCancelRequest(const WatchCancelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.WatchCancelRequest)
}

inline void WatchCancelRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.watch_id_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WatchCancelRequest::~WatchCancelRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.WatchCancelRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WatchCancelRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void WatchCancelRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WatchCancelRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.WatchCancelRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.watch_id_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WatchCancelRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 watch_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.watch_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WatchCancelRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.WatchCancelRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 watch_id = 1;
  if (this->_internal_watch_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_watch_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.WatchCancelRequest)
  return target;
}

::size_t WatchCancelRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.WatchCancelRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 watch_id = 1;
  if (this->_internal_watch_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_watch_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WatchCancelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WatchCancelRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WatchCancelRequest::GetClassData() const { return &_class_data_; }


void WatchCancelRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WatchCancelRequest*>(&to_msg);
  auto& from = static_cast<const WatchCancelRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.WatchCancelRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_watch_id() != 0) {
    _this->_internal_set_watch_id(from._internal_watch_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WatchCancelRequest::CopyFrom(const WatchCancelRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.WatchCancelRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WatchCancelRequest::IsInitialized() const {
  return true;
}

void WatchCancelRequest::InternalSwap(WatchCancelRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.watch_id_, other->_impl_.watch_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WatchCancelRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[22]);
}
// ===================================================================

class WatchProgressRequest::_Internal {
 public:
};

WatchProgressRequest::WatchProgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.WatchProgressRequest)
}
WatchProgressRequest::WatchProgressRequest(const WatchProgressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WatchProgressRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.WatchProgressRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WatchProgressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WatchProgressRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WatchProgressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[23]);
}
// ===================================================================

class WatchResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<WatchResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WatchResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const WatchResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
WatchResponse::_Internal::header(const WatchResponse* msg) {
  return *msg->_impl_.header_;
}
void WatchResponse::clear_events() {
  _internal_mutable_events()->Clear();
}
WatchResponse::WatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.WatchResponse)
}
WatchResponse::WatchResponse(const WatchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WatchResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.events_){from._impl_.events_}
    , decltype(_impl_.cancel_reason_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.watch_id_) {}

    , decltype(_impl_.compact_revision_) {}

    , decltype(_impl_.created_) {}

    , decltype(_impl_.canceled_) {}

    , decltype(_impl_.fragment_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cancel_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cancel_reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cancel_reason().empty()) {
    _this->_impl_.cancel_reason_.Set(from._internal_cancel_reason(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.watch_id_, &from._impl_.watch_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fragment_) -
    reinterpret_cast<char*>(&_impl_.watch_id_)) + sizeof(_impl_.fragment_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.WatchResponse)
}

inline void WatchResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.events_){arena}
    , decltype(_impl_.cancel_reason_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.watch_id_) { ::int64_t{0} }

    , decltype(_impl_.compact_revision_) { ::int64_t{0} }

    , decltype(_impl_.created_) { false }

    , decltype(_impl_.canceled_) { false }

    , decltype(_impl_.fragment_) { false }

  };
  _impl_.cancel_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cancel_reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WatchResponse::~WatchResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.WatchResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WatchResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_events()->~RepeatedPtrField();
  _impl_.cancel_reason_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void WatchResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WatchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.WatchResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_events()->Clear();
  _impl_.cancel_reason_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.watch_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fragment_) -
      reinterpret_cast<char*>(&_impl_.watch_id_)) + sizeof(_impl_.fragment_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WatchResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 watch_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.watch_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool created = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool canceled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.canceled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 compact_revision = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.compact_revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string cancel_reason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_cancel_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.WatchResponse.cancel_reason"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool fragment = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.fragment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .mvccpb.Event events = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WatchResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.WatchResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 watch_id = 2;
  if (this->_internal_watch_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_watch_id(), target);
  }

  // bool created = 3;
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_created(), target);
  }

  // bool canceled = 4;
  if (this->_internal_canceled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_canceled(), target);
  }

  // int64 compact_revision = 5;
  if (this->_internal_compact_revision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_compact_revision(), target);
  }

  // string cancel_reason = 6;
  if (!this->_internal_cancel_reason().empty()) {
    const std::string& _s = this->_internal_cancel_reason();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.WatchResponse.cancel_reason");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // bool fragment = 7;
  if (this->_internal_fragment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_fragment(), target);
  }

  // repeated .mvccpb.Event events = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.WatchResponse)
  return target;
}

::size_t WatchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.WatchResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mvccpb.Event events = 11;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->_internal_events()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string cancel_reason = 6;
  if (!this->_internal_cancel_reason().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cancel_reason());
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 watch_id = 2;
  if (this->_internal_watch_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_watch_id());
  }

  // int64 compact_revision = 5;
  if (this->_internal_compact_revision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_compact_revision());
  }

  // bool created = 3;
  if (this->_internal_created() != 0) {
    total_size += 2;
  }

  // bool canceled = 4;
  if (this->_internal_canceled() != 0) {
    total_size += 2;
  }

  // bool fragment = 7;
  if (this->_internal_fragment() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WatchResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WatchResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WatchResponse::GetClassData() const { return &_class_data_; }


void WatchResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WatchResponse*>(&to_msg);
  auto& from = static_cast<const WatchResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.WatchResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_events()->MergeFrom(from._internal_events());
  if (!from._internal_cancel_reason().empty()) {
    _this->_internal_set_cancel_reason(from._internal_cancel_reason());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_watch_id() != 0) {
    _this->_internal_set_watch_id(from._internal_watch_id());
  }
  if (from._internal_compact_revision() != 0) {
    _this->_internal_set_compact_revision(from._internal_compact_revision());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  if (from._internal_canceled() != 0) {
    _this->_internal_set_canceled(from._internal_canceled());
  }
  if (from._internal_fragment() != 0) {
    _this->_internal_set_fragment(from._internal_fragment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WatchResponse::CopyFrom(const WatchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.WatchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WatchResponse::IsInitialized() const {
  return true;
}

void WatchResponse::InternalSwap(WatchResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_events()->InternalSwap(other->_internal_mutable_events());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cancel_reason_, lhs_arena,
                                       &other->_impl_.cancel_reason_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WatchResponse, _impl_.fragment_)
      + sizeof(WatchResponse::_impl_.fragment_)
      - PROTOBUF_FIELD_OFFSET(WatchResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WatchResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[24]);
}
// ===================================================================

class LeaseGrantRequest::_Internal {
 public:
};

LeaseGrantRequest::LeaseGrantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseGrantRequest)
}
LeaseGrantRequest::LeaseGrantRequest(const LeaseGrantRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseGrantRequest)
}

inline void LeaseGrantRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ttl_) { ::int64_t{0} }

    , decltype(_impl_.id_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseGrantRequest::~LeaseGrantRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseGrantRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseGrantRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseGrantRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseGrantRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseGrantRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.ttl_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.id_) -
      reinterpret_cast<char*>(&_impl_.ttl_)) + sizeof(_impl_.id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseGrantRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 TTL = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseGrantRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseGrantRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 TTL = 1;
  if (this->_internal_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_ttl(), target);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseGrantRequest)
  return target;
}

::size_t LeaseGrantRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseGrantRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 TTL = 1;
  if (this->_internal_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ttl());
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseGrantRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseGrantRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseGrantRequest::GetClassData() const { return &_class_data_; }


void LeaseGrantRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseGrantRequest*>(&to_msg);
  auto& from = static_cast<const LeaseGrantRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseGrantRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ttl() != 0) {
    _this->_internal_set_ttl(from._internal_ttl());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseGrantRequest::CopyFrom(const LeaseGrantRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseGrantRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseGrantRequest::IsInitialized() const {
  return true;
}

void LeaseGrantRequest::InternalSwap(LeaseGrantRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseGrantRequest, _impl_.id_)
      + sizeof(LeaseGrantRequest::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(LeaseGrantRequest, _impl_.ttl_)>(
          reinterpret_cast<char*>(&_impl_.ttl_),
          reinterpret_cast<char*>(&other->_impl_.ttl_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseGrantRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[25]);
}
// ===================================================================

class LeaseGrantResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseGrantResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseGrantResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseGrantResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseGrantResponse::_Internal::header(const LeaseGrantResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseGrantResponse::LeaseGrantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseGrantResponse)
}
LeaseGrantResponse::LeaseGrantResponse(const LeaseGrantResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseGrantResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.ttl_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.error_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error().empty()) {
    _this->_impl_.error_.Set(from._internal_error(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ttl_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ttl_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseGrantResponse)
}

inline void LeaseGrantResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.ttl_) { ::int64_t{0} }

  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.error_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeaseGrantResponse::~LeaseGrantResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseGrantResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseGrantResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseGrantResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseGrantResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseGrantResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ttl_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ttl_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseGrantResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 TTL = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.LeaseGrantResponse.error"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseGrantResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseGrantResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_id(), target);
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_ttl(), target);
  }

  // string error = 4;
  if (!this->_internal_error().empty()) {
    const std::string& _s = this->_internal_error();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.LeaseGrantResponse.error");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseGrantResponse)
  return target;
}

::size_t LeaseGrantResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseGrantResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error = 4;
  if (!this->_internal_error().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_error());
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ttl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseGrantResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseGrantResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseGrantResponse::GetClassData() const { return &_class_data_; }


void LeaseGrantResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseGrantResponse*>(&to_msg);
  auto& from = static_cast<const LeaseGrantResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseGrantResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error().empty()) {
    _this->_internal_set_error(from._internal_error());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_ttl() != 0) {
    _this->_internal_set_ttl(from._internal_ttl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseGrantResponse::CopyFrom(const LeaseGrantResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseGrantResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseGrantResponse::IsInitialized() const {
  return true;
}

void LeaseGrantResponse::InternalSwap(LeaseGrantResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, lhs_arena,
                                       &other->_impl_.error_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseGrantResponse, _impl_.ttl_)
      + sizeof(LeaseGrantResponse::_impl_.ttl_)
      - PROTOBUF_FIELD_OFFSET(LeaseGrantResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseGrantResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[26]);
}
// ===================================================================

class LeaseRevokeRequest::_Internal {
 public:
};

LeaseRevokeRequest::LeaseRevokeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseRevokeRequest)
}
LeaseRevokeRequest::LeaseRevokeRequest(const LeaseRevokeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseRevokeRequest)
}

inline void LeaseRevokeRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseRevokeRequest::~LeaseRevokeRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseRevokeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseRevokeRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseRevokeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseRevokeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseRevokeRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseRevokeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseRevokeRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseRevokeRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseRevokeRequest)
  return target;
}

::size_t LeaseRevokeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseRevokeRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseRevokeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseRevokeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseRevokeRequest::GetClassData() const { return &_class_data_; }


void LeaseRevokeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseRevokeRequest*>(&to_msg);
  auto& from = static_cast<const LeaseRevokeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseRevokeRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseRevokeRequest::CopyFrom(const LeaseRevokeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseRevokeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseRevokeRequest::IsInitialized() const {
  return true;
}

void LeaseRevokeRequest::InternalSwap(LeaseRevokeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseRevokeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[27]);
}
// ===================================================================

class LeaseRevokeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseRevokeResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseRevokeResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseRevokeResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseRevokeResponse::_Internal::header(const LeaseRevokeResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseRevokeResponse::LeaseRevokeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseRevokeResponse)
}
LeaseRevokeResponse::LeaseRevokeResponse(const LeaseRevokeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseRevokeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseRevokeResponse)
}

inline void LeaseRevokeResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

LeaseRevokeResponse::~LeaseRevokeResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseRevokeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseRevokeResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseRevokeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseRevokeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseRevokeResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseRevokeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseRevokeResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseRevokeResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseRevokeResponse)
  return target;
}

::size_t LeaseRevokeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseRevokeResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseRevokeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseRevokeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseRevokeResponse::GetClassData() const { return &_class_data_; }


void LeaseRevokeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseRevokeResponse*>(&to_msg);
  auto& from = static_cast<const LeaseRevokeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseRevokeResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseRevokeResponse::CopyFrom(const LeaseRevokeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseRevokeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseRevokeResponse::IsInitialized() const {
  return true;
}

void LeaseRevokeResponse::InternalSwap(LeaseRevokeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseRevokeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[28]);
}
// ===================================================================

class LeaseCheckpoint::_Internal {
 public:
};

LeaseCheckpoint::LeaseCheckpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseCheckpoint)
}
LeaseCheckpoint::LeaseCheckpoint(const LeaseCheckpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseCheckpoint)
}

inline void LeaseCheckpoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.remaining_ttl_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseCheckpoint::~LeaseCheckpoint() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseCheckpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseCheckpoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseCheckpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseCheckpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseCheckpoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.remaining_ttl_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.remaining_ttl_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseCheckpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 remaining_TTL = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.remaining_ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseCheckpoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseCheckpoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  // int64 remaining_TTL = 2;
  if (this->_internal_remaining_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_remaining_ttl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseCheckpoint)
  return target;
}

::size_t LeaseCheckpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseCheckpoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int64 remaining_TTL = 2;
  if (this->_internal_remaining_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_remaining_ttl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseCheckpoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseCheckpoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseCheckpoint::GetClassData() const { return &_class_data_; }


void LeaseCheckpoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseCheckpoint*>(&to_msg);
  auto& from = static_cast<const LeaseCheckpoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseCheckpoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_remaining_ttl() != 0) {
    _this->_internal_set_remaining_ttl(from._internal_remaining_ttl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseCheckpoint::CopyFrom(const LeaseCheckpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseCheckpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseCheckpoint::IsInitialized() const {
  return true;
}

void LeaseCheckpoint::InternalSwap(LeaseCheckpoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseCheckpoint, _impl_.remaining_ttl_)
      + sizeof(LeaseCheckpoint::_impl_.remaining_ttl_)
      - PROTOBUF_FIELD_OFFSET(LeaseCheckpoint, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseCheckpoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[29]);
}
// ===================================================================

class LeaseCheckpointRequest::_Internal {
 public:
};

LeaseCheckpointRequest::LeaseCheckpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseCheckpointRequest)
}
LeaseCheckpointRequest::LeaseCheckpointRequest(const LeaseCheckpointRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseCheckpointRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.checkpoints_){from._impl_.checkpoints_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseCheckpointRequest)
}

inline void LeaseCheckpointRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.checkpoints_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseCheckpointRequest::~LeaseCheckpointRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseCheckpointRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseCheckpointRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_checkpoints()->~RepeatedPtrField();
}

void LeaseCheckpointRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseCheckpointRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseCheckpointRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_checkpoints()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseCheckpointRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .etcdserverpb.LeaseCheckpoint checkpoints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_checkpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseCheckpointRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseCheckpointRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .etcdserverpb.LeaseCheckpoint checkpoints = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_checkpoints_size()); i < n; i++) {
    const auto& repfield = this->_internal_checkpoints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseCheckpointRequest)
  return target;
}

::size_t LeaseCheckpointRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseCheckpointRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.LeaseCheckpoint checkpoints = 1;
  total_size += 1UL * this->_internal_checkpoints_size();
  for (const auto& msg : this->_internal_checkpoints()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseCheckpointRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseCheckpointRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseCheckpointRequest::GetClassData() const { return &_class_data_; }


void LeaseCheckpointRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseCheckpointRequest*>(&to_msg);
  auto& from = static_cast<const LeaseCheckpointRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseCheckpointRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_checkpoints()->MergeFrom(from._internal_checkpoints());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseCheckpointRequest::CopyFrom(const LeaseCheckpointRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseCheckpointRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseCheckpointRequest::IsInitialized() const {
  return true;
}

void LeaseCheckpointRequest::InternalSwap(LeaseCheckpointRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_checkpoints()->InternalSwap(other->_internal_mutable_checkpoints());
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseCheckpointRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[30]);
}
// ===================================================================

class LeaseCheckpointResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseCheckpointResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseCheckpointResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseCheckpointResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseCheckpointResponse::_Internal::header(const LeaseCheckpointResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseCheckpointResponse::LeaseCheckpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseCheckpointResponse)
}
LeaseCheckpointResponse::LeaseCheckpointResponse(const LeaseCheckpointResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseCheckpointResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseCheckpointResponse)
}

inline void LeaseCheckpointResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

LeaseCheckpointResponse::~LeaseCheckpointResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseCheckpointResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseCheckpointResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseCheckpointResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseCheckpointResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseCheckpointResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseCheckpointResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseCheckpointResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseCheckpointResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseCheckpointResponse)
  return target;
}

::size_t LeaseCheckpointResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseCheckpointResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseCheckpointResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseCheckpointResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseCheckpointResponse::GetClassData() const { return &_class_data_; }


void LeaseCheckpointResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseCheckpointResponse*>(&to_msg);
  auto& from = static_cast<const LeaseCheckpointResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseCheckpointResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseCheckpointResponse::CopyFrom(const LeaseCheckpointResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseCheckpointResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseCheckpointResponse::IsInitialized() const {
  return true;
}

void LeaseCheckpointResponse::InternalSwap(LeaseCheckpointResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseCheckpointResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[31]);
}
// ===================================================================

class LeaseKeepAliveRequest::_Internal {
 public:
};

LeaseKeepAliveRequest::LeaseKeepAliveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseKeepAliveRequest)
}
LeaseKeepAliveRequest::LeaseKeepAliveRequest(const LeaseKeepAliveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseKeepAliveRequest)
}

inline void LeaseKeepAliveRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseKeepAliveRequest::~LeaseKeepAliveRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseKeepAliveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseKeepAliveRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseKeepAliveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseKeepAliveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseKeepAliveRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseKeepAliveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseKeepAliveRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseKeepAliveRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseKeepAliveRequest)
  return target;
}

::size_t LeaseKeepAliveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseKeepAliveRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseKeepAliveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseKeepAliveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseKeepAliveRequest::GetClassData() const { return &_class_data_; }


void LeaseKeepAliveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseKeepAliveRequest*>(&to_msg);
  auto& from = static_cast<const LeaseKeepAliveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseKeepAliveRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseKeepAliveRequest::CopyFrom(const LeaseKeepAliveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseKeepAliveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseKeepAliveRequest::IsInitialized() const {
  return true;
}

void LeaseKeepAliveRequest::InternalSwap(LeaseKeepAliveRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseKeepAliveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[32]);
}
// ===================================================================

class LeaseKeepAliveResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseKeepAliveResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseKeepAliveResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseKeepAliveResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseKeepAliveResponse::_Internal::header(const LeaseKeepAliveResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseKeepAliveResponse::LeaseKeepAliveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseKeepAliveResponse)
}
LeaseKeepAliveResponse::LeaseKeepAliveResponse(const LeaseKeepAliveResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseKeepAliveResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.ttl_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ttl_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ttl_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseKeepAliveResponse)
}

inline void LeaseKeepAliveResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.ttl_) { ::int64_t{0} }

  };
}

LeaseKeepAliveResponse::~LeaseKeepAliveResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseKeepAliveResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseKeepAliveResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseKeepAliveResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseKeepAliveResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseKeepAliveResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ttl_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ttl_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseKeepAliveResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 TTL = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseKeepAliveResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseKeepAliveResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_id(), target);
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_ttl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseKeepAliveResponse)
  return target;
}

::size_t LeaseKeepAliveResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseKeepAliveResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ttl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseKeepAliveResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseKeepAliveResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseKeepAliveResponse::GetClassData() const { return &_class_data_; }


void LeaseKeepAliveResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseKeepAliveResponse*>(&to_msg);
  auto& from = static_cast<const LeaseKeepAliveResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseKeepAliveResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_ttl() != 0) {
    _this->_internal_set_ttl(from._internal_ttl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseKeepAliveResponse::CopyFrom(const LeaseKeepAliveResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseKeepAliveResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseKeepAliveResponse::IsInitialized() const {
  return true;
}

void LeaseKeepAliveResponse::InternalSwap(LeaseKeepAliveResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseKeepAliveResponse, _impl_.ttl_)
      + sizeof(LeaseKeepAliveResponse::_impl_.ttl_)
      - PROTOBUF_FIELD_OFFSET(LeaseKeepAliveResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseKeepAliveResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[33]);
}
// ===================================================================

class LeaseTimeToLiveRequest::_Internal {
 public:
};

LeaseTimeToLiveRequest::LeaseTimeToLiveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseTimeToLiveRequest)
}
LeaseTimeToLiveRequest::LeaseTimeToLiveRequest(const LeaseTimeToLiveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseTimeToLiveRequest)
}

inline void LeaseTimeToLiveRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.keys_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseTimeToLiveRequest::~LeaseTimeToLiveRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseTimeToLiveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseTimeToLiveRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseTimeToLiveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseTimeToLiveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseTimeToLiveRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.keys_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.keys_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseTimeToLiveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.keys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseTimeToLiveRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseTimeToLiveRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  // bool keys = 2;
  if (this->_internal_keys() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_keys(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseTimeToLiveRequest)
  return target;
}

::size_t LeaseTimeToLiveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseTimeToLiveRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // bool keys = 2;
  if (this->_internal_keys() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseTimeToLiveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseTimeToLiveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseTimeToLiveRequest::GetClassData() const { return &_class_data_; }


void LeaseTimeToLiveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseTimeToLiveRequest*>(&to_msg);
  auto& from = static_cast<const LeaseTimeToLiveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseTimeToLiveRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_keys() != 0) {
    _this->_internal_set_keys(from._internal_keys());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseTimeToLiveRequest::CopyFrom(const LeaseTimeToLiveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseTimeToLiveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseTimeToLiveRequest::IsInitialized() const {
  return true;
}

void LeaseTimeToLiveRequest::InternalSwap(LeaseTimeToLiveRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseTimeToLiveRequest, _impl_.keys_)
      + sizeof(LeaseTimeToLiveRequest::_impl_.keys_)
      - PROTOBUF_FIELD_OFFSET(LeaseTimeToLiveRequest, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseTimeToLiveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[34]);
}
// ===================================================================

class LeaseTimeToLiveResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseTimeToLiveResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseTimeToLiveResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseTimeToLiveResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseTimeToLiveResponse::_Internal::header(const LeaseTimeToLiveResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseTimeToLiveResponse::LeaseTimeToLiveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseTimeToLiveResponse)
}
LeaseTimeToLiveResponse::LeaseTimeToLiveResponse(const LeaseTimeToLiveResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseTimeToLiveResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.ttl_) {}

    , decltype(_impl_.grantedttl_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.grantedttl_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.grantedttl_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseTimeToLiveResponse)
}

inline void LeaseTimeToLiveResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.ttl_) { ::int64_t{0} }

    , decltype(_impl_.grantedttl_) { ::int64_t{0} }

  };
}

LeaseTimeToLiveResponse::~LeaseTimeToLiveResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseTimeToLiveResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseTimeToLiveResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_keys()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseTimeToLiveResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseTimeToLiveResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseTimeToLiveResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_keys()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.grantedttl_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.grantedttl_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseTimeToLiveResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 TTL = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 grantedTTL = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.grantedttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bytes keys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseTimeToLiveResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseTimeToLiveResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_id(), target);
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_ttl(), target);
  }

  // int64 grantedTTL = 4;
  if (this->_internal_grantedttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_grantedttl(), target);
  }

  // repeated bytes keys = 5;
  for (int i = 0, n = this->_internal_keys_size(); i < n; ++i) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteBytes(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseTimeToLiveResponse)
  return target;
}

::size_t LeaseTimeToLiveResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseTimeToLiveResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes keys = 5;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_keys().size());
  for (int i = 0, n = _internal_keys().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_keys().Get(i));
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 ID = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int64 TTL = 3;
  if (this->_internal_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ttl());
  }

  // int64 grantedTTL = 4;
  if (this->_internal_grantedttl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_grantedttl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseTimeToLiveResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseTimeToLiveResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseTimeToLiveResponse::GetClassData() const { return &_class_data_; }


void LeaseTimeToLiveResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseTimeToLiveResponse*>(&to_msg);
  auto& from = static_cast<const LeaseTimeToLiveResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseTimeToLiveResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_keys()->MergeFrom(from._internal_keys());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_ttl() != 0) {
    _this->_internal_set_ttl(from._internal_ttl());
  }
  if (from._internal_grantedttl() != 0) {
    _this->_internal_set_grantedttl(from._internal_grantedttl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseTimeToLiveResponse::CopyFrom(const LeaseTimeToLiveResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseTimeToLiveResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseTimeToLiveResponse::IsInitialized() const {
  return true;
}

void LeaseTimeToLiveResponse::InternalSwap(LeaseTimeToLiveResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_keys()->InternalSwap(
      other->_internal_mutable_keys());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseTimeToLiveResponse, _impl_.grantedttl_)
      + sizeof(LeaseTimeToLiveResponse::_impl_.grantedttl_)
      - PROTOBUF_FIELD_OFFSET(LeaseTimeToLiveResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseTimeToLiveResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[35]);
}
// ===================================================================

class LeaseLeasesRequest::_Internal {
 public:
};

LeaseLeasesRequest::LeaseLeasesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseLeasesRequest)
}
LeaseLeasesRequest::LeaseLeasesRequest(const LeaseLeasesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  LeaseLeasesRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseLeasesRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseLeasesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseLeasesRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata LeaseLeasesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[36]);
}
// ===================================================================

class LeaseStatus::_Internal {
 public:
};

LeaseStatus::LeaseStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseStatus)
}
LeaseStatus::LeaseStatus(const LeaseStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseStatus)
}

inline void LeaseStatus::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseStatus::~LeaseStatus() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseStatus::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaseStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseStatus)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseStatus::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseStatus)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseStatus)
  return target;
}

::size_t LeaseStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseStatus)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseStatus::GetClassData() const { return &_class_data_; }


void LeaseStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseStatus*>(&to_msg);
  auto& from = static_cast<const LeaseStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseStatus)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseStatus::CopyFrom(const LeaseStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseStatus::IsInitialized() const {
  return true;
}

void LeaseStatus::InternalSwap(LeaseStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[37]);
}
// ===================================================================

class LeaseLeasesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaseLeasesResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LeaseLeasesResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const LeaseLeasesResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
LeaseLeasesResponse::_Internal::header(const LeaseLeasesResponse* msg) {
  return *msg->_impl_.header_;
}
LeaseLeasesResponse::LeaseLeasesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.LeaseLeasesResponse)
}
LeaseLeasesResponse::LeaseLeasesResponse(const LeaseLeasesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseLeasesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leases_){from._impl_.leases_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.LeaseLeasesResponse)
}

inline void LeaseLeasesResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leases_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

LeaseLeasesResponse::~LeaseLeasesResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.LeaseLeasesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseLeasesResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_leases()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LeaseLeasesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseLeasesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.LeaseLeasesResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_leases()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseLeasesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.LeaseStatus leases = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_leases(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeaseLeasesResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.LeaseLeasesResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.LeaseStatus leases = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_leases_size()); i < n; i++) {
    const auto& repfield = this->_internal_leases(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.LeaseLeasesResponse)
  return target;
}

::size_t LeaseLeasesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.LeaseLeasesResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.LeaseStatus leases = 2;
  total_size += 1UL * this->_internal_leases_size();
  for (const auto& msg : this->_internal_leases()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseLeasesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseLeasesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseLeasesResponse::GetClassData() const { return &_class_data_; }


void LeaseLeasesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseLeasesResponse*>(&to_msg);
  auto& from = static_cast<const LeaseLeasesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.LeaseLeasesResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_leases()->MergeFrom(from._internal_leases());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseLeasesResponse::CopyFrom(const LeaseLeasesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.LeaseLeasesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseLeasesResponse::IsInitialized() const {
  return true;
}

void LeaseLeasesResponse::InternalSwap(LeaseLeasesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_leases()->InternalSwap(other->_internal_mutable_leases());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseLeasesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[38]);
}
// ===================================================================

class Member::_Internal {
 public:
};

Member::Member(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.Member)
}
Member::Member(const Member& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Member* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){from._impl_.peerurls_}
    , decltype(_impl_.clienturls_){from._impl_.clienturls_}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.islearner_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.islearner_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.islearner_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.Member)
}

inline void Member::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){arena}
    , decltype(_impl_.clienturls_){arena}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.id_) { ::uint64_t{0u} }

    , decltype(_impl_.islearner_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Member::~Member() {
  // @@protoc_insertion_point(destructor:etcdserverpb.Member)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Member::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_peerurls()->~RepeatedPtrField();
  _internal_mutable_clienturls()->~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void Member::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Member::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.Member)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_peerurls()->Clear();
  _internal_mutable_clienturls()->Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.islearner_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.islearner_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Member::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.Member.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string peerURLs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_peerurls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.Member.peerURLs"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string clientURLs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_clienturls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.Member.clientURLs"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLearner = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.islearner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Member::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.Member)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.Member.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string peerURLs = 3;
  for (int i = 0, n = this->_internal_peerurls_size(); i < n; ++i) {
    const auto& s = this->_internal_peerurls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.Member.peerURLs");
    target = stream->WriteString(3, s, target);
  }

  // repeated string clientURLs = 4;
  for (int i = 0, n = this->_internal_clienturls_size(); i < n; ++i) {
    const auto& s = this->_internal_clienturls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.Member.clientURLs");
    target = stream->WriteString(4, s, target);
  }

  // bool isLearner = 5;
  if (this->_internal_islearner() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_islearner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.Member)
  return target;
}

::size_t Member::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.Member)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string peerURLs = 3;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_peerurls().size());
  for (int i = 0, n = _internal_peerurls().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_peerurls().Get(i));
  }

  // repeated string clientURLs = 4;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_clienturls().size());
  for (int i = 0, n = _internal_clienturls().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_clienturls().Get(i));
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_id());
  }

  // bool isLearner = 5;
  if (this->_internal_islearner() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Member::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Member::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Member::GetClassData() const { return &_class_data_; }


void Member::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Member*>(&to_msg);
  auto& from = static_cast<const Member&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.Member)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_peerurls()->MergeFrom(from._internal_peerurls());
  _this->_internal_mutable_clienturls()->MergeFrom(from._internal_clienturls());
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_islearner() != 0) {
    _this->_internal_set_islearner(from._internal_islearner());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Member::CopyFrom(const Member& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.Member)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Member::IsInitialized() const {
  return true;
}

void Member::InternalSwap(Member* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_peerurls()->InternalSwap(
      other->_internal_mutable_peerurls());
  _internal_mutable_clienturls()->InternalSwap(
      other->_internal_mutable_clienturls());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Member, _impl_.islearner_)
      + sizeof(Member::_impl_.islearner_)
      - PROTOBUF_FIELD_OFFSET(Member, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Member::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[39]);
}
// ===================================================================

class MemberAddRequest::_Internal {
 public:
};

MemberAddRequest::MemberAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberAddRequest)
}
MemberAddRequest::MemberAddRequest(const MemberAddRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberAddRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){from._impl_.peerurls_}
    , decltype(_impl_.islearner_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.islearner_ = from._impl_.islearner_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberAddRequest)
}

inline void MemberAddRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){arena}
    , decltype(_impl_.islearner_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MemberAddRequest::~MemberAddRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberAddRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberAddRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_peerurls()->~RepeatedPtrField();
}

void MemberAddRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberAddRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberAddRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_peerurls()->Clear();
  _impl_.islearner_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberAddRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string peerURLs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_peerurls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.MemberAddRequest.peerURLs"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLearner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.islearner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberAddRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberAddRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string peerURLs = 1;
  for (int i = 0, n = this->_internal_peerurls_size(); i < n; ++i) {
    const auto& s = this->_internal_peerurls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.MemberAddRequest.peerURLs");
    target = stream->WriteString(1, s, target);
  }

  // bool isLearner = 2;
  if (this->_internal_islearner() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_islearner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberAddRequest)
  return target;
}

::size_t MemberAddRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberAddRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string peerURLs = 1;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_peerurls().size());
  for (int i = 0, n = _internal_peerurls().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_peerurls().Get(i));
  }

  // bool isLearner = 2;
  if (this->_internal_islearner() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberAddRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberAddRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberAddRequest::GetClassData() const { return &_class_data_; }


void MemberAddRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberAddRequest*>(&to_msg);
  auto& from = static_cast<const MemberAddRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberAddRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_peerurls()->MergeFrom(from._internal_peerurls());
  if (from._internal_islearner() != 0) {
    _this->_internal_set_islearner(from._internal_islearner());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberAddRequest::CopyFrom(const MemberAddRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberAddRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberAddRequest::IsInitialized() const {
  return true;
}

void MemberAddRequest::InternalSwap(MemberAddRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_peerurls()->InternalSwap(
      other->_internal_mutable_peerurls());

  swap(_impl_.islearner_, other->_impl_.islearner_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberAddRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[40]);
}
// ===================================================================

class MemberAddResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MemberAddResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MemberAddResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MemberAddResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::etcdserverpb::Member& member(const MemberAddResponse* msg);
  static void set_has_member(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::etcdserverpb::ResponseHeader&
MemberAddResponse::_Internal::header(const MemberAddResponse* msg) {
  return *msg->_impl_.header_;
}
const ::etcdserverpb::Member&
MemberAddResponse::_Internal::member(const MemberAddResponse* msg) {
  return *msg->_impl_.member_;
}
MemberAddResponse::MemberAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberAddResponse)
}
MemberAddResponse::MemberAddResponse(const MemberAddResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberAddResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.member_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.member_ = new ::etcdserverpb::Member(*from._impl_.member_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberAddResponse)
}

inline void MemberAddResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.member_){nullptr}
  };
}

MemberAddResponse::~MemberAddResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberAddResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberAddResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_members()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.member_;
}

void MemberAddResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberAddResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberAddResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.member_ != nullptr);
      _impl_.member_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberAddResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.Member member = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_member(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.Member members = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberAddResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberAddResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .etcdserverpb.Member member = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::member(this),
        _Internal::member(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.Member members = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberAddResponse)
  return target;
}

::size_t MemberAddResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberAddResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Member members = 3;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_internal_members()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .etcdserverpb.ResponseHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // .etcdserverpb.Member member = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.member_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberAddResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberAddResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberAddResponse::GetClassData() const { return &_class_data_; }


void MemberAddResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberAddResponse*>(&to_msg);
  auto& from = static_cast<const MemberAddResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberAddResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_members()->MergeFrom(from._internal_members());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_member()->::etcdserverpb::Member::MergeFrom(
          from._internal_member());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberAddResponse::CopyFrom(const MemberAddResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberAddResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberAddResponse::IsInitialized() const {
  return true;
}

void MemberAddResponse::InternalSwap(MemberAddResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_members()->InternalSwap(other->_internal_mutable_members());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MemberAddResponse, _impl_.member_)
      + sizeof(MemberAddResponse::_impl_.member_)
      - PROTOBUF_FIELD_OFFSET(MemberAddResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberAddResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[41]);
}
// ===================================================================

class MemberRemoveRequest::_Internal {
 public:
};

MemberRemoveRequest::MemberRemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberRemoveRequest)
}
MemberRemoveRequest::MemberRemoveRequest(const MemberRemoveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberRemoveRequest)
}

inline void MemberRemoveRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MemberRemoveRequest::~MemberRemoveRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberRemoveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberRemoveRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MemberRemoveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberRemoveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberRemoveRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberRemoveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberRemoveRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberRemoveRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberRemoveRequest)
  return target;
}

::size_t MemberRemoveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberRemoveRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberRemoveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberRemoveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberRemoveRequest::GetClassData() const { return &_class_data_; }


void MemberRemoveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberRemoveRequest*>(&to_msg);
  auto& from = static_cast<const MemberRemoveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberRemoveRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberRemoveRequest::CopyFrom(const MemberRemoveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberRemoveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberRemoveRequest::IsInitialized() const {
  return true;
}

void MemberRemoveRequest::InternalSwap(MemberRemoveRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberRemoveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[42]);
}
// ===================================================================

class MemberRemoveResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MemberRemoveResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MemberRemoveResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MemberRemoveResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
MemberRemoveResponse::_Internal::header(const MemberRemoveResponse* msg) {
  return *msg->_impl_.header_;
}
MemberRemoveResponse::MemberRemoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberRemoveResponse)
}
MemberRemoveResponse::MemberRemoveResponse(const MemberRemoveResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberRemoveResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberRemoveResponse)
}

inline void MemberRemoveResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

MemberRemoveResponse::~MemberRemoveResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberRemoveResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberRemoveResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_members()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MemberRemoveResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberRemoveResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberRemoveResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberRemoveResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.Member members = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberRemoveResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberRemoveResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.Member members = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberRemoveResponse)
  return target;
}

::size_t MemberRemoveResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberRemoveResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Member members = 2;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_internal_members()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberRemoveResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberRemoveResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberRemoveResponse::GetClassData() const { return &_class_data_; }


void MemberRemoveResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberRemoveResponse*>(&to_msg);
  auto& from = static_cast<const MemberRemoveResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberRemoveResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_members()->MergeFrom(from._internal_members());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberRemoveResponse::CopyFrom(const MemberRemoveResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberRemoveResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberRemoveResponse::IsInitialized() const {
  return true;
}

void MemberRemoveResponse::InternalSwap(MemberRemoveResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_members()->InternalSwap(other->_internal_mutable_members());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberRemoveResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[43]);
}
// ===================================================================

class MemberUpdateRequest::_Internal {
 public:
};

MemberUpdateRequest::MemberUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberUpdateRequest)
}
MemberUpdateRequest::MemberUpdateRequest(const MemberUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){from._impl_.peerurls_}
    , decltype(_impl_.id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberUpdateRequest)
}

inline void MemberUpdateRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.peerurls_){arena}
    , decltype(_impl_.id_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MemberUpdateRequest::~MemberUpdateRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberUpdateRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_peerurls()->~RepeatedPtrField();
}

void MemberUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberUpdateRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_peerurls()->Clear();
  _impl_.id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string peerURLs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_peerurls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.MemberUpdateRequest.peerURLs"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberUpdateRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberUpdateRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_id(), target);
  }

  // repeated string peerURLs = 2;
  for (int i = 0, n = this->_internal_peerurls_size(); i < n; ++i) {
    const auto& s = this->_internal_peerurls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.MemberUpdateRequest.peerURLs");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberUpdateRequest)
  return target;
}

::size_t MemberUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberUpdateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string peerURLs = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_peerurls().size());
  for (int i = 0, n = _internal_peerurls().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_peerurls().Get(i));
  }

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberUpdateRequest::GetClassData() const { return &_class_data_; }


void MemberUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberUpdateRequest*>(&to_msg);
  auto& from = static_cast<const MemberUpdateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberUpdateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_peerurls()->MergeFrom(from._internal_peerurls());
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberUpdateRequest::CopyFrom(const MemberUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberUpdateRequest::IsInitialized() const {
  return true;
}

void MemberUpdateRequest::InternalSwap(MemberUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_peerurls()->InternalSwap(
      other->_internal_mutable_peerurls());

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberUpdateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[44]);
}
// ===================================================================

class MemberUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MemberUpdateResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MemberUpdateResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MemberUpdateResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
MemberUpdateResponse::_Internal::header(const MemberUpdateResponse* msg) {
  return *msg->_impl_.header_;
}
MemberUpdateResponse::MemberUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberUpdateResponse)
}
MemberUpdateResponse::MemberUpdateResponse(const MemberUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberUpdateResponse)
}

inline void MemberUpdateResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

MemberUpdateResponse::~MemberUpdateResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberUpdateResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_members()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MemberUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberUpdateResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.Member members = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberUpdateResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberUpdateResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.Member members = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberUpdateResponse)
  return target;
}

::size_t MemberUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberUpdateResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Member members = 2;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_internal_members()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberUpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberUpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberUpdateResponse::GetClassData() const { return &_class_data_; }


void MemberUpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberUpdateResponse*>(&to_msg);
  auto& from = static_cast<const MemberUpdateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberUpdateResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_members()->MergeFrom(from._internal_members());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberUpdateResponse::CopyFrom(const MemberUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberUpdateResponse::IsInitialized() const {
  return true;
}

void MemberUpdateResponse::InternalSwap(MemberUpdateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_members()->InternalSwap(other->_internal_mutable_members());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberUpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[45]);
}
// ===================================================================

class MemberListRequest::_Internal {
 public:
};

MemberListRequest::MemberListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberListRequest)
}
MemberListRequest::MemberListRequest(const MemberListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MemberListRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MemberListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[46]);
}
// ===================================================================

class MemberListResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MemberListResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MemberListResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MemberListResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
MemberListResponse::_Internal::header(const MemberListResponse* msg) {
  return *msg->_impl_.header_;
}
MemberListResponse::MemberListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberListResponse)
}
MemberListResponse::MemberListResponse(const MemberListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberListResponse)
}

inline void MemberListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

MemberListResponse::~MemberListResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_members()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MemberListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.Member members = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.Member members = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberListResponse)
  return target;
}

::size_t MemberListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Member members = 2;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_internal_members()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberListResponse::GetClassData() const { return &_class_data_; }


void MemberListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberListResponse*>(&to_msg);
  auto& from = static_cast<const MemberListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_members()->MergeFrom(from._internal_members());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberListResponse::CopyFrom(const MemberListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberListResponse::IsInitialized() const {
  return true;
}

void MemberListResponse::InternalSwap(MemberListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_members()->InternalSwap(other->_internal_mutable_members());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[47]);
}
// ===================================================================

class MemberPromoteRequest::_Internal {
 public:
};

MemberPromoteRequest::MemberPromoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberPromoteRequest)
}
MemberPromoteRequest::MemberPromoteRequest(const MemberPromoteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberPromoteRequest)
}

inline void MemberPromoteRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.id_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MemberPromoteRequest::~MemberPromoteRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberPromoteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberPromoteRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MemberPromoteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberPromoteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberPromoteRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberPromoteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 ID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberPromoteRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberPromoteRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberPromoteRequest)
  return target;
}

::size_t MemberPromoteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberPromoteRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 ID = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberPromoteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberPromoteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberPromoteRequest::GetClassData() const { return &_class_data_; }


void MemberPromoteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberPromoteRequest*>(&to_msg);
  auto& from = static_cast<const MemberPromoteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberPromoteRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberPromoteRequest::CopyFrom(const MemberPromoteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberPromoteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberPromoteRequest::IsInitialized() const {
  return true;
}

void MemberPromoteRequest::InternalSwap(MemberPromoteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberPromoteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[48]);
}
// ===================================================================

class MemberPromoteResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MemberPromoteResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MemberPromoteResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MemberPromoteResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
MemberPromoteResponse::_Internal::header(const MemberPromoteResponse* msg) {
  return *msg->_impl_.header_;
}
MemberPromoteResponse::MemberPromoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MemberPromoteResponse)
}
MemberPromoteResponse::MemberPromoteResponse(const MemberPromoteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemberPromoteResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MemberPromoteResponse)
}

inline void MemberPromoteResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

MemberPromoteResponse::~MemberPromoteResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MemberPromoteResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemberPromoteResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_members()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MemberPromoteResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemberPromoteResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MemberPromoteResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemberPromoteResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.Member members = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MemberPromoteResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MemberPromoteResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.Member members = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MemberPromoteResponse)
  return target;
}

::size_t MemberPromoteResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MemberPromoteResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.Member members = 2;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_internal_members()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemberPromoteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemberPromoteResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemberPromoteResponse::GetClassData() const { return &_class_data_; }


void MemberPromoteResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemberPromoteResponse*>(&to_msg);
  auto& from = static_cast<const MemberPromoteResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MemberPromoteResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_members()->MergeFrom(from._internal_members());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemberPromoteResponse::CopyFrom(const MemberPromoteResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MemberPromoteResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberPromoteResponse::IsInitialized() const {
  return true;
}

void MemberPromoteResponse::InternalSwap(MemberPromoteResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_members()->InternalSwap(other->_internal_mutable_members());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MemberPromoteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[49]);
}
// ===================================================================

class DefragmentRequest::_Internal {
 public:
};

DefragmentRequest::DefragmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.DefragmentRequest)
}
DefragmentRequest::DefragmentRequest(const DefragmentRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DefragmentRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.DefragmentRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefragmentRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefragmentRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DefragmentRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[50]);
}
// ===================================================================

class DefragmentResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DefragmentResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DefragmentResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const DefragmentResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
DefragmentResponse::_Internal::header(const DefragmentResponse* msg) {
  return *msg->_impl_.header_;
}
DefragmentResponse::DefragmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.DefragmentResponse)
}
DefragmentResponse::DefragmentResponse(const DefragmentResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DefragmentResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.DefragmentResponse)
}

inline void DefragmentResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

DefragmentResponse::~DefragmentResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.DefragmentResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefragmentResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DefragmentResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefragmentResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.DefragmentResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefragmentResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DefragmentResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.DefragmentResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.DefragmentResponse)
  return target;
}

::size_t DefragmentResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.DefragmentResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefragmentResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefragmentResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefragmentResponse::GetClassData() const { return &_class_data_; }


void DefragmentResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefragmentResponse*>(&to_msg);
  auto& from = static_cast<const DefragmentResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.DefragmentResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefragmentResponse::CopyFrom(const DefragmentResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.DefragmentResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefragmentResponse::IsInitialized() const {
  return true;
}

void DefragmentResponse::InternalSwap(DefragmentResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DefragmentResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[51]);
}
// ===================================================================

class MoveLeaderRequest::_Internal {
 public:
};

MoveLeaderRequest::MoveLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MoveLeaderRequest)
}
MoveLeaderRequest::MoveLeaderRequest(const MoveLeaderRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MoveLeaderRequest)
}

inline void MoveLeaderRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.targetid_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoveLeaderRequest::~MoveLeaderRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MoveLeaderRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveLeaderRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MoveLeaderRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveLeaderRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MoveLeaderRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.targetid_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveLeaderRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 targetID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.targetid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MoveLeaderRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MoveLeaderRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 targetID = 1;
  if (this->_internal_targetid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_targetid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MoveLeaderRequest)
  return target;
}

::size_t MoveLeaderRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MoveLeaderRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 targetID = 1;
  if (this->_internal_targetid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_targetid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveLeaderRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveLeaderRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveLeaderRequest::GetClassData() const { return &_class_data_; }


void MoveLeaderRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveLeaderRequest*>(&to_msg);
  auto& from = static_cast<const MoveLeaderRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MoveLeaderRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_targetid() != 0) {
    _this->_internal_set_targetid(from._internal_targetid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveLeaderRequest::CopyFrom(const MoveLeaderRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MoveLeaderRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveLeaderRequest::IsInitialized() const {
  return true;
}

void MoveLeaderRequest::InternalSwap(MoveLeaderRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.targetid_, other->_impl_.targetid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveLeaderRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[52]);
}
// ===================================================================

class MoveLeaderResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveLeaderResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MoveLeaderResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const MoveLeaderResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
MoveLeaderResponse::_Internal::header(const MoveLeaderResponse* msg) {
  return *msg->_impl_.header_;
}
MoveLeaderResponse::MoveLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.MoveLeaderResponse)
}
MoveLeaderResponse::MoveLeaderResponse(const MoveLeaderResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveLeaderResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.MoveLeaderResponse)
}

inline void MoveLeaderResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

MoveLeaderResponse::~MoveLeaderResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.MoveLeaderResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveLeaderResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MoveLeaderResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveLeaderResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.MoveLeaderResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveLeaderResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MoveLeaderResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.MoveLeaderResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.MoveLeaderResponse)
  return target;
}

::size_t MoveLeaderResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.MoveLeaderResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveLeaderResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveLeaderResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveLeaderResponse::GetClassData() const { return &_class_data_; }


void MoveLeaderResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveLeaderResponse*>(&to_msg);
  auto& from = static_cast<const MoveLeaderResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.MoveLeaderResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveLeaderResponse::CopyFrom(const MoveLeaderResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.MoveLeaderResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveLeaderResponse::IsInitialized() const {
  return true;
}

void MoveLeaderResponse::InternalSwap(MoveLeaderResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveLeaderResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[53]);
}
// ===================================================================

class AlarmRequest::_Internal {
 public:
};

AlarmRequest::AlarmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AlarmRequest)
}
AlarmRequest::AlarmRequest(const AlarmRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AlarmRequest)
}

inline void AlarmRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.memberid_) { ::uint64_t{0u} }

    , decltype(_impl_.action_) { 0 }

    , decltype(_impl_.alarm_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AlarmRequest::~AlarmRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AlarmRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AlarmRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AlarmRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AlarmRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AlarmRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.memberid_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.alarm_) -
      reinterpret_cast<char*>(&_impl_.memberid_)) + sizeof(_impl_.alarm_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AlarmRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.AlarmRequest.AlarmAction action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::etcdserverpb::AlarmRequest_AlarmAction>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 memberID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.memberid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.AlarmType alarm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_alarm(static_cast<::etcdserverpb::AlarmType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AlarmRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AlarmRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .etcdserverpb.AlarmRequest.AlarmAction action = 1;
  if (this->_internal_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_action(), target);
  }

  // uint64 memberID = 2;
  if (this->_internal_memberid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_memberid(), target);
  }

  // .etcdserverpb.AlarmType alarm = 3;
  if (this->_internal_alarm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_alarm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AlarmRequest)
  return target;
}

::size_t AlarmRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AlarmRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 memberID = 2;
  if (this->_internal_memberid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_memberid());
  }

  // .etcdserverpb.AlarmRequest.AlarmAction action = 1;
  if (this->_internal_action() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  // .etcdserverpb.AlarmType alarm = 3;
  if (this->_internal_alarm() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_alarm());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AlarmRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AlarmRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AlarmRequest::GetClassData() const { return &_class_data_; }


void AlarmRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AlarmRequest*>(&to_msg);
  auto& from = static_cast<const AlarmRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AlarmRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_memberid() != 0) {
    _this->_internal_set_memberid(from._internal_memberid());
  }
  if (from._internal_action() != 0) {
    _this->_internal_set_action(from._internal_action());
  }
  if (from._internal_alarm() != 0) {
    _this->_internal_set_alarm(from._internal_alarm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AlarmRequest::CopyFrom(const AlarmRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AlarmRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlarmRequest::IsInitialized() const {
  return true;
}

void AlarmRequest::InternalSwap(AlarmRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AlarmRequest, _impl_.alarm_)
      + sizeof(AlarmRequest::_impl_.alarm_)
      - PROTOBUF_FIELD_OFFSET(AlarmRequest, _impl_.memberid_)>(
          reinterpret_cast<char*>(&_impl_.memberid_),
          reinterpret_cast<char*>(&other->_impl_.memberid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AlarmRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[54]);
}
// ===================================================================

class AlarmMember::_Internal {
 public:
};

AlarmMember::AlarmMember(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AlarmMember)
}
AlarmMember::AlarmMember(const AlarmMember& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AlarmMember)
}

inline void AlarmMember::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.memberid_) { ::uint64_t{0u} }

    , decltype(_impl_.alarm_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AlarmMember::~AlarmMember() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AlarmMember)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AlarmMember::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AlarmMember::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AlarmMember::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AlarmMember)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.memberid_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.alarm_) -
      reinterpret_cast<char*>(&_impl_.memberid_)) + sizeof(_impl_.alarm_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AlarmMember::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 memberID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.memberid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .etcdserverpb.AlarmType alarm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_alarm(static_cast<::etcdserverpb::AlarmType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AlarmMember::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AlarmMember)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 memberID = 1;
  if (this->_internal_memberid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_memberid(), target);
  }

  // .etcdserverpb.AlarmType alarm = 2;
  if (this->_internal_alarm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_alarm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AlarmMember)
  return target;
}

::size_t AlarmMember::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AlarmMember)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 memberID = 1;
  if (this->_internal_memberid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_memberid());
  }

  // .etcdserverpb.AlarmType alarm = 2;
  if (this->_internal_alarm() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_alarm());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AlarmMember::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AlarmMember::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AlarmMember::GetClassData() const { return &_class_data_; }


void AlarmMember::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AlarmMember*>(&to_msg);
  auto& from = static_cast<const AlarmMember&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AlarmMember)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_memberid() != 0) {
    _this->_internal_set_memberid(from._internal_memberid());
  }
  if (from._internal_alarm() != 0) {
    _this->_internal_set_alarm(from._internal_alarm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AlarmMember::CopyFrom(const AlarmMember& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AlarmMember)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlarmMember::IsInitialized() const {
  return true;
}

void AlarmMember::InternalSwap(AlarmMember* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AlarmMember, _impl_.alarm_)
      + sizeof(AlarmMember::_impl_.alarm_)
      - PROTOBUF_FIELD_OFFSET(AlarmMember, _impl_.memberid_)>(
          reinterpret_cast<char*>(&_impl_.memberid_),
          reinterpret_cast<char*>(&other->_impl_.memberid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AlarmMember::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[55]);
}
// ===================================================================

class AlarmResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AlarmResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AlarmResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AlarmResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AlarmResponse::_Internal::header(const AlarmResponse* msg) {
  return *msg->_impl_.header_;
}
AlarmResponse::AlarmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AlarmResponse)
}
AlarmResponse::AlarmResponse(const AlarmResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AlarmResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alarms_){from._impl_.alarms_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AlarmResponse)
}

inline void AlarmResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alarms_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

AlarmResponse::~AlarmResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AlarmResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AlarmResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_alarms()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AlarmResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AlarmResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AlarmResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_alarms()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AlarmResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .etcdserverpb.AlarmMember alarms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alarms(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AlarmResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AlarmResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .etcdserverpb.AlarmMember alarms = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alarms_size()); i < n; i++) {
    const auto& repfield = this->_internal_alarms(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AlarmResponse)
  return target;
}

::size_t AlarmResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AlarmResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .etcdserverpb.AlarmMember alarms = 2;
  total_size += 1UL * this->_internal_alarms_size();
  for (const auto& msg : this->_internal_alarms()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AlarmResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AlarmResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AlarmResponse::GetClassData() const { return &_class_data_; }


void AlarmResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AlarmResponse*>(&to_msg);
  auto& from = static_cast<const AlarmResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AlarmResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_alarms()->MergeFrom(from._internal_alarms());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AlarmResponse::CopyFrom(const AlarmResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AlarmResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlarmResponse::IsInitialized() const {
  return true;
}

void AlarmResponse::InternalSwap(AlarmResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_alarms()->InternalSwap(other->_internal_mutable_alarms());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AlarmResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[56]);
}
// ===================================================================

class StatusRequest::_Internal {
 public:
};

StatusRequest::StatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.StatusRequest)
}
StatusRequest::StatusRequest(const StatusRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  StatusRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.StatusRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata StatusRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[57]);
}
// ===================================================================

class StatusResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatusResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const StatusResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
StatusResponse::_Internal::header(const StatusResponse* msg) {
  return *msg->_impl_.header_;
}
StatusResponse::StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.StatusResponse)
}
StatusResponse::StatusResponse(const StatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.errors_){from._impl_.errors_}
    , decltype(_impl_.version_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.dbsize_) {}

    , decltype(_impl_.leader_) {}

    , decltype(_impl_.raftindex_) {}

    , decltype(_impl_.raftterm_) {}

    , decltype(_impl_.raftappliedindex_) {}

    , decltype(_impl_.dbsizeinuse_) {}

    , decltype(_impl_.islearner_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.dbsize_, &from._impl_.dbsize_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.islearner_) -
    reinterpret_cast<char*>(&_impl_.dbsize_)) + sizeof(_impl_.islearner_));
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.StatusResponse)
}

inline void StatusResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.errors_){arena}
    , decltype(_impl_.version_) {}

    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.dbsize_) { ::int64_t{0} }

    , decltype(_impl_.leader_) { ::uint64_t{0u} }

    , decltype(_impl_.raftindex_) { ::uint64_t{0u} }

    , decltype(_impl_.raftterm_) { ::uint64_t{0u} }

    , decltype(_impl_.raftappliedindex_) { ::uint64_t{0u} }

    , decltype(_impl_.dbsizeinuse_) { ::int64_t{0} }

    , decltype(_impl_.islearner_) { false }

  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatusResponse::~StatusResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.StatusResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_errors()->~RepeatedPtrField();
  _impl_.version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void StatusResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.StatusResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_errors()->Clear();
  _impl_.version_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  ::memset(&_impl_.dbsize_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.islearner_) -
      reinterpret_cast<char*>(&_impl_.dbsize_)) + sizeof(_impl_.islearner_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.StatusResponse.version"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 dbSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.dbsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 leader = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.leader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 raftIndex = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.raftindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 raftTerm = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.raftterm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 raftAppliedIndex = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.raftappliedindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string errors = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_errors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.StatusResponse.errors"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 dbSizeInUse = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.dbsizeinuse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLearner = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.islearner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.StatusResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    const std::string& _s = this->_internal_version();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.StatusResponse.version");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 dbSize = 3;
  if (this->_internal_dbsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_dbsize(), target);
  }

  // uint64 leader = 4;
  if (this->_internal_leader() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_leader(), target);
  }

  // uint64 raftIndex = 5;
  if (this->_internal_raftindex() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_raftindex(), target);
  }

  // uint64 raftTerm = 6;
  if (this->_internal_raftterm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_raftterm(), target);
  }

  // uint64 raftAppliedIndex = 7;
  if (this->_internal_raftappliedindex() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_raftappliedindex(), target);
  }

  // repeated string errors = 8;
  for (int i = 0, n = this->_internal_errors_size(); i < n; ++i) {
    const auto& s = this->_internal_errors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.StatusResponse.errors");
    target = stream->WriteString(8, s, target);
  }

  // int64 dbSizeInUse = 9;
  if (this->_internal_dbsizeinuse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        9, this->_internal_dbsizeinuse(), target);
  }

  // bool isLearner = 10;
  if (this->_internal_islearner() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_islearner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.StatusResponse)
  return target;
}

::size_t StatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.StatusResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string errors = 8;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_errors().size());
  for (int i = 0, n = _internal_errors().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_errors().Get(i));
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_version());
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 dbSize = 3;
  if (this->_internal_dbsize() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_dbsize());
  }

  // uint64 leader = 4;
  if (this->_internal_leader() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_leader());
  }

  // uint64 raftIndex = 5;
  if (this->_internal_raftindex() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_raftindex());
  }

  // uint64 raftTerm = 6;
  if (this->_internal_raftterm() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_raftterm());
  }

  // uint64 raftAppliedIndex = 7;
  if (this->_internal_raftappliedindex() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_raftappliedindex());
  }

  // int64 dbSizeInUse = 9;
  if (this->_internal_dbsizeinuse() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_dbsizeinuse());
  }

  // bool isLearner = 10;
  if (this->_internal_islearner() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusResponse::GetClassData() const { return &_class_data_; }


void StatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusResponse*>(&to_msg);
  auto& from = static_cast<const StatusResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.StatusResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_errors()->MergeFrom(from._internal_errors());
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_dbsize() != 0) {
    _this->_internal_set_dbsize(from._internal_dbsize());
  }
  if (from._internal_leader() != 0) {
    _this->_internal_set_leader(from._internal_leader());
  }
  if (from._internal_raftindex() != 0) {
    _this->_internal_set_raftindex(from._internal_raftindex());
  }
  if (from._internal_raftterm() != 0) {
    _this->_internal_set_raftterm(from._internal_raftterm());
  }
  if (from._internal_raftappliedindex() != 0) {
    _this->_internal_set_raftappliedindex(from._internal_raftappliedindex());
  }
  if (from._internal_dbsizeinuse() != 0) {
    _this->_internal_set_dbsizeinuse(from._internal_dbsizeinuse());
  }
  if (from._internal_islearner() != 0) {
    _this->_internal_set_islearner(from._internal_islearner());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusResponse::CopyFrom(const StatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.StatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusResponse::IsInitialized() const {
  return true;
}

void StatusResponse::InternalSwap(StatusResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_errors()->InternalSwap(
      other->_internal_mutable_errors());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena,
                                       &other->_impl_.version_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusResponse, _impl_.islearner_)
      + sizeof(StatusResponse::_impl_.islearner_)
      - PROTOBUF_FIELD_OFFSET(StatusResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[58]);
}
// ===================================================================

class AuthEnableRequest::_Internal {
 public:
};

AuthEnableRequest::AuthEnableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthEnableRequest)
}
AuthEnableRequest::AuthEnableRequest(const AuthEnableRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AuthEnableRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthEnableRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthEnableRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthEnableRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AuthEnableRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[59]);
}
// ===================================================================

class AuthDisableRequest::_Internal {
 public:
};

AuthDisableRequest::AuthDisableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthDisableRequest)
}
AuthDisableRequest::AuthDisableRequest(const AuthDisableRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AuthDisableRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthDisableRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthDisableRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthDisableRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AuthDisableRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[60]);
}
// ===================================================================

class AuthenticateRequest::_Internal {
 public:
};

AuthenticateRequest::AuthenticateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthenticateRequest)
}
AuthenticateRequest::AuthenticateRequest(const AuthenticateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthenticateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthenticateRequest)
}

inline void AuthenticateRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthenticateRequest::~AuthenticateRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthenticateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthenticateRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.password_.Destroy();
}

void AuthenticateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthenticateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthenticateRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthenticateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthenticateRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthenticateRequest.password"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthenticateRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthenticateRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthenticateRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    const std::string& _s = this->_internal_password();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthenticateRequest.password");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthenticateRequest)
  return target;
}

::size_t AuthenticateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthenticateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthenticateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthenticateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthenticateRequest::GetClassData() const { return &_class_data_; }


void AuthenticateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthenticateRequest*>(&to_msg);
  auto& from = static_cast<const AuthenticateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthenticateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthenticateRequest::CopyFrom(const AuthenticateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthenticateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticateRequest::IsInitialized() const {
  return true;
}

void AuthenticateRequest::InternalSwap(AuthenticateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, lhs_arena,
                                       &other->_impl_.password_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthenticateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[61]);
}
// ===================================================================

class AuthUserAddRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserAddRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserAddRequest, _impl_._has_bits_);
  static const ::authpb::UserAddOptions& options(const AuthUserAddRequest* msg);
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::authpb::UserAddOptions&
AuthUserAddRequest::_Internal::options(const AuthUserAddRequest* msg) {
  return *msg->_impl_.options_;
}
void AuthUserAddRequest::clear_options() {
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AuthUserAddRequest::AuthUserAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserAddRequest)
}
AuthUserAddRequest::AuthUserAddRequest(const AuthUserAddRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserAddRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , decltype(_impl_.options_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.options_ = new ::authpb::UserAddOptions(*from._impl_.options_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserAddRequest)
}

inline void AuthUserAddRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , decltype(_impl_.options_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserAddRequest::~AuthUserAddRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserAddRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserAddRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.options_;
}

void AuthUserAddRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserAddRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserAddRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.options_ != nullptr);
    _impl_.options_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserAddRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserAddRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserAddRequest.password"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .authpb.UserAddOptions options = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserAddRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserAddRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserAddRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    const std::string& _s = this->_internal_password();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserAddRequest.password");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .authpb.UserAddOptions options = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserAddRequest)
  return target;
}

::size_t AuthUserAddRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserAddRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_password());
  }

  // .authpb.UserAddOptions options = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserAddRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserAddRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserAddRequest::GetClassData() const { return &_class_data_; }


void AuthUserAddRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserAddRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserAddRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserAddRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_options()->::authpb::UserAddOptions::MergeFrom(
        from._internal_options());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserAddRequest::CopyFrom(const AuthUserAddRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserAddRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserAddRequest::IsInitialized() const {
  return true;
}

void AuthUserAddRequest::InternalSwap(AuthUserAddRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, lhs_arena,
                                       &other->_impl_.password_, rhs_arena);
  swap(_impl_.options_, other->_impl_.options_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserAddRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[62]);
}
// ===================================================================

class AuthUserGetRequest::_Internal {
 public:
};

AuthUserGetRequest::AuthUserGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserGetRequest)
}
AuthUserGetRequest::AuthUserGetRequest(const AuthUserGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserGetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserGetRequest)
}

inline void AuthUserGetRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserGetRequest::~AuthUserGetRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserGetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserGetRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void AuthUserGetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserGetRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserGetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserGetRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserGetRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserGetRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserGetRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserGetRequest)
  return target;
}

::size_t AuthUserGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserGetRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserGetRequest::GetClassData() const { return &_class_data_; }


void AuthUserGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserGetRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserGetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserGetRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserGetRequest::CopyFrom(const AuthUserGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserGetRequest::IsInitialized() const {
  return true;
}

void AuthUserGetRequest::InternalSwap(AuthUserGetRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserGetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[63]);
}
// ===================================================================

class AuthUserDeleteRequest::_Internal {
 public:
};

AuthUserDeleteRequest::AuthUserDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserDeleteRequest)
}
AuthUserDeleteRequest::AuthUserDeleteRequest(const AuthUserDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserDeleteRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserDeleteRequest)
}

inline void AuthUserDeleteRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserDeleteRequest::~AuthUserDeleteRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserDeleteRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void AuthUserDeleteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserDeleteRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserDeleteRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserDeleteRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserDeleteRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserDeleteRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserDeleteRequest)
  return target;
}

::size_t AuthUserDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserDeleteRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserDeleteRequest::GetClassData() const { return &_class_data_; }


void AuthUserDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserDeleteRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserDeleteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserDeleteRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserDeleteRequest::CopyFrom(const AuthUserDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserDeleteRequest::IsInitialized() const {
  return true;
}

void AuthUserDeleteRequest::InternalSwap(AuthUserDeleteRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[64]);
}
// ===================================================================

class AuthUserChangePasswordRequest::_Internal {
 public:
};

AuthUserChangePasswordRequest::AuthUserChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserChangePasswordRequest)
}
AuthUserChangePasswordRequest::AuthUserChangePasswordRequest(const AuthUserChangePasswordRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserChangePasswordRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserChangePasswordRequest)
}

inline void AuthUserChangePasswordRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.password_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserChangePasswordRequest::~AuthUserChangePasswordRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserChangePasswordRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserChangePasswordRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.password_.Destroy();
}

void AuthUserChangePasswordRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserChangePasswordRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserChangePasswordRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserChangePasswordRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserChangePasswordRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserChangePasswordRequest.password"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserChangePasswordRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserChangePasswordRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserChangePasswordRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    const std::string& _s = this->_internal_password();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserChangePasswordRequest.password");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserChangePasswordRequest)
  return target;
}

::size_t AuthUserChangePasswordRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserChangePasswordRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserChangePasswordRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserChangePasswordRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserChangePasswordRequest::GetClassData() const { return &_class_data_; }


void AuthUserChangePasswordRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserChangePasswordRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserChangePasswordRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserChangePasswordRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserChangePasswordRequest::CopyFrom(const AuthUserChangePasswordRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserChangePasswordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserChangePasswordRequest::IsInitialized() const {
  return true;
}

void AuthUserChangePasswordRequest::InternalSwap(AuthUserChangePasswordRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, lhs_arena,
                                       &other->_impl_.password_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserChangePasswordRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[65]);
}
// ===================================================================

class AuthUserGrantRoleRequest::_Internal {
 public:
};

AuthUserGrantRoleRequest::AuthUserGrantRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserGrantRoleRequest)
}
AuthUserGrantRoleRequest::AuthUserGrantRoleRequest(const AuthUserGrantRoleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserGrantRoleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_) {}

    , decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.user_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), _this->GetArenaForAllocation());
  }
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_role().empty()) {
    _this->_impl_.role_.Set(from._internal_role(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserGrantRoleRequest)
}

inline void AuthUserGrantRoleRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.user_) {}

    , decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.user_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserGrantRoleRequest::~AuthUserGrantRoleRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserGrantRoleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserGrantRoleRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.role_.Destroy();
}

void AuthUserGrantRoleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserGrantRoleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserGrantRoleRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.ClearToEmpty();
  _impl_.role_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserGrantRoleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserGrantRoleRequest.user"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserGrantRoleRequest.role"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserGrantRoleRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserGrantRoleRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user = 1;
  if (!this->_internal_user().empty()) {
    const std::string& _s = this->_internal_user();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserGrantRoleRequest.user");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string role = 2;
  if (!this->_internal_role().empty()) {
    const std::string& _s = this->_internal_role();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserGrantRoleRequest.role");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserGrantRoleRequest)
  return target;
}

::size_t AuthUserGrantRoleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserGrantRoleRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user = 1;
  if (!this->_internal_user().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_user());
  }

  // string role = 2;
  if (!this->_internal_role().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserGrantRoleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserGrantRoleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserGrantRoleRequest::GetClassData() const { return &_class_data_; }


void AuthUserGrantRoleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserGrantRoleRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserGrantRoleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserGrantRoleRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_role().empty()) {
    _this->_internal_set_role(from._internal_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserGrantRoleRequest::CopyFrom(const AuthUserGrantRoleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserGrantRoleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserGrantRoleRequest::IsInitialized() const {
  return true;
}

void AuthUserGrantRoleRequest::InternalSwap(AuthUserGrantRoleRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.user_, lhs_arena,
                                       &other->_impl_.user_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_, lhs_arena,
                                       &other->_impl_.role_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserGrantRoleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[66]);
}
// ===================================================================

class AuthUserRevokeRoleRequest::_Internal {
 public:
};

AuthUserRevokeRoleRequest::AuthUserRevokeRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserRevokeRoleRequest)
}
AuthUserRevokeRoleRequest::AuthUserRevokeRoleRequest(const AuthUserRevokeRoleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserRevokeRoleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_role().empty()) {
    _this->_impl_.role_.Set(from._internal_role(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserRevokeRoleRequest)
}

inline void AuthUserRevokeRoleRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthUserRevokeRoleRequest::~AuthUserRevokeRoleRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserRevokeRoleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserRevokeRoleRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.role_.Destroy();
}

void AuthUserRevokeRoleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserRevokeRoleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserRevokeRoleRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.role_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserRevokeRoleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserRevokeRoleRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserRevokeRoleRequest.role"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserRevokeRoleRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserRevokeRoleRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserRevokeRoleRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string role = 2;
  if (!this->_internal_role().empty()) {
    const std::string& _s = this->_internal_role();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserRevokeRoleRequest.role");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserRevokeRoleRequest)
  return target;
}

::size_t AuthUserRevokeRoleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserRevokeRoleRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string role = 2;
  if (!this->_internal_role().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserRevokeRoleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserRevokeRoleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserRevokeRoleRequest::GetClassData() const { return &_class_data_; }


void AuthUserRevokeRoleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserRevokeRoleRequest*>(&to_msg);
  auto& from = static_cast<const AuthUserRevokeRoleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserRevokeRoleRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_role().empty()) {
    _this->_internal_set_role(from._internal_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserRevokeRoleRequest::CopyFrom(const AuthUserRevokeRoleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserRevokeRoleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserRevokeRoleRequest::IsInitialized() const {
  return true;
}

void AuthUserRevokeRoleRequest::InternalSwap(AuthUserRevokeRoleRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_, lhs_arena,
                                       &other->_impl_.role_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserRevokeRoleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[67]);
}
// ===================================================================

class AuthRoleAddRequest::_Internal {
 public:
};

AuthRoleAddRequest::AuthRoleAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleAddRequest)
}
AuthRoleAddRequest::AuthRoleAddRequest(const AuthRoleAddRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleAddRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleAddRequest)
}

inline void AuthRoleAddRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthRoleAddRequest::~AuthRoleAddRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleAddRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleAddRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void AuthRoleAddRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleAddRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleAddRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleAddRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleAddRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleAddRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleAddRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleAddRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleAddRequest)
  return target;
}

::size_t AuthRoleAddRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleAddRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleAddRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleAddRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleAddRequest::GetClassData() const { return &_class_data_; }


void AuthRoleAddRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleAddRequest*>(&to_msg);
  auto& from = static_cast<const AuthRoleAddRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleAddRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleAddRequest::CopyFrom(const AuthRoleAddRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleAddRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleAddRequest::IsInitialized() const {
  return true;
}

void AuthRoleAddRequest::InternalSwap(AuthRoleAddRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleAddRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[68]);
}
// ===================================================================

class AuthRoleGetRequest::_Internal {
 public:
};

AuthRoleGetRequest::AuthRoleGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleGetRequest)
}
AuthRoleGetRequest::AuthRoleGetRequest(const AuthRoleGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleGetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_role().empty()) {
    _this->_impl_.role_.Set(from._internal_role(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleGetRequest)
}

inline void AuthRoleGetRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthRoleGetRequest::~AuthRoleGetRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleGetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleGetRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_.Destroy();
}

void AuthRoleGetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleGetRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleGetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleGetRequest.role"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleGetRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleGetRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    const std::string& _s = this->_internal_role();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleGetRequest.role");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleGetRequest)
  return target;
}

::size_t AuthRoleGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleGetRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleGetRequest::GetClassData() const { return &_class_data_; }


void AuthRoleGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleGetRequest*>(&to_msg);
  auto& from = static_cast<const AuthRoleGetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleGetRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_role().empty()) {
    _this->_internal_set_role(from._internal_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleGetRequest::CopyFrom(const AuthRoleGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleGetRequest::IsInitialized() const {
  return true;
}

void AuthRoleGetRequest::InternalSwap(AuthRoleGetRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_, lhs_arena,
                                       &other->_impl_.role_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleGetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[69]);
}
// ===================================================================

class AuthUserListRequest::_Internal {
 public:
};

AuthUserListRequest::AuthUserListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserListRequest)
}
AuthUserListRequest::AuthUserListRequest(const AuthUserListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AuthUserListRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AuthUserListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[70]);
}
// ===================================================================

class AuthRoleListRequest::_Internal {
 public:
};

AuthRoleListRequest::AuthRoleListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleListRequest)
}
AuthRoleListRequest::AuthRoleListRequest(const AuthRoleListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AuthRoleListRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[71]);
}
// ===================================================================

class AuthRoleDeleteRequest::_Internal {
 public:
};

AuthRoleDeleteRequest::AuthRoleDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleDeleteRequest)
}
AuthRoleDeleteRequest::AuthRoleDeleteRequest(const AuthRoleDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleDeleteRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_role().empty()) {
    _this->_impl_.role_.Set(from._internal_role(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleDeleteRequest)
}

inline void AuthRoleDeleteRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthRoleDeleteRequest::~AuthRoleDeleteRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleDeleteRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_.Destroy();
}

void AuthRoleDeleteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleDeleteRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleDeleteRequest.role"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleDeleteRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleDeleteRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    const std::string& _s = this->_internal_role();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleDeleteRequest.role");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleDeleteRequest)
  return target;
}

::size_t AuthRoleDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleDeleteRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleDeleteRequest::GetClassData() const { return &_class_data_; }


void AuthRoleDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleDeleteRequest*>(&to_msg);
  auto& from = static_cast<const AuthRoleDeleteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleDeleteRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_role().empty()) {
    _this->_internal_set_role(from._internal_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleDeleteRequest::CopyFrom(const AuthRoleDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleDeleteRequest::IsInitialized() const {
  return true;
}

void AuthRoleDeleteRequest::InternalSwap(AuthRoleDeleteRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_, lhs_arena,
                                       &other->_impl_.role_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[72]);
}
// ===================================================================

class AuthRoleGrantPermissionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleGrantPermissionRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleGrantPermissionRequest, _impl_._has_bits_);
  static const ::authpb::Permission& perm(const AuthRoleGrantPermissionRequest* msg);
  static void set_has_perm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::authpb::Permission&
AuthRoleGrantPermissionRequest::_Internal::perm(const AuthRoleGrantPermissionRequest* msg) {
  return *msg->_impl_.perm_;
}
void AuthRoleGrantPermissionRequest::clear_perm() {
  if (_impl_.perm_ != nullptr) _impl_.perm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AuthRoleGrantPermissionRequest::AuthRoleGrantPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleGrantPermissionRequest)
}
AuthRoleGrantPermissionRequest::AuthRoleGrantPermissionRequest(const AuthRoleGrantPermissionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleGrantPermissionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.perm_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.perm_ = new ::authpb::Permission(*from._impl_.perm_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleGrantPermissionRequest)
}

inline void AuthRoleGrantPermissionRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.perm_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthRoleGrantPermissionRequest::~AuthRoleGrantPermissionRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleGrantPermissionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleGrantPermissionRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.perm_;
}

void AuthRoleGrantPermissionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleGrantPermissionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleGrantPermissionRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.perm_ != nullptr);
    _impl_.perm_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleGrantPermissionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleGrantPermissionRequest.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .authpb.Permission perm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_perm(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleGrantPermissionRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleGrantPermissionRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleGrantPermissionRequest.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .authpb.Permission perm = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::perm(this),
        _Internal::perm(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleGrantPermissionRequest)
  return target;
}

::size_t AuthRoleGrantPermissionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleGrantPermissionRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // .authpb.Permission perm = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.perm_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleGrantPermissionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleGrantPermissionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleGrantPermissionRequest::GetClassData() const { return &_class_data_; }


void AuthRoleGrantPermissionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleGrantPermissionRequest*>(&to_msg);
  auto& from = static_cast<const AuthRoleGrantPermissionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleGrantPermissionRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_perm()->::authpb::Permission::MergeFrom(
        from._internal_perm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleGrantPermissionRequest::CopyFrom(const AuthRoleGrantPermissionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleGrantPermissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleGrantPermissionRequest::IsInitialized() const {
  return true;
}

void AuthRoleGrantPermissionRequest::InternalSwap(AuthRoleGrantPermissionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  swap(_impl_.perm_, other->_impl_.perm_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleGrantPermissionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[73]);
}
// ===================================================================

class AuthRoleRevokePermissionRequest::_Internal {
 public:
};

AuthRoleRevokePermissionRequest::AuthRoleRevokePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleRevokePermissionRequest)
}
AuthRoleRevokePermissionRequest::AuthRoleRevokePermissionRequest(const AuthRoleRevokePermissionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleRevokePermissionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_role().empty()) {
    _this->_impl_.role_.Set(from._internal_role(), _this->GetArenaForAllocation());
  }
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleRevokePermissionRequest)
}

inline void AuthRoleRevokePermissionRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.role_) {}

    , decltype(_impl_.key_) {}

    , decltype(_impl_.range_end_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.role_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthRoleRevokePermissionRequest::~AuthRoleRevokePermissionRequest() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleRevokePermissionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleRevokePermissionRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_.Destroy();
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
}

void AuthRoleRevokePermissionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleRevokePermissionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleRevokePermissionRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_.ClearToEmpty();
  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleRevokePermissionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleRevokePermissionRequest.role"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes range_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleRevokePermissionRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleRevokePermissionRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    const std::string& _s = this->_internal_role();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleRevokePermissionRequest.role");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    const std::string& _s = this->_internal_range_end();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleRevokePermissionRequest)
  return target;
}

::size_t AuthRoleRevokePermissionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleRevokePermissionRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string role = 1;
  if (!this->_internal_role().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_role());
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_range_end());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleRevokePermissionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleRevokePermissionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleRevokePermissionRequest::GetClassData() const { return &_class_data_; }


void AuthRoleRevokePermissionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleRevokePermissionRequest*>(&to_msg);
  auto& from = static_cast<const AuthRoleRevokePermissionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleRevokePermissionRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_role().empty()) {
    _this->_internal_set_role(from._internal_role());
  }
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleRevokePermissionRequest::CopyFrom(const AuthRoleRevokePermissionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleRevokePermissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleRevokePermissionRequest::IsInitialized() const {
  return true;
}

void AuthRoleRevokePermissionRequest::InternalSwap(AuthRoleRevokePermissionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_, lhs_arena,
                                       &other->_impl_.role_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.range_end_, lhs_arena,
                                       &other->_impl_.range_end_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleRevokePermissionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[74]);
}
// ===================================================================

class AuthEnableResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthEnableResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthEnableResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthEnableResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthEnableResponse::_Internal::header(const AuthEnableResponse* msg) {
  return *msg->_impl_.header_;
}
AuthEnableResponse::AuthEnableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthEnableResponse)
}
AuthEnableResponse::AuthEnableResponse(const AuthEnableResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthEnableResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthEnableResponse)
}

inline void AuthEnableResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthEnableResponse::~AuthEnableResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthEnableResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthEnableResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthEnableResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthEnableResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthEnableResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthEnableResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthEnableResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthEnableResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthEnableResponse)
  return target;
}

::size_t AuthEnableResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthEnableResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthEnableResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthEnableResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthEnableResponse::GetClassData() const { return &_class_data_; }


void AuthEnableResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthEnableResponse*>(&to_msg);
  auto& from = static_cast<const AuthEnableResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthEnableResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthEnableResponse::CopyFrom(const AuthEnableResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthEnableResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthEnableResponse::IsInitialized() const {
  return true;
}

void AuthEnableResponse::InternalSwap(AuthEnableResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthEnableResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[75]);
}
// ===================================================================

class AuthDisableResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthDisableResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthDisableResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthDisableResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthDisableResponse::_Internal::header(const AuthDisableResponse* msg) {
  return *msg->_impl_.header_;
}
AuthDisableResponse::AuthDisableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthDisableResponse)
}
AuthDisableResponse::AuthDisableResponse(const AuthDisableResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthDisableResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthDisableResponse)
}

inline void AuthDisableResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthDisableResponse::~AuthDisableResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthDisableResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthDisableResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthDisableResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthDisableResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthDisableResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthDisableResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthDisableResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthDisableResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthDisableResponse)
  return target;
}

::size_t AuthDisableResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthDisableResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthDisableResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthDisableResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthDisableResponse::GetClassData() const { return &_class_data_; }


void AuthDisableResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthDisableResponse*>(&to_msg);
  auto& from = static_cast<const AuthDisableResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthDisableResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthDisableResponse::CopyFrom(const AuthDisableResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthDisableResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthDisableResponse::IsInitialized() const {
  return true;
}

void AuthDisableResponse::InternalSwap(AuthDisableResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthDisableResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[76]);
}
// ===================================================================

class AuthenticateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticateResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthenticateResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthenticateResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthenticateResponse::_Internal::header(const AuthenticateResponse* msg) {
  return *msg->_impl_.header_;
}
AuthenticateResponse::AuthenticateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthenticateResponse)
}
AuthenticateResponse::AuthenticateResponse(const AuthenticateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthenticateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_) {}

    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token().empty()) {
    _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthenticateResponse)
}

inline void AuthenticateResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_) {}

    , decltype(_impl_.header_){nullptr}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthenticateResponse::~AuthenticateResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthenticateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthenticateResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthenticateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthenticateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthenticateResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.token_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthenticateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthenticateResponse.token"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthenticateResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthenticateResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string token = 2;
  if (!this->_internal_token().empty()) {
    const std::string& _s = this->_internal_token();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthenticateResponse.token");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthenticateResponse)
  return target;
}

::size_t AuthenticateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthenticateResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string token = 2;
  if (!this->_internal_token().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_token());
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthenticateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthenticateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthenticateResponse::GetClassData() const { return &_class_data_; }


void AuthenticateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthenticateResponse*>(&to_msg);
  auto& from = static_cast<const AuthenticateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthenticateResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_token().empty()) {
    _this->_internal_set_token(from._internal_token());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthenticateResponse::CopyFrom(const AuthenticateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthenticateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticateResponse::IsInitialized() const {
  return true;
}

void AuthenticateResponse::InternalSwap(AuthenticateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena,
                                       &other->_impl_.token_, rhs_arena);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthenticateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[77]);
}
// ===================================================================

class AuthUserAddResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserAddResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserAddResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserAddResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserAddResponse::_Internal::header(const AuthUserAddResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserAddResponse::AuthUserAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserAddResponse)
}
AuthUserAddResponse::AuthUserAddResponse(const AuthUserAddResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserAddResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserAddResponse)
}

inline void AuthUserAddResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserAddResponse::~AuthUserAddResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserAddResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserAddResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserAddResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserAddResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserAddResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserAddResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserAddResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserAddResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserAddResponse)
  return target;
}

::size_t AuthUserAddResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserAddResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserAddResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserAddResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserAddResponse::GetClassData() const { return &_class_data_; }


void AuthUserAddResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserAddResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserAddResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserAddResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserAddResponse::CopyFrom(const AuthUserAddResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserAddResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserAddResponse::IsInitialized() const {
  return true;
}

void AuthUserAddResponse::InternalSwap(AuthUserAddResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserAddResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[78]);
}
// ===================================================================

class AuthUserGetResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserGetResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserGetResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserGetResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserGetResponse::_Internal::header(const AuthUserGetResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserGetResponse::AuthUserGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserGetResponse)
}
AuthUserGetResponse::AuthUserGetResponse(const AuthUserGetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserGetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roles_){from._impl_.roles_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserGetResponse)
}

inline void AuthUserGetResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roles_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserGetResponse::~AuthUserGetResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserGetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserGetResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_roles()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserGetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserGetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserGetResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_roles()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserGetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string roles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_roles();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserGetResponse.roles"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserGetResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserGetResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated string roles = 2;
  for (int i = 0, n = this->_internal_roles_size(); i < n; ++i) {
    const auto& s = this->_internal_roles(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserGetResponse.roles");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserGetResponse)
  return target;
}

::size_t AuthUserGetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserGetResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string roles = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_roles().size());
  for (int i = 0, n = _internal_roles().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_roles().Get(i));
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserGetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserGetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserGetResponse::GetClassData() const { return &_class_data_; }


void AuthUserGetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserGetResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserGetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserGetResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_roles()->MergeFrom(from._internal_roles());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserGetResponse::CopyFrom(const AuthUserGetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserGetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserGetResponse::IsInitialized() const {
  return true;
}

void AuthUserGetResponse::InternalSwap(AuthUserGetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_roles()->InternalSwap(
      other->_internal_mutable_roles());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserGetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[79]);
}
// ===================================================================

class AuthUserDeleteResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserDeleteResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserDeleteResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserDeleteResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserDeleteResponse::_Internal::header(const AuthUserDeleteResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserDeleteResponse::AuthUserDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserDeleteResponse)
}
AuthUserDeleteResponse::AuthUserDeleteResponse(const AuthUserDeleteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserDeleteResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserDeleteResponse)
}

inline void AuthUserDeleteResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserDeleteResponse::~AuthUserDeleteResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserDeleteResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserDeleteResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserDeleteResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserDeleteResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserDeleteResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserDeleteResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserDeleteResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserDeleteResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserDeleteResponse)
  return target;
}

::size_t AuthUserDeleteResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserDeleteResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserDeleteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserDeleteResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserDeleteResponse::GetClassData() const { return &_class_data_; }


void AuthUserDeleteResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserDeleteResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserDeleteResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserDeleteResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserDeleteResponse::CopyFrom(const AuthUserDeleteResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserDeleteResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserDeleteResponse::IsInitialized() const {
  return true;
}

void AuthUserDeleteResponse::InternalSwap(AuthUserDeleteResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserDeleteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[80]);
}
// ===================================================================

class AuthUserChangePasswordResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserChangePasswordResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserChangePasswordResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserChangePasswordResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserChangePasswordResponse::_Internal::header(const AuthUserChangePasswordResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserChangePasswordResponse::AuthUserChangePasswordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserChangePasswordResponse)
}
AuthUserChangePasswordResponse::AuthUserChangePasswordResponse(const AuthUserChangePasswordResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserChangePasswordResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserChangePasswordResponse)
}

inline void AuthUserChangePasswordResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserChangePasswordResponse::~AuthUserChangePasswordResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserChangePasswordResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserChangePasswordResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserChangePasswordResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserChangePasswordResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserChangePasswordResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserChangePasswordResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserChangePasswordResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserChangePasswordResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserChangePasswordResponse)
  return target;
}

::size_t AuthUserChangePasswordResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserChangePasswordResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserChangePasswordResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserChangePasswordResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserChangePasswordResponse::GetClassData() const { return &_class_data_; }


void AuthUserChangePasswordResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserChangePasswordResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserChangePasswordResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserChangePasswordResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserChangePasswordResponse::CopyFrom(const AuthUserChangePasswordResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserChangePasswordResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserChangePasswordResponse::IsInitialized() const {
  return true;
}

void AuthUserChangePasswordResponse::InternalSwap(AuthUserChangePasswordResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserChangePasswordResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[81]);
}
// ===================================================================

class AuthUserGrantRoleResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserGrantRoleResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserGrantRoleResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserGrantRoleResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserGrantRoleResponse::_Internal::header(const AuthUserGrantRoleResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserGrantRoleResponse::AuthUserGrantRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserGrantRoleResponse)
}
AuthUserGrantRoleResponse::AuthUserGrantRoleResponse(const AuthUserGrantRoleResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserGrantRoleResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserGrantRoleResponse)
}

inline void AuthUserGrantRoleResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserGrantRoleResponse::~AuthUserGrantRoleResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserGrantRoleResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserGrantRoleResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserGrantRoleResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserGrantRoleResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserGrantRoleResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserGrantRoleResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserGrantRoleResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserGrantRoleResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserGrantRoleResponse)
  return target;
}

::size_t AuthUserGrantRoleResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserGrantRoleResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserGrantRoleResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserGrantRoleResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserGrantRoleResponse::GetClassData() const { return &_class_data_; }


void AuthUserGrantRoleResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserGrantRoleResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserGrantRoleResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserGrantRoleResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserGrantRoleResponse::CopyFrom(const AuthUserGrantRoleResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserGrantRoleResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserGrantRoleResponse::IsInitialized() const {
  return true;
}

void AuthUserGrantRoleResponse::InternalSwap(AuthUserGrantRoleResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserGrantRoleResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[82]);
}
// ===================================================================

class AuthUserRevokeRoleResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserRevokeRoleResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserRevokeRoleResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserRevokeRoleResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserRevokeRoleResponse::_Internal::header(const AuthUserRevokeRoleResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserRevokeRoleResponse::AuthUserRevokeRoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserRevokeRoleResponse)
}
AuthUserRevokeRoleResponse::AuthUserRevokeRoleResponse(const AuthUserRevokeRoleResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserRevokeRoleResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserRevokeRoleResponse)
}

inline void AuthUserRevokeRoleResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserRevokeRoleResponse::~AuthUserRevokeRoleResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserRevokeRoleResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserRevokeRoleResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserRevokeRoleResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserRevokeRoleResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserRevokeRoleResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserRevokeRoleResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserRevokeRoleResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserRevokeRoleResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserRevokeRoleResponse)
  return target;
}

::size_t AuthUserRevokeRoleResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserRevokeRoleResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserRevokeRoleResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserRevokeRoleResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserRevokeRoleResponse::GetClassData() const { return &_class_data_; }


void AuthUserRevokeRoleResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserRevokeRoleResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserRevokeRoleResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserRevokeRoleResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserRevokeRoleResponse::CopyFrom(const AuthUserRevokeRoleResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserRevokeRoleResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserRevokeRoleResponse::IsInitialized() const {
  return true;
}

void AuthUserRevokeRoleResponse::InternalSwap(AuthUserRevokeRoleResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserRevokeRoleResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[83]);
}
// ===================================================================

class AuthRoleAddResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleAddResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleAddResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleAddResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleAddResponse::_Internal::header(const AuthRoleAddResponse* msg) {
  return *msg->_impl_.header_;
}
AuthRoleAddResponse::AuthRoleAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleAddResponse)
}
AuthRoleAddResponse::AuthRoleAddResponse(const AuthRoleAddResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleAddResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleAddResponse)
}

inline void AuthRoleAddResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleAddResponse::~AuthRoleAddResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleAddResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleAddResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleAddResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleAddResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleAddResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleAddResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleAddResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleAddResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleAddResponse)
  return target;
}

::size_t AuthRoleAddResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleAddResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleAddResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleAddResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleAddResponse::GetClassData() const { return &_class_data_; }


void AuthRoleAddResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleAddResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleAddResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleAddResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleAddResponse::CopyFrom(const AuthRoleAddResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleAddResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleAddResponse::IsInitialized() const {
  return true;
}

void AuthRoleAddResponse::InternalSwap(AuthRoleAddResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleAddResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[84]);
}
// ===================================================================

class AuthRoleGetResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleGetResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleGetResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleGetResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleGetResponse::_Internal::header(const AuthRoleGetResponse* msg) {
  return *msg->_impl_.header_;
}
void AuthRoleGetResponse::clear_perm() {
  _internal_mutable_perm()->Clear();
}
AuthRoleGetResponse::AuthRoleGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleGetResponse)
}
AuthRoleGetResponse::AuthRoleGetResponse(const AuthRoleGetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleGetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.perm_){from._impl_.perm_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleGetResponse)
}

inline void AuthRoleGetResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.perm_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleGetResponse::~AuthRoleGetResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleGetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleGetResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_perm()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleGetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleGetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleGetResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_perm()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleGetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .authpb.Permission perm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_perm(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleGetResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleGetResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .authpb.Permission perm = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_perm_size()); i < n; i++) {
    const auto& repfield = this->_internal_perm(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleGetResponse)
  return target;
}

::size_t AuthRoleGetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleGetResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .authpb.Permission perm = 2;
  total_size += 1UL * this->_internal_perm_size();
  for (const auto& msg : this->_internal_perm()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleGetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleGetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleGetResponse::GetClassData() const { return &_class_data_; }


void AuthRoleGetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleGetResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleGetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleGetResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_perm()->MergeFrom(from._internal_perm());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleGetResponse::CopyFrom(const AuthRoleGetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleGetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleGetResponse::IsInitialized() const {
  return true;
}

void AuthRoleGetResponse::InternalSwap(AuthRoleGetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_perm()->InternalSwap(other->_internal_mutable_perm());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleGetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[85]);
}
// ===================================================================

class AuthRoleListResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleListResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleListResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleListResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleListResponse::_Internal::header(const AuthRoleListResponse* msg) {
  return *msg->_impl_.header_;
}
AuthRoleListResponse::AuthRoleListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleListResponse)
}
AuthRoleListResponse::AuthRoleListResponse(const AuthRoleListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roles_){from._impl_.roles_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleListResponse)
}

inline void AuthRoleListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roles_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleListResponse::~AuthRoleListResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_roles()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_roles()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string roles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_roles();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthRoleListResponse.roles"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated string roles = 2;
  for (int i = 0, n = this->_internal_roles_size(); i < n; ++i) {
    const auto& s = this->_internal_roles(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthRoleListResponse.roles");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleListResponse)
  return target;
}

::size_t AuthRoleListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string roles = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_roles().size());
  for (int i = 0, n = _internal_roles().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_roles().Get(i));
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleListResponse::GetClassData() const { return &_class_data_; }


void AuthRoleListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleListResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_roles()->MergeFrom(from._internal_roles());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleListResponse::CopyFrom(const AuthRoleListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleListResponse::IsInitialized() const {
  return true;
}

void AuthRoleListResponse::InternalSwap(AuthRoleListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_roles()->InternalSwap(
      other->_internal_mutable_roles());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[86]);
}
// ===================================================================

class AuthUserListResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthUserListResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthUserListResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthUserListResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthUserListResponse::_Internal::header(const AuthUserListResponse* msg) {
  return *msg->_impl_.header_;
}
AuthUserListResponse::AuthUserListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthUserListResponse)
}
AuthUserListResponse::AuthUserListResponse(const AuthUserListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthUserListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.users_){from._impl_.users_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthUserListResponse)
}

inline void AuthUserListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.users_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthUserListResponse::~AuthUserListResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthUserListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthUserListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_users()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthUserListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthUserListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthUserListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_users()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthUserListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string users = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_users();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "etcdserverpb.AuthUserListResponse.users"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthUserListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthUserListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated string users = 2;
  for (int i = 0, n = this->_internal_users_size(); i < n; ++i) {
    const auto& s = this->_internal_users(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "etcdserverpb.AuthUserListResponse.users");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthUserListResponse)
  return target;
}

::size_t AuthUserListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthUserListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string users = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_users().size());
  for (int i = 0, n = _internal_users().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_users().Get(i));
  }

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthUserListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthUserListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthUserListResponse::GetClassData() const { return &_class_data_; }


void AuthUserListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthUserListResponse*>(&to_msg);
  auto& from = static_cast<const AuthUserListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthUserListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_users()->MergeFrom(from._internal_users());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthUserListResponse::CopyFrom(const AuthUserListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthUserListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthUserListResponse::IsInitialized() const {
  return true;
}

void AuthUserListResponse::InternalSwap(AuthUserListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_users()->InternalSwap(
      other->_internal_mutable_users());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthUserListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[87]);
}
// ===================================================================

class AuthRoleDeleteResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleDeleteResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleDeleteResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleDeleteResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleDeleteResponse::_Internal::header(const AuthRoleDeleteResponse* msg) {
  return *msg->_impl_.header_;
}
AuthRoleDeleteResponse::AuthRoleDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleDeleteResponse)
}
AuthRoleDeleteResponse::AuthRoleDeleteResponse(const AuthRoleDeleteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleDeleteResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleDeleteResponse)
}

inline void AuthRoleDeleteResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleDeleteResponse::~AuthRoleDeleteResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleDeleteResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleDeleteResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleDeleteResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleDeleteResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleDeleteResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleDeleteResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleDeleteResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleDeleteResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleDeleteResponse)
  return target;
}

::size_t AuthRoleDeleteResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleDeleteResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleDeleteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleDeleteResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleDeleteResponse::GetClassData() const { return &_class_data_; }


void AuthRoleDeleteResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleDeleteResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleDeleteResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleDeleteResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleDeleteResponse::CopyFrom(const AuthRoleDeleteResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleDeleteResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleDeleteResponse::IsInitialized() const {
  return true;
}

void AuthRoleDeleteResponse::InternalSwap(AuthRoleDeleteResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleDeleteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[88]);
}
// ===================================================================

class AuthRoleGrantPermissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleGrantPermissionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleGrantPermissionResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleGrantPermissionResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleGrantPermissionResponse::_Internal::header(const AuthRoleGrantPermissionResponse* msg) {
  return *msg->_impl_.header_;
}
AuthRoleGrantPermissionResponse::AuthRoleGrantPermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleGrantPermissionResponse)
}
AuthRoleGrantPermissionResponse::AuthRoleGrantPermissionResponse(const AuthRoleGrantPermissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleGrantPermissionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleGrantPermissionResponse)
}

inline void AuthRoleGrantPermissionResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleGrantPermissionResponse::~AuthRoleGrantPermissionResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleGrantPermissionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleGrantPermissionResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleGrantPermissionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleGrantPermissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleGrantPermissionResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleGrantPermissionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleGrantPermissionResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleGrantPermissionResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleGrantPermissionResponse)
  return target;
}

::size_t AuthRoleGrantPermissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleGrantPermissionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleGrantPermissionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleGrantPermissionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleGrantPermissionResponse::GetClassData() const { return &_class_data_; }


void AuthRoleGrantPermissionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleGrantPermissionResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleGrantPermissionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleGrantPermissionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleGrantPermissionResponse::CopyFrom(const AuthRoleGrantPermissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleGrantPermissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleGrantPermissionResponse::IsInitialized() const {
  return true;
}

void AuthRoleGrantPermissionResponse::InternalSwap(AuthRoleGrantPermissionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleGrantPermissionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[89]);
}
// ===================================================================

class AuthRoleRevokePermissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthRoleRevokePermissionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthRoleRevokePermissionResponse, _impl_._has_bits_);
  static const ::etcdserverpb::ResponseHeader& header(const AuthRoleRevokePermissionResponse* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::etcdserverpb::ResponseHeader&
AuthRoleRevokePermissionResponse::_Internal::header(const AuthRoleRevokePermissionResponse* msg) {
  return *msg->_impl_.header_;
}
AuthRoleRevokePermissionResponse::AuthRoleRevokePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:etcdserverpb.AuthRoleRevokePermissionResponse)
}
AuthRoleRevokePermissionResponse::AuthRoleRevokePermissionResponse(const AuthRoleRevokePermissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthRoleRevokePermissionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::etcdserverpb::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:etcdserverpb.AuthRoleRevokePermissionResponse)
}

inline void AuthRoleRevokePermissionResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
  };
}

AuthRoleRevokePermissionResponse::~AuthRoleRevokePermissionResponse() {
  // @@protoc_insertion_point(destructor:etcdserverpb.AuthRoleRevokePermissionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthRoleRevokePermissionResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AuthRoleRevokePermissionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthRoleRevokePermissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:etcdserverpb.AuthRoleRevokePermissionResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthRoleRevokePermissionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .etcdserverpb.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthRoleRevokePermissionResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:etcdserverpb.AuthRoleRevokePermissionResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .etcdserverpb.ResponseHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:etcdserverpb.AuthRoleRevokePermissionResponse)
  return target;
}

::size_t AuthRoleRevokePermissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:etcdserverpb.AuthRoleRevokePermissionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .etcdserverpb.ResponseHeader header = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthRoleRevokePermissionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthRoleRevokePermissionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthRoleRevokePermissionResponse::GetClassData() const { return &_class_data_; }


void AuthRoleRevokePermissionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthRoleRevokePermissionResponse*>(&to_msg);
  auto& from = static_cast<const AuthRoleRevokePermissionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:etcdserverpb.AuthRoleRevokePermissionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::etcdserverpb::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthRoleRevokePermissionResponse::CopyFrom(const AuthRoleRevokePermissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:etcdserverpb.AuthRoleRevokePermissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthRoleRevokePermissionResponse::IsInitialized() const {
  return true;
}

void AuthRoleRevokePermissionResponse::InternalSwap(AuthRoleRevokePermissionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthRoleRevokePermissionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_rpc_2eproto_getter, &descriptor_table_rpc_2eproto_once,
      file_level_metadata_rpc_2eproto[90]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace etcdserverpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::etcdserverpb::ResponseHeader*
Arena::CreateMaybeMessage< ::etcdserverpb::ResponseHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::ResponseHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::RangeRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::RangeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::RangeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::RangeResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::RangeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::RangeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::PutRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::PutRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::PutRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::PutResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::PutResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::PutResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::DeleteRangeRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::DeleteRangeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::DeleteRangeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::DeleteRangeResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::DeleteRangeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::DeleteRangeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::RequestOp*
Arena::CreateMaybeMessage< ::etcdserverpb::RequestOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::RequestOp >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::ResponseOp*
Arena::CreateMaybeMessage< ::etcdserverpb::ResponseOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::ResponseOp >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::Compare*
Arena::CreateMaybeMessage< ::etcdserverpb::Compare >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::Compare >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::TxnRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::TxnRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::TxnRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::TxnResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::TxnResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::TxnResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::CompactionRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::CompactionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::CompactionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::CompactionResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::CompactionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::CompactionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::HashRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::HashRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::HashRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::HashKVRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::HashKVRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::HashKVRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::HashKVResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::HashKVResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::HashKVResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::HashResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::HashResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::HashResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::SnapshotRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::SnapshotRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::SnapshotRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::SnapshotResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::SnapshotResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::SnapshotResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::WatchRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::WatchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::WatchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::WatchCreateRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::WatchCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::WatchCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::WatchCancelRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::WatchCancelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::WatchCancelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::WatchProgressRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::WatchProgressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::WatchProgressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::WatchResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::WatchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::WatchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseGrantRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseGrantRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseGrantRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseGrantResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseGrantResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseGrantResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseRevokeRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseRevokeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseRevokeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseRevokeResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseRevokeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseRevokeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseCheckpoint*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseCheckpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseCheckpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseCheckpointRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseCheckpointRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseCheckpointRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseCheckpointResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseCheckpointResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseCheckpointResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseKeepAliveRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseKeepAliveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseKeepAliveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseKeepAliveResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseKeepAliveResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseKeepAliveResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseTimeToLiveRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseTimeToLiveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseTimeToLiveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseTimeToLiveResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseTimeToLiveResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseTimeToLiveResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseLeasesRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseLeasesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseLeasesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseStatus*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::LeaseLeasesResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::LeaseLeasesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::LeaseLeasesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::Member*
Arena::CreateMaybeMessage< ::etcdserverpb::Member >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::Member >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberAddRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberAddRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberAddRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberAddResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberAddResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberAddResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberRemoveRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberRemoveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberRemoveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberRemoveResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberRemoveResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberRemoveResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberUpdateRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberUpdateResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberListRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberListResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberPromoteRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberPromoteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberPromoteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MemberPromoteResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MemberPromoteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MemberPromoteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::DefragmentRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::DefragmentRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::DefragmentRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::DefragmentResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::DefragmentResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::DefragmentResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MoveLeaderRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::MoveLeaderRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MoveLeaderRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::MoveLeaderResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::MoveLeaderResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::MoveLeaderResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AlarmRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AlarmRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AlarmRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AlarmMember*
Arena::CreateMaybeMessage< ::etcdserverpb::AlarmMember >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AlarmMember >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AlarmResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AlarmResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AlarmResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::StatusRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::StatusRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::StatusRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::StatusResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::StatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::StatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthEnableRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthEnableRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthEnableRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthDisableRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthDisableRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthDisableRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthenticateRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthenticateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthenticateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserAddRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserAddRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserAddRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserGetRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserDeleteRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserChangePasswordRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserChangePasswordRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserChangePasswordRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserGrantRoleRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserGrantRoleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserGrantRoleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserRevokeRoleRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserRevokeRoleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserRevokeRoleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleAddRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleAddRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleAddRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleGetRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserListRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleListRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleDeleteRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleGrantPermissionRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleGrantPermissionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleGrantPermissionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleRevokePermissionRequest*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleRevokePermissionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleRevokePermissionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthEnableResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthEnableResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthEnableResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthDisableResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthDisableResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthDisableResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthenticateResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthenticateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthenticateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserAddResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserAddResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserAddResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserGetResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserGetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserGetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserDeleteResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserDeleteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserDeleteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserChangePasswordResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserChangePasswordResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserChangePasswordResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserGrantRoleResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserGrantRoleResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserGrantRoleResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserRevokeRoleResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserRevokeRoleResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserRevokeRoleResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleAddResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleAddResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleAddResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleGetResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleGetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleGetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleListResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthUserListResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthUserListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthUserListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleDeleteResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleDeleteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleDeleteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleGrantPermissionResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleGrantPermissionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleGrantPermissionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::etcdserverpb::AuthRoleRevokePermissionResponse*
Arena::CreateMaybeMessage< ::etcdserverpb::AuthRoleRevokePermissionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::etcdserverpb::AuthRoleRevokePermissionResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
